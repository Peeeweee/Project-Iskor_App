PROJECT DIRECTORY TREE (Filtered View)
======================================================================
project_-iskor-app
├── .gitignore
├── App.tsx
├── components
│   ├── AnalyticsPage.tsx
│   ├── AudienceView.tsx
│   ├── BoxScore.tsx
│   ├── charts
│   │   ├── BarChart.tsx
│   │   └── DonutChart.tsx
│   ├── ControlPanel.tsx
│   ├── CreateEditTeamModal.tsx
│   ├── Dashboard.tsx
│   ├── DeleteConfirmationModal.tsx
│   ├── form
│   │   └── ColorPicker.tsx
│   ├── HighestScoringGamesModal.tsx
│   ├── icons
│   │   ├── ArchiveIcon.tsx
│   │   ├── BasketballIcon.tsx
│   │   ├── CalendarIcon.tsx
│   │   ├── ChartBarIcon.tsx
│   │   ├── CheckIcon.tsx
│   │   ├── ClipboardListIcon.tsx
│   │   ├── ClockIcon.tsx
│   │   ├── CopyIcon.tsx
│   │   ├── DashboardIcon.tsx
│   │   ├── DatabaseIcon.tsx
│   │   ├── DocumentTextIcon.tsx
│   │   ├── DownloadIcon.tsx
│   │   ├── EditIcon.tsx
│   │   ├── ExitIcon.tsx
│   │   ├── FireIcon.tsx
│   │   ├── FullScreenIcon.tsx
│   │   ├── LayoutCenterIcon.tsx
│   │   ├── LayoutSplitIcon.tsx
│   │   ├── ListIcon.tsx
│   │   ├── MenuIcon.tsx
│   │   ├── MinimizeIcon.tsx
│   │   ├── MinusIcon.tsx
│   │   ├── MoonIcon.tsx
│   │   ├── PaletteIcon.tsx
│   │   ├── PauseIcon.tsx
│   │   ├── PictureInPictureIcon.tsx
│   │   ├── PlayIcon.tsx
│   │   ├── PlusIcon.tsx
│   │   ├── RedoIcon.tsx
│   │   ├── ResetIcon.tsx
│   │   ├── RestoreIcon.tsx
│   │   ├── SearchIcon.tsx
│   │   ├── SettingsIcon.tsx
│   │   ├── SlidersIcon.tsx
│   │   ├── SoccerIcon.tsx
│   │   ├── SparkleIcon.tsx
│   │   ├── SunIcon.tsx
│   │   ├── TrashIcon.tsx
│   │   ├── TrendingUpIcon.tsx
│   │   ├── TrophyIcon.tsx
│   │   ├── UnarchiveIcon.tsx
│   │   ├── UndoIcon.tsx
│   │   ├── UploadIcon.tsx
│   │   ├── UserIcon.tsx
│   │   ├── UsersIcon.tsx
│   │   ├── VolleyballIcon.tsx
│   │   └── WarningIcon.tsx
│   ├── LandingPage.tsx
│   ├── layout
│   │   ├── Header.tsx
│   │   ├── Layout.tsx
│   │   └── Sidebar.tsx
│   ├── MatchActions.tsx
│   ├── MatchDetailModal.tsx
│   ├── MatchHistoryPage.tsx
│   ├── MatchResult.tsx
│   ├── MatchView.tsx
│   ├── MiniAudienceWindow.tsx
│   ├── MostDecisiveVictoryModal.tsx
│   ├── MostPlayedSportModal.tsx
│   ├── Scoreboard.tsx
│   ├── settings
│   │   ├── AccountSettings.tsx
│   │   ├── DataSettings.tsx
│   │   ├── GeneralSettings.tsx
│   │   ├── PreferencesSettings.tsx
│   │   └── ThemeSettings.tsx
│   ├── SettingsPage.tsx
│   ├── SetupScreen.tsx
│   ├── SportIcon.tsx
│   ├── TeamDetailModal.tsx
│   ├── TeamSelector.tsx
│   ├── TeamsPage.tsx
│   └── TotalMatchesModal.tsx
├── constants.ts
├── create_snapshot.py
├── hooks
│   ├── useGameClock.ts
│   └── useGameLogic.ts
├── index.html
├── index.tsx
├── metadata.json
├── package-lock.json
├── package.json
├── README.md
├── src
│   ├── App.tsx
│   └── components
│       └── AnalyticsPage.tsx
├── tsconfig.json
├── types.ts
├── utils.ts
└── vite.config.ts


--- START FILE: .gitignore ---
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
--- END FILE: .gitignore ---

--- START FILE: App.tsx ---
import React, { useState, useCallback, useRef, useEffect } from 'react';
import type { MatchConfig, Theme, View, Match, SavedTeam, Settings, TeamStat, SportDefaultSettings } from './types';
import { GameStatus, Sport, Font, Layout as UILayout } from './types';
import { useGameLogic } from './hooks/useGameLogic';
import SetupScreen from './components/SetupScreen';
import Dashboard from './components/Dashboard';
import AudienceView from './components/AudienceView';
import MatchView from './components/MatchView';
import Layout from './components/layout/Layout';
import SettingsPage from './components/SettingsPage';
import LandingPage from './components/LandingPage';
import AnalyticsPage from './components/AnalyticsPage';
import MatchHistoryPage from './components/MatchHistoryPage';
import TeamsPage from './components/TeamsPage';
import { TEAM_COLORS } from './constants';
import { getDateFromId } from './utils';

const initialMatches: Match[] = [
  { id: '1', sport: Sport.Basketball, teamA: { name: 'Lakers', color: '#FDB927' }, teamB: { name: 'Warriors', color: '#006BB6' }, status: 'In Progress', durationMinutes: 12, durationSeconds: 0, periods: 4, gameMode: 'time' },
  { id: '2', sport: Sport.Soccer, teamA: { name: 'Real Madrid', color: '#FEBE10' }, teamB: { name: 'Barcelona', color: '#A50044' }, status: 'Finished', durationMinutes: 45, durationSeconds: 0, periods: 2, gameMode: 'time', finalScoreA: 6, finalScoreB: 4 },
  { id: '3', sport: Sport.Volleyball, teamA: { name: 'Brazil', color: '#009B3A' }, teamB: { name: 'USA', color: '#B31336' }, status: 'Upcoming', durationMinutes: 0, durationSeconds: 0, periods: 5, gameMode: 'time' },
  { id: '4', sport: Sport.Basketball, teamA: { name: 'Celtics', color: '#008348' }, teamB: { name: 'Heat', color: '#98002E' }, status: 'Finished', durationMinutes: 12, durationSeconds: 0, periods: 4, gameMode: 'time', finalScoreA: 9, finalScoreB: 6 },
  { id: '5', sport: Sport.Soccer, teamA: { name: 'Man United', color: '#DA291C' }, teamB: { name: 'Liverpool', color: '#C8102E' }, status: 'Upcoming', durationMinutes: 45, durationSeconds: 0, periods: 2, gameMode: 'time' },
  { id: '6', sport: Sport.Volleyball, teamA: { name: 'Poland', color: '#DC143C' }, teamB: { name: 'Italy', color: '#008C45' }, status: 'In Progress', durationMinutes: 0, durationSeconds: 0, periods: 5, gameMode: 'time' },
];

const App: React.FC = () => {
    const [view, setView] = useState<View>('landing');
    const [settings, setSettings] = useState<Settings>(() => {
        const saved = localStorage.getItem('scoreboardSettings');
        const defaultSettings: Settings = {
            theme: 'dark',
            font: Font.Display,
            layout: UILayout.Wide,
            defaultSport: Sport.Basketball,
            defaultTeamAColor: TEAM_COLORS[0],
            defaultTeamBColor: TEAM_COLORS[1],
            sportDefaults: {
                [Sport.Basketball]: { durationMinutes: 12, durationSeconds: 0, periods: 4, targetScore: 21 },
                [Sport.Soccer]: { durationMinutes: 45, durationSeconds: 0, periods: 2, targetScore: 10 },
                [Sport.Volleyball]: { durationMinutes: 0, durationSeconds: 0, periods: 5, targetScore: 25 },
            }
        };
        try {
            if (saved) {
                // Deep merge to ensure new settings properties are added
                const parsed = JSON.parse(saved);
                return { 
                    ...defaultSettings, 
                    ...parsed,
                    sportDefaults: {
                        ...defaultSettings.sportDefaults,
                        ...(parsed.sportDefaults || {})
                    }
                };
            }
            const legacyTheme = localStorage.getItem('theme') as Theme | null;
            if (legacyTheme) {
                defaultSettings.theme = legacyTheme;
                localStorage.removeItem('theme');
            }
        } catch (error) {
            console.error("Could not parse settings from localStorage", error);
        }
        return defaultSettings;
    });

    const [matchConfig, setMatchConfig] = useState<MatchConfig | null>(null);
    const [activeMatchId, setActiveMatchId] = useState<string | null>(null);
    const [matches, setMatches] = useState<Match[]>(() => {
        try {
            const savedMatches = localStorage.getItem('matches');
            return savedMatches ? JSON.parse(savedMatches) : initialMatches;
        } catch (error) {
            console.error("Could not parse matches from localStorage", error);
            return initialMatches;
        }
    });
    
    const [savedTeams, setSavedTeams] = useState<SavedTeam[]>(() => {
        try {
            const storedTeams = localStorage.getItem('savedTeams');
            return storedTeams ? JSON.parse(storedTeams) : [];
        } catch (error) {
            console.error("Could not parse saved teams from localStorage", error);
            return [];
        }
    });

    const [searchQuery, setSearchQuery] = useState('');
    const [isExportingPdf, setIsExportingPdf] = useState(false);


    const { gameState, time, isRunning, actions, canUndo, canRedo } = useGameLogic(matchConfig, activeMatchId);

    useEffect(() => {
        localStorage.setItem('matches', JSON.stringify(matches));
    }, [matches]);
    
     useEffect(() => {
        localStorage.setItem('savedTeams', JSON.stringify(savedTeams));
    }, [savedTeams]);

    useEffect(() => {
        localStorage.setItem('scoreboardSettings', JSON.stringify(settings));
        const root = window.document.documentElement;
        root.className = '';
        root.classList.add(settings.theme);
    }, [settings]);

    const updateSettings = (newSettings: Partial<Settings>) => {
        setSettings(prev => ({ ...prev, ...newSettings }));
    };

    const navigateTo = (newView: View) => {
      setSearchQuery(''); // Clear search when navigating
      setView(newView);
    };

    const handleLeaveMatch = () => {
        setMatchConfig(null);
        setActiveMatchId(null);
        navigateTo('dashboard');
    };

    const setupMatchForControl = (match: Match) => {
         const config: MatchConfig = {
            sport: match.sport,
            teamA: match.teamA,
            teamB: match.teamB,
            durationMinutes: match.durationMinutes,
            durationSeconds: match.durationSeconds,
            periods: match.periods,
            gameMode: match.gameMode,
            targetScore: match.targetScore,
        };
        setMatchConfig(config);
        setActiveMatchId(match.id);
    };

    const handleManageMatch = (match: Match) => {
        setupMatchForControl(match);
        navigateTo('match');
    };
    
    const handleGoToAudienceView = (match: Match) => {
        setActiveMatchId(match.id);
        setMatchConfig({
             sport: match.sport,
            teamA: match.teamA,
            teamB: match.teamB,
            durationMinutes: match.durationMinutes,
            durationSeconds: match.durationSeconds,
            periods: match.periods,
            gameMode: match.gameMode,
            targetScore: match.targetScore,
        });
        navigateTo('audience');
    };

    const handleMatchStart = (config: MatchConfig) => {
        const newMatch: Match = {
            ...config,
            id: `match-${Date.now()}`,
            status: 'Upcoming',
        };
        setMatches(prev => [...prev, newMatch]);
        setMatchConfig(config);
        setActiveMatchId(newMatch.id);
        navigateTo('match');
    };

    const handleDeleteMatch = (matchId: string) => {
        setMatches(prev => prev.filter(match => match.id !== matchId));
        localStorage.removeItem(`match-state-${matchId}`);
    };

    const handleArchiveMatch = (matchId: string) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isArchived: true } : match
            )
        );
    };
    
    const handleToggleCompleteMatch = (matchId: string, isCompleted: boolean) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isCompleted } : match
            )
        );
    };

    const handleUnarchiveMatch = (matchId: string) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isArchived: false } : match
            )
        );
    };
    
    const handleUpdateMatchConfig = (matchId: string, newConfig: Partial<MatchConfig>) => {
        let updatedMatch: Match | undefined;
        setMatches(prev =>
            prev.map(match => {
                if (match.id === matchId) {
                    updatedMatch = { ...match, ...newConfig };
                    return updatedMatch;
                }
                return match;
            })
        );

        if (activeMatchId === matchId && updatedMatch) {
            setMatchConfig(updatedMatch);
        }
    };
    
    const handleSaveTeam = (team: Omit<SavedTeam, 'id'> & { id?: string }) => {
        if (team.id) {
            setSavedTeams(prev => prev.map(t => t.id === team.id ? { ...t, name: team.name, color: team.color, sport: team.sport } : t));
        } else {
            const newTeam = { ...team, id: `team-${Date.now()}` };
            setSavedTeams(prev => [...prev, newTeam]);
            return newTeam; // Return the new team to be auto-selected
        }
    };

    const handleDeleteTeam = (teamId: string) => {
        setSavedTeams(prev => prev.filter(t => t.id !== teamId));
    };

    const handleExportData = () => {
        try {
            const dataToExport = {
                matches: JSON.parse(localStorage.getItem('matches') || '[]'),
                savedTeams: JSON.parse(localStorage.getItem('savedTeams') || '[]'),
                settings: JSON.parse(localStorage.getItem('scoreboardSettings') || '{}'),
            };
            const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(dataToExport, null, 2))}`;
            const link = document.createElement("a");
            link.href = jsonString;
            link.download = `scoreboard_pro_backup_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        } catch (error) {
            console.error("Failed to export data:", error);
            alert("Error exporting data.");
        }
    };

    const handleExportPdf = async () => {
        setIsExportingPdf(true);
        try {
            const { default: jsPDF } = await import('jspdf');
            const { default: autoTable } = await import('jspdf-autotable');

            const doc = new jsPDF();
            const pageHeight = doc.internal.pageSize.height;
            let finalY = 0;

            doc.setFontSize(22).setFont('helvetica', 'bold');
            doc.text('Project: Iskor-App', 105, 20, { align: 'center' });
            doc.setFontSize(16).setFont('helvetica', 'normal');
            doc.text('Data Export', 105, 30, { align: 'center' });
            doc.setFontSize(12);
            doc.text(`Export Date: ${new Date().toLocaleDateString()}`, 105, 40, { align: 'center' });

            const tableOptions = {
                startY: 60,
                headStyles: { fillColor: '#16A3B8' },
                theme: 'grid' as const, // FIX: Added 'as const' to assert literal type
                didDrawPage: (data: any) => { finalY = data.cursor.y; }
            };

            doc.setFontSize(18).setFont('helvetica', 'bold');
            doc.text('Application Settings', 14, tableOptions.startY - 10);
            autoTable(doc, { ...tableOptions, head: [['Setting', 'Value']], body: [
                ['Theme', settings.theme], ['Default Sport', settings.defaultSport],
                ['Audience View Font', settings.font], ['Audience View Layout', settings.layout],
                ['Default Team A Color', settings.defaultTeamAColor], ['Default Team B Color', settings.defaultTeamBColor],
            ]});

            const checkNewPage = (yPos: number) => {
                if (yPos + 40 > pageHeight) { doc.addPage(); return 30; }
                return yPos + 20;
            };

            let currentY = checkNewPage(finalY);
            
            const finishedMatches = matches.filter((m): m is Match & { finalScoreA: number; finalScoreB: number } => 
                m.status === 'Finished' && typeof m.finalScoreA === 'number' && typeof m.finalScoreB === 'number'
            );

            if (finishedMatches.length > 0) {
                doc.setFontSize(18).setFont('helvetica', 'bold');
                doc.text('Analytics Overview', 14, currentY - 10);

                const sportCounts = finishedMatches.reduce((acc: Record<Sport, number>, match) => {
                    acc[match.sport] = (acc[match.sport] || 0) + 1;
                    return acc;
                }, {} as Record<Sport, number>);

                const maxCount = Math.max(0, ...Object.values(sportCounts) as number[]);
                const mostPlayedSportName = Object.entries(sportCounts)
                    .filter(([, count]) => count === maxCount)
                    .map(([sport]) => sport)
                    .join(', ');

                const highestGamesBySport = (Object.values(Sport) as Sport[]).reduce((acc, sport: Sport) => {
                    const sportMatches = finishedMatches.filter(m => m.sport === sport);
                    if (sportMatches.length > 0) {
                        acc[sport] = sportMatches.reduce((max, match) => {
                            const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
                            return totalScore > max.total ? { total: totalScore } : max;
                        }, { total: (sportMatches[0].finalScoreA ?? 0) + (sportMatches[0].finalScoreB ?? 0) });
                    } else {
                        acc[sport] = { total: 0 };
                    }
                    return acc;
                }, {} as Record<Sport, { total: number }>);

                const highestScoresText = (Object.values(Sport) as Sport[]).map(sport => `${sport}: ${highestGamesBySport[sport]?.total ?? '0'}`).join('\n');

                const mostDecisiveVictoriesBySport = (Object.values(Sport) as Sport[]).reduce((acc, sport: Sport) => {
                    const sportMatches = finishedMatches.filter(m => m.sport === sport);
                    if (sportMatches.length > 0) {
                        acc[sport] = sportMatches.reduce((max, match) => {
                            const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
                            return diff > max.diff ? { diff } : max;
                        }, { diff: Math.abs((sportMatches[0].finalScoreA ?? 0) - (sportMatches[0].finalScoreB ?? 0)) });
                    } else {
                        acc[sport] = { diff: 0 };
                    }
                    return acc;
                }, {} as Record<Sport, { diff: number }>);
                
                const mostDecisiveText = (Object.values(Sport) as Sport[]).map(sport => `${sport}: +${mostDecisiveVictoriesBySport[sport]?.diff ?? '0'}`).join('\n');

                autoTable(doc, {
                    ...tableOptions,
                    startY: currentY,
                    head: [['Metric', 'Value']],
                    body: [
                        ['Total Matches Played', finishedMatches.length.toString()],
                        ['Most Played Sport(s)', mostPlayedSportName],
                        ['Highest Scoring Games (Total Points)', highestScoresText],
                        ['Most Decisive Victories (Point Diff)', mostDecisiveText],
                    ],
                     didParseCell: (data) => {
                        if (data.row.index >= 2) {
                            (data.cell.styles as any).cellWidth = 'wrap';
                        }
                    },
                });

                currentY = checkNewPage(finalY);
            }
            
            if (savedTeams.length > 0) {
              doc.setFontSize(18).setFont('helvetica', 'bold');
              doc.text('Saved Teams', 14, currentY - 10);
              autoTable(doc, { ...tableOptions, startY: currentY, head: [['Name', 'Color', 'Sport Association']], body: savedTeams.map(team => [team.name, team.color, team.sport || 'Universal'])});
              currentY = checkNewPage(finalY);
            }
            
            if (finishedMatches.length > 0) {
                const teamStats = finishedMatches.reduce((acc, match) => {
                    const teams = [match.teamA, match.teamB];
                    const scores = [match.finalScoreA, match.finalScoreB];
                    for (let i = 0; i < teams.length; i++) {
                        const team = teams[i];
                        if (!acc[team.name]) acc[team.name] = { wins: 0, losses: 0, ties: 0, totalGames: 0, teamConfig: team };
                        acc[team.name].totalGames++;
                        if (scores[i] > scores[1 - i]) acc[team.name].wins++;
                        else if (scores[i] < scores[1 - i]) acc[team.name].losses++;
                        else acc[team.name].ties++;
                    }
                    return acc;
                }, {} as Record<string, TeamStat>);

                const leaderboard = (Object.values(teamStats) as TeamStat[]).map((team: TeamStat) => ({
                    ...team,
                    winRate: team.totalGames > 0 ? (team.wins / team.totalGames * 100) : 0,
                })).sort((a, b) => b.wins - a.wins || b.winRate - a.winRate);
                
                const top5Teams = leaderboard.slice(0, 5);

                if (top5Teams.length > 0) {
                    doc.setFontSize(18).setFont('helvetica', 'bold');
                    doc.text('Top 5 Teams Leaderboard', 14, currentY - 10);
                    autoTable(doc, {
                        ...tableOptions, startY: currentY,
                        head: [['#', 'Team', 'W', 'L', 'GP', 'Win %']],
                        body: top5Teams.map((team, index) => [
                            index + 1, team.teamConfig.name, team.wins, team.losses, team.totalGames, `${team.winRate.toFixed(1)}%`
                        ]),
                        didParseCell: (data) => {
                            if (data.section === 'body' && data.column.index === 1) {
                                const teamStat = top5Teams[data.row.index];
                                if (teamStat) (data.cell.styles as any).textColor = teamStat.teamConfig.color;
                            }
                        }
                    });
                    currentY = checkNewPage(finalY);
                }

                doc.setFontSize(18).setFont('helvetica', 'bold');
                doc.text('Completed Match History', 14, currentY - 10);
                autoTable(doc, {
                    ...tableOptions, startY: currentY,
                    head: [['Date', 'Sport', 'Matchup', 'Final Score', 'Winner']],
                    body: finishedMatches.map(match => {
                        const winner = (match.finalScoreA ?? 0) > (match.finalScoreB ?? 0) ? match.teamA.name : ((match.finalScoreB ?? 0) > (match.finalScoreA ?? 0) ? match.teamB.name : 'Tie');
                        return [getDateFromId(match.id, { year: 'numeric', month: 'short', day: 'numeric' }), match.sport, `${match.teamA.name} vs ${match.teamB.name}`, `${match.finalScoreA} - ${match.finalScoreB}`, winner];
                    }),
                });
            }

            doc.save(`scoreboard_pro_export_${new Date().toISOString().split('T')[0]}.pdf`);

        } catch (error) {
            console.error("Failed to export PDF:", error);
            alert("Error exporting PDF. Check console for details.");
        } finally {
            setIsExportingPdf(false);
        }
    };

    const handleImportData = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const text = e.target?.result;
                if (typeof text !== 'string') throw new Error("File is not readable.");
                const data = JSON.parse(text);
                if (data.matches && data.savedTeams && data.settings) {
                    if (window.confirm("Are you sure you want to import this data? This will overwrite all your current matches, teams, and settings.")) {
                        setMatches(data.matches);
                        setSavedTeams(data.savedTeams);
                        setSettings(data.settings);
                        alert("Data imported successfully!");
                        navigateTo('dashboard');
                    }
                } else {
                    throw new Error("Invalid backup file format. The file must contain 'matches', 'savedTeams', and 'settings' keys.");
                }
            } catch (error) {
                alert(`Error importing data: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        };
        reader.readAsText(file);
    };

    const handleClearData = () => {
        if (window.prompt('This action is irreversible and will delete all your matches, teams, and settings. To confirm, please type "DELETE" below.') === 'DELETE') {
            localStorage.removeItem('matches');
            localStorage.removeItem('savedTeams');
            localStorage.removeItem('scoreboardSettings');
            window.location.reload();
        }
    };

    useEffect(() => {
        if (!activeMatchId || !gameState?.status) return;

        const newStatus = (() => {
            switch (gameState.status) {
                case GameStatus.InProgress:
                case GameStatus.Paused:
                case GameStatus.PeriodBreak:
                    return 'In Progress';
                case GameStatus.Finished:
                    return 'Finished';
                case GameStatus.NotStarted:
                default:
                    return 'Upcoming';
            }
        })();

        setMatches(prevMatches =>
            prevMatches.map(match => {
                if (match.id === activeMatchId) {
                    const updatedMatch: Match = { ...match, status: newStatus };
                    if (newStatus === 'Finished' && gameState) {
                        updatedMatch.finalScoreA = gameState.teamA.score;
                        updatedMatch.finalScoreB = gameState.teamB.score;
                        updatedMatch.periodScores = gameState.periodScores;
                    }
                    return updatedMatch;
                }
                return match;
            })
        );
    }, [gameState?.status, activeMatchId, gameState]);

    const renderView = () => {
        const handleCreateMatch = () => navigateTo('setup');
        const handleGoToHistory = () => navigateTo('history');
        const dashboardProps = {
            matches,
            onManageMatch: handleManageMatch,
            onGoToAudienceView: handleGoToAudienceView,
            onCreateMatch: handleCreateMatch,
            onDeleteMatch: handleDeleteMatch,
            onArchiveMatch: handleArchiveMatch,
            onUnarchiveMatch: handleUnarchiveMatch,
            onGoToHistory: handleGoToHistory,
            onToggleCompleteMatch: handleToggleCompleteMatch,
            searchQuery
        };

        switch (view) {
            case 'dashboard':
                return <Dashboard {...dashboardProps} />;
            case 'setup':
                return <SetupScreen onStartMatch={handleMatchStart} onBack={() => navigateTo('dashboard')} savedTeams={savedTeams} onSaveTeam={handleSaveTeam} settings={settings} />;
            case 'settings':
                return <SettingsPage settings={settings} updateSettings={updateSettings} onExportData={handleExportData} onImportData={handleImportData} onClearData={handleClearData} onExportPdf={handleExportPdf} isExportingPdf={isExportingPdf} />;
            case 'analytics':
                return <AnalyticsPage matches={matches} />;
            case 'history':
                return <MatchHistoryPage matches={matches} />;
            case 'teams':
                return <TeamsPage savedTeams={savedTeams} onSaveTeam={handleSaveTeam} onDeleteTeam={handleDeleteTeam} searchQuery={searchQuery} />;
            case 'match':
                if (matchConfig && gameState && activeMatchId) {
                    const activeMatch = matches.find(m => m.id === activeMatchId);
                    if (activeMatch) {
                        return <MatchView
                            match={activeMatch}
                            matchConfig={matchConfig}
                            gameState={gameState}
                            clock={{ time, isRunning }}
                            actions={actions}
                            onLeaveMatch={handleLeaveMatch}
                            activeMatchId={activeMatchId}
                            onUpdateMatchConfig={(newConfig) => handleUpdateMatchConfig(activeMatchId, newConfig)}
                            canUndo={canUndo}
                            canRedo={canRedo}
                            theme={settings.theme}
                            toggleTheme={cycleTheme}
                        />;
                    }
                }
                return <Dashboard {...dashboardProps} />;
            default:
                return <Dashboard {...dashboardProps} />;
        }
    };
    
    const themes: Theme[] = ['light', 'dark', 'viola', 'coder'];
    const cycleTheme = () => {
        const currentIndex = themes.indexOf(settings.theme);
        const nextIndex = (currentIndex + 1) % themes.length;
        updateSettings({ theme: themes[nextIndex] });
    };

    if (view === 'landing') {
        return <LandingPage onGetStarted={() => navigateTo('dashboard')} toggleTheme={cycleTheme} theme={settings.theme} />;
    }
    
    if (view === 'audience' && matchConfig && activeMatchId) {
        return <AudienceView config={matchConfig} matchId={activeMatchId} onExit={() => navigateTo('dashboard')} theme={settings.theme} />;
    }

    return (
      <Layout 
        activeView={view}
        navigateTo={navigateTo}
        theme={settings.theme}
        toggleTheme={cycleTheme}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
      >
        {renderView()}
      </Layout>
    );
};

export default App;
--- END FILE: App.tsx ---

--- START FILE: components\AnalyticsPage.tsx ---
import React, { useMemo, useState, useEffect, useRef } from 'react';
import type { Match, TeamConfig, TeamStat } from '../types';
import { Sport } from '../types';
import ListIcon from './icons/ListIcon';
import FireIcon from './icons/FireIcon';
import TrendingUpIcon from './icons/TrendingUpIcon';
import ChartBarIcon from './icons/ChartBarIcon';
import TeamDetailModal from './TeamDetailModal';
import DonutChart from './charts/DonutChart';
import BarChart from './charts/BarChart';
import TotalMatchesModal from './TotalMatchesModal';
import MostPlayedSportModal from './MostPlayedSportModal';
import HighestScoringGamesModal from './HighestScoringGamesModal';
import SportIcon from './SportIcon';
import MostDecisiveVictoryModal from './MostDecisiveVictoryModal';


interface AnalyticsPageProps {
  matches: Match[];
}

const easeOutQuad = (t: number) => t * (2 - t);

const useCountUp = (end: number = 0, duration = 1500) => {
    const [count, setCount] = useState(0);
    // FIX: Initialize useRef with null for better type safety.
    const animationFrameRef = useRef<number | null>(null);

    useEffect(() => {
        let startTime: number | null = null;
        
        const animate = (timestamp: number) => {
            if (!startTime) {
                startTime = timestamp;
            }
            
            const progress = timestamp - startTime;
            const percentage = Math.min(progress / duration, 1);
            const easedPercentage = easeOutQuad(percentage);
            
            const currentCount = Math.round(end * easedPercentage);
            setCount(currentCount);
            
            if (progress < duration) {
                animationFrameRef.current = requestAnimationFrame(animate);
            } else {
                setCount(end); // Ensure it ends on the exact value
            }
        };

        // Reset count to 0 to start animation from the beginning when 'end' value changes
        setCount(0);
        animationFrameRef.current = requestAnimationFrame(animate);

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [end, duration]);
    
    return count;
};

interface KpiCardProps {
    icon: React.ReactNode;
    title: string;
    value?: string | number;
    children?: React.ReactNode;
    description: React.ReactNode;
    isCounting?: boolean;
    prefix?: string;
    suffix?: string;
}

const KpiCard: React.FC<KpiCardProps> = ({ icon, title, value, children, description, isCounting = false, prefix = '', suffix = '' }) => {
    const endValueForCountUp = parseFloat(String(value)) || 0;
    const animatedValue = useCountUp(endValueForCountUp, 1500);
    const displayValue = isCounting ? `${prefix}${animatedValue}${suffix}` : value;

    const valueIsString = typeof displayValue === 'string';
    // Adjust font size based on string length to prevent overflow and keep it looking good.
    const valueSizeClass = valueIsString && displayValue.length > 20 
        ? 'text-lg' 
        : valueIsString && displayValue.length > 12 
        ? 'text-xl' 
        : 'text-2xl';

    return (
        <div className="bg-light-card dark:bg-dark-card techy-bg p-6 rounded-xl shadow-sm flex items-start gap-4 card-glow-on-hover h-full">
            <div className="bg-brand-blue/10 text-brand-blue p-3 rounded-lg">
                {icon}
            </div>
            <div className="flex-1">
                <p className="text-sm font-semibold text-light-text-muted dark:text-dark-text-muted">{title}</p>
                {children ? (
                    <div className="mt-1">{children}</div>
                ) : (
                    <p className={`${valueSizeClass} font-bold font-display break-words`}>{displayValue}</p>
                )}
                <p className="text-xs text-light-text-muted dark:text-dark-text-muted">{description}</p>
            </div>
        </div>
    );
};

const AnalyticsPage: React.FC<AnalyticsPageProps> = ({ matches }) => {
    const [selectedSport, setSelectedSport] = useState<Sport | 'All'>('All');
    const [selectedTeam, setSelectedTeam] = useState<TeamStat | null>(null);
    const [isTotalMatchesModalOpen, setIsTotalMatchesModalOpen] = useState(false);
    const [isMostPlayedSportModalOpen, setIsMostPlayedSportModalOpen] = useState(false);
    const [isHighestScoringGamesModalOpen, setIsHighestScoringGamesModalOpen] = useState(false);
    const [isMostDecisiveVictoryModalOpen, setIsMostDecisiveVictoryModalOpen] = useState(false);

    
    const allFinishedMatches = useMemo<(Match & { finalScoreA: number; finalScoreB: number; })[]>(() => 
        matches.filter((m): m is Match & { finalScoreA: number; finalScoreB: number } =>
            m.status === 'Finished' && typeof m.finalScoreA === 'number' && typeof m.finalScoreB === 'number'
        )
    , [matches]);

    const finishedMatches = useMemo<(Match & { finalScoreA: number; finalScoreB: number; })[]>(() => {
        if (selectedSport === 'All') {
            return allFinishedMatches;
        }
        return allFinishedMatches.filter(m => m.sport === selectedSport);
    }, [allFinishedMatches, selectedSport]);


    const stats = useMemo(() => {
        if (allFinishedMatches.length === 0) return null;

        const sportCounts = allFinishedMatches
            .reduce((acc: Record<Sport, number>, match) => {
                acc[match.sport] = (acc[match.sport] || 0) + 1;
                return acc;
            }, {} as Record<Sport, number>);

        const mostPlayedSportNames = (() => {
            if (Object.keys(sportCounts).length === 0) return ['N/A'];
            // Coerce to number[] to ensure type safety with Math.max in strict mode.
            const maxCount = Math.max(0, ...Object.values(sportCounts) as number[]);
            return Object.entries(sportCounts)
                .filter(([, count]) => count === maxCount)
                .map(([sport]) => sport);
        })();

        const mostPlayedSportName = mostPlayedSportNames.join(', ');
        
        const highestScoringGame = finishedMatches.reduce((max: { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
            const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
            return totalScore > max.total ? { match, total: totalScore } : max;
        }, { match: null, total: 0 });

        const mostDecisiveVictory = finishedMatches.reduce((max: { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
            const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
            return diff > max.diff ? { match, diff } : max;
        }, { match: null, diff: 0 });

        const matchesBySport = allFinishedMatches.reduce((acc: Record<Sport, number>, match) => {
            acc[match.sport] = (acc[match.sport] || 0) + 1;
            return acc;
        }, {} as Record<Sport, number>);

        const createLeaderboard = (matchesForLeaderboard: (Match & { finalScoreA: number; finalScoreB: number; })[]) => {
            const teamStats = matchesForLeaderboard.reduce((acc: Record<string, TeamStat>, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
                const { teamA, teamB, finalScoreA, finalScoreB } = match;
                const teams = [teamA, teamB];
                const scores = [finalScoreA ?? 0, finalScoreB ?? 0];

                for (let i = 0; i < teams.length; i++) {
                    const team = teams[i];
                    if (!acc[team.name]) {
                        acc[team.name] = { wins: 0, losses: 0, ties: 0, totalGames: 0, teamConfig: team };
                    }
                    acc[team.name].totalGames++;
                    if (scores[i] > scores[1 - i]) {
                        acc[team.name].wins++;
                    } else if (scores[i] < scores[1 - i]) {
                        acc[team.name].losses++;
                    } else {
                        acc[team.name].ties++;
                    }
                }
                return acc;
            }, {} as Record<string, TeamStat>);

            // FIX: In a strict TypeScript environment, `Object.values` on a record can return `unknown[]`.
            // Added `as TeamStat[]` to assert the correct type.
            return (Object.values(teamStats) as TeamStat[])
                .map((team: TeamStat) => ({
                    ...team,
                    winRate: team.totalGames > 0 ? (team.wins / team.totalGames * 100) : 0,
                }))
                .sort((a, b) => b.wins - a.wins || b.winRate - a.winRate);
        };

        const leaderboard = createLeaderboard(finishedMatches);

        const calculateHighestScores = (filteredMatches: typeof allFinishedMatches) => {
            return (Object.values(Sport) as Sport[]).reduce((acc: Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }>, sport: Sport) => {
                const sportMatches = filteredMatches.filter(m => m.sport === sport);
                if (sportMatches.length > 0) {
                    acc[sport] = sportMatches.reduce((max, match) => {
                        const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
                        return totalScore > max.total ? { match, total: totalScore } : max;
                    }, { match: sportMatches[0], total: (sportMatches[0].finalScoreA ?? 0) + (sportMatches[0].finalScoreB ?? 0) });
                } else {
                    acc[sport] = { match: null, total: 0 };
                }
                return acc;
            }, {} as Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }>);
        };
        
        const calculateMostDecisive = (filteredMatches: typeof allFinishedMatches) => {
            return (Object.values(Sport) as Sport[]).reduce((acc: Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }>, sport: Sport) => {
                const sportMatches = filteredMatches.filter(m => m.sport === sport);
                if (sportMatches.length > 0) {
                    acc[sport] = sportMatches.reduce((max, match) => {
                        const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
                        return diff > max.diff ? { match, diff } : max;
                    }, { match: sportMatches[0], diff: Math.abs((sportMatches[0].finalScoreA ?? 0) - (sportMatches[0].finalScoreB ?? 0)) });
                } else {
                    acc[sport] = { match: null, diff: 0 };
                }
                return acc;
            }, {} as Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }>);
        };
        
        const timeBasedMatches = allFinishedMatches.filter(m => (m.gameMode || 'time') === 'time');
        const scoreBasedMatches = allFinishedMatches.filter(m => m.gameMode === 'score');

        const timeBasedLeaderboard = createLeaderboard(
            selectedSport === 'All' ? timeBasedMatches : timeBasedMatches.filter(m => m.sport === selectedSport)
        );
        const scoreBasedLeaderboard = createLeaderboard(
            selectedSport === 'All' ? scoreBasedMatches : scoreBasedMatches.filter(m => m.sport === selectedSport)
        );


        return { 
            kpis: {mostPlayedSportName, highestScoringGame, mostDecisiveVictory}, 
            matchesBySport, 
            leaderboard, 
            highestGamesBySport: calculateHighestScores(allFinishedMatches), 
            mostDecisiveVictoriesBySport: calculateMostDecisive(allFinishedMatches),
            highestGamesBySportTime: calculateHighestScores(timeBasedMatches),
            highestGamesBySportScore: calculateHighestScores(scoreBasedMatches),
            mostDecisiveVictoriesBySportTime: calculateMostDecisive(timeBasedMatches),
            mostDecisiveVictoriesBySportScore: calculateMostDecisive(scoreBasedMatches),
            timeBasedLeaderboard,
            scoreBasedLeaderboard,
        };

    }, [allFinishedMatches, finishedMatches, selectedSport]);
    

    const renderContent = () => {
        if (!stats) {
            return (
                <div className="bg-light-card dark:bg-dark-card rounded-lg p-8 text-center shadow-sm mt-8">
                    <h2 className="text-2xl font-bold mb-4">No Data Yet!</h2>
                    <p className="text-light-text-muted dark:text-dark-text-muted">
                        No finished matches found for {selectedSport}. Play some games to see your analytics here.
                    </p>
                </div>
            );
        }

        const sportColorMap: Record<Sport, string> = {
            [Sport.Basketball]: '#F97316', // orange-500
            [Sport.Soccer]: '#10B981', // emerald-500
            [Sport.Volleyball]: '#0EA5E9', // sky-500
        };
        
        const sportColorTextClasses: Record<Sport, string> = {
            [Sport.Basketball]: 'text-orange-500',
            [Sport.Soccer]: 'text-green-500',
            [Sport.Volleyball]: 'text-sky-500',
        };

        // FIX: Cast the result of Object.entries to a specific tuple type [Sport, number][]
        // to ensure type safety for 'sport' and 'count' in strict mode.
        const donutChartData = (Object.entries(stats.matchesBySport) as [Sport, number][])
          .map(([sport, count]) => ({
            label: sport,
            value: count,
            color: sportColorMap[sport] || '#6B7280',
          }))
          .sort((a, b) => b.value - a.value);
        
        const topTeams = stats.leaderboard.slice(0, 5);
        const barChartData = topTeams.map(team => ({
            label: team.teamConfig.name,
            color: team.teamConfig.color,
            totalGames: team.totalGames,
            values: [
                { value: team.wins, color: '#22C55E', label: 'Wins' },
                { value: team.losses, color: '#EF4444', label: 'Losses' },
                { value: team.ties, color: '#6B7280', label: 'Ties' },
            ]
        }));

        return (
            <div key={selectedSport} className="animate-fade-in">
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 my-8">
                   <button
                        onClick={() => setIsTotalMatchesModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{animationDelay: '100ms'}}
                        aria-label="View details for all played matches"
                    >
                        <KpiCard icon={<ListIcon />} title="Total Matches Played" value={allFinishedMatches.length} description="Click to view all games" isCounting />
                    </button>
                    <button
                        onClick={() => setIsMostPlayedSportModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{ animationDelay: '200ms' }}
                        aria-label="View sport popularity breakdown"
                    >
                        <KpiCard icon={<ChartBarIcon />} title="Most Played Sport" value={stats.kpis.mostPlayedSportName} description="Click to see breakdown" />
                    </button>
                   <button
                        onClick={() => setIsHighestScoringGamesModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{ animationDelay: '300ms' }}
                        aria-label="View highest scoring games by sport"
                    >
                     <KpiCard 
                        icon={<FireIcon />} 
                        title="Highest Scoring Game" 
                        description="Click to see breakdown"
                    >
                        <div className="flex items-end justify-around gap-2 mt-2 w-full text-center">
                            {(Object.values(Sport) as Sport[]).map(sport => (
                                <div key={sport} className="flex flex-col items-center flex-1">
                                    <SportIcon sport={sport} className={`h-5 w-5 mb-1 ${sportColorTextClasses[sport]}`} />
                                    <span className="text-xl font-bold font-mono">
                                        {stats.highestGamesBySport[sport]?.total ?? '-'}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </KpiCard>
                   </button>
                   <button
                        onClick={() => setIsMostDecisiveVictoryModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{animationDelay: '400ms'}}
                        aria-label="View most decisive victories by sport"
                    >
                        <KpiCard
                            icon={<TrendingUpIcon />}
                            title="Most Decisive Victory"
                            description="Click to see breakdown"
                        >
                            <div className="flex items-end justify-around gap-2 mt-2 w-full text-center">
                                {(Object.values(Sport) as Sport[]).map(sport => (
                                    <div key={sport} className="flex flex-col items-center flex-1">
                                        <SportIcon sport={sport} className={`h-5 w-5 mb-1 ${sportColorTextClasses[sport]}`} />
                                        <span className="text-xl font-bold font-mono">
                                            {`+${stats.mostDecisiveVictoriesBySport[sport]?.diff ?? 0}`}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </KpiCard>
                   </button>
                </div>

                <div className="grid grid-cols-1 xl:grid-cols-5 gap-8">
                    <div className="xl:col-span-3 bg-light-card dark:bg-dark-card p-6 rounded-xl shadow-sm animate-slide-in-bottom" style={{animationDelay: '500ms'}}>
                         <h2 className="text-xl font-bold mb-4">Team Leaderboard</h2>
                         <div className="overflow-x-auto">
                            <table className="w-full text-left">
                                <thead>
                                    <tr className="border-b border-light-border dark:border-dark-border text-sm text-light-text-muted dark:text-dark-text-muted">
                                        <th className="p-2">#</th>
                                        <th className="p-2">Team</th>
                                        <th className="p-2 text-center">W</th>
                                        <th className="p-2 text-center">L</th>
                                        <th className="p-2 text-center">GP</th>
                                        <th className="p-2 text-right">Win %</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {stats.leaderboard.map((team: TeamStat & { winRate: number }, index) => {
                                        const animationDelay = `${500 + index * 50}ms`;
                                        return (
                                        <tr 
                                            key={team.teamConfig.name} 
                                            onClick={() => setSelectedTeam(team)}
                                            className="border-b border-light-border dark:border-dark-border last:border-b-0 hover:bg-light-card-secondary dark:hover:bg-dark-card-secondary cursor-pointer leaderboard-row-hover animate-slide-in-bottom"
                                            style={{
                                                '--team-glow-color': `${team.teamConfig.color}50`,
                                                animationDelay
                                            } as React.CSSProperties}
                                        >
                                            <td className="p-2 font-semibold text-light-text dark:text-dark-text">{index + 1}</td>
                                            <td className="p-2 font-bold" style={{ color: team.teamConfig.color }}>{team.teamConfig.name}</td>
                                            <td className="p-2 text-center font-mono text-green-500">{team.wins}</td>
                                            <td className="p-2 text-center font-mono text-brand-red">{team.losses}</td>
                                            <td className="p-2 text-center font-mono text-light-text dark:text-dark-text">{team.totalGames}</td>
                                            <td className="p-2 text-right font-mono font-semibold text-light-text dark:text-dark-text">{team.winRate.toFixed(1)}%</td>
                                        </tr>
                                    );
                                    })}
                                </tbody>
                            </table>
                         </div>
                    </div>
                    <div className="xl:col-span-2 space-y-8 animate-slide-in-bottom" style={{animationDelay: '600ms'}}>
                        {selectedSport === 'All' && <DonutChart data={donutChartData} title="Sport Popularity" />}
                        <BarChart data={barChartData} title={`Top 5 Teams (by Wins)${selectedSport !== 'All' ? ` in ${selectedSport}` : ''}`} />
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="p-4 sm:p-6 md:p-8">
            <h1 className="text-4xl md:text-5xl font-bold font-display mb-8">Analytics</h1>

            <div className="mb-6 flex flex-wrap items-center gap-2 p-1.5 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg">
                {(['All', ...Object.values(Sport)] as const).map(sport => (
                    <button
                        key={sport}
                        onClick={() => setSelectedSport(sport)}
                        className={`flex-1 px-4 py-2 text-sm font-semibold rounded-md transition-colors ${
                            selectedSport === sport
                                ? 'bg-light-card dark:bg-dark-card shadow-sm text-brand-blue'
                                : 'text-light-text-muted dark:text-dark-text-muted hover:text-light-text dark:hover:text-dark-text'
                        }`}
                    >
                        {sport}
                    </button>
                ))}
            </div>
            
            {renderContent()}
            
            {selectedTeam && (
                <TeamDetailModal
                    team={selectedTeam}
                    matches={finishedMatches}
                    onClose={() => setSelectedTeam(null)}
                />
            )}

            {isTotalMatchesModalOpen && stats && (
                <TotalMatchesModal
                    matches={allFinishedMatches}
                    onClose={() => setIsTotalMatchesModalOpen(false)}
                />
            )}

            {isMostPlayedSportModalOpen && stats && (
                <MostPlayedSportModal
                    matchesBySport={stats.matchesBySport}
                    onClose={() => setIsMostPlayedSportModalOpen(false)}
                />
            )}

            {isHighestScoringGamesModalOpen && stats && (
                <HighestScoringGamesModal
                    highestGamesBySportTime={stats.highestGamesBySportTime}
                    highestGamesBySportScore={stats.highestGamesBySportScore}
                    onClose={() => setIsHighestScoringGamesModalOpen(false)}
                />
            )}

            {isMostDecisiveVictoryModalOpen && stats && (
                <MostDecisiveVictoryModal
                    mostDecisiveVictoriesBySportTime={stats.mostDecisiveVictoriesBySportTime}
                    mostDecisiveVictoriesBySportScore={stats.mostDecisiveVictoriesBySportScore}
                    onClose={() => setIsMostDecisiveVictoryModalOpen(false)}
                />
            )}
        </div>
    );
};

export default AnalyticsPage;
--- END FILE: components\AnalyticsPage.tsx ---

--- START FILE: components\AudienceView.tsx ---
import React, { useState, useEffect, useRef, useCallback } from 'react';
import type { MatchConfig, GameState, Theme, Match, Font } from '../types';
import { Sport, Layout, GameStatus } from '../types';
import ExitIcon from './icons/ExitIcon';

interface AudienceViewProps {
    config: MatchConfig;
    matchId: string;
    onExit: () => void;
    theme: Theme;
    isPreview?: boolean;
    font?: Font;
    layout?: Layout;
}

const formatTime = (totalSeconds: number) => {
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
};

type LiveData = { gameState: GameState, time: number };

interface AnimatedTeamScoreProps {
    name: string;
    score: number;
    color: string;
    font: Font;
    styles: {
        name: React.CSSProperties;
        score: React.CSSProperties;
        pointsContainer?: React.CSSProperties;
        pointsLabel?: React.CSSProperties;
        pointsScore?: React.CSSProperties;
    };
    isVolleyball?: boolean;
    pointScore?: number;
}

const AnimatedTeamScore: React.FC<AnimatedTeamScoreProps> = ({ name, score, color, font, styles, isVolleyball, pointScore }) => {
    const scoreToAnimate = isVolleyball ? pointScore : score;
    const prevScoreRef = useRef(scoreToAnimate);
    const [isAnimating, setIsAnimating] = useState(false);

    useEffect(() => {
        if (scoreToAnimate !== prevScoreRef.current) {
            setIsAnimating(true);
            const timer = setTimeout(() => setIsAnimating(false), 400); // Match animation duration
            prevScoreRef.current = scoreToAnimate;
            return () => clearTimeout(timer);
        }
    }, [scoreToAnimate]);
    
    const fontClass = `font-${font}`;

    return (
        <div className={`flex flex-col items-center text-center p-4 rounded-lg h-full ${isVolleyball ? 'justify-between' : 'justify-center'}`} style={{ backgroundColor: color }}>
            <h2 
              className={`font-bold uppercase text-white ${fontClass} text-shadow-heavy tracking-wider truncate w-full`}
              style={styles.name}
            >
              {name}
            </h2>
            <p 
              className={`font-bold text-white ${fontClass} text-shadow-heavy leading-none ${!isVolleyball && isAnimating ? 'animate-score-update' : ''}`}
              style={styles.score}
            >
              {score}
            </p>
            {isVolleyball && (
                <div className="bg-black/30 backdrop-blur-sm rounded-md" style={styles.pointsContainer}>
                    <h3 className={`font-sans font-semibold uppercase text-white/80 tracking-wider`} style={styles.pointsLabel}>Points</h3>
                    <p 
                        className={`font-bold text-white ${fontClass} text-shadow-heavy leading-none ${isAnimating ? 'animate-score-update' : ''}`}
                        style={styles.pointsScore}
                    >
                        {pointScore}
                    </p>
                </div>
            )}
        </div>
    );
};

const AudienceView: React.FC<AudienceViewProps> = ({ config, matchId, onExit, theme, isPreview = false, font = 'display', layout = Layout.Wide }) => {
    const [controlsVisible, setControlsVisible] = useState(!isPreview);
    const controlsTimeoutRef = useRef<number | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

    useEffect(() => {
        const element = containerRef.current;
        if (!element) return;

        const resizeObserver = new ResizeObserver(entries => {
            if (entries[0]) {
                const { width, height } = entries[0].contentRect;
                setDimensions({ width, height });
            }
        });

        resizeObserver.observe(element);
        return () => resizeObserver.unobserve(element);
    }, []);

    const getInitialState = (): LiveData => {
        const rawData = localStorage.getItem(`match-state-${matchId}`);
        if (rawData && !isPreview) {
            try {
                const historyData = JSON.parse(rawData);
                if (historyData.states && historyData.states.length > 0 && typeof historyData.index === 'number') {
                    return historyData.states[historyData.index];
                }
            } catch (e) {
                console.error("Failed to parse initial match data from localStorage", e);
            }
        }
        
        const finishedMatchRaw = localStorage.getItem('matches');
        if (finishedMatchRaw) {
            try {
                const allMatches = JSON.parse(finishedMatchRaw) as Match[];
                const thisMatch = allMatches.find(m => m.id === matchId);
                if (thisMatch && thisMatch.status === 'Finished') {
                    return {
                        gameState: {
                            teamA: { ...thisMatch.teamA, score: thisMatch.finalScoreA ?? 0 },
                            teamB: { ...thisMatch.teamB, score: thisMatch.finalScoreB ?? 0 },
                            currentPeriod: thisMatch.periods,
                            pauseReason: null,
                            status: GameStatus.Finished,
                            periodScores: thisMatch.periodScores ?? [],
                            setScores: thisMatch.sport === Sport.Volleyball ? (thisMatch.periodScores || []).reduce((acc, score) => {
                                if (score && score.a > score.b) acc.a++;
                                if (score && score.b > score.a) acc.b++;
                                return acc;
                            }, { a: 0, b: 0 }) : undefined,
                        },
                        time: 0,
                    }
                }
            } catch (e) {
                console.error("Failed to parse finished match data", e);
            }
        }
        
        return {
            gameState: {
                teamA: { ...config.teamA, score: 0 },
                teamB: { ...config.teamB, score: 0 },
                currentPeriod: 1,
                pauseReason: null,
                status: GameStatus.NotStarted,
                periodScores: [],
                ...(config.sport === Sport.Volleyball && { setScores: { a: 0, b: 0 } }),
            },
            time: config.sport === Sport.Volleyball ? 0 : config.durationMinutes * 60 + config.durationSeconds,
        };
    };

    const [liveData, setLiveData] = useState<LiveData>(getInitialState);
    const isVolleyball = config.sport === Sport.Volleyball;

    const getResponsiveStyles = useCallback((isVolleyball: boolean) => {
        const containerWidth = dimensions.width;
        if (!containerWidth) {
            const hidden = { fontSize: '0px' };
            return { name: hidden, score: hidden, time: hidden, period: hidden, setScore: hidden, pauseReason: hidden, sportName: hidden, pointsContainer: {}, pointsLabel: hidden, pointsScore: hidden };
        }

        const width = containerWidth;
        
        const nameRatio = isVolleyball ? 0.06 : 0.07;
        const scoreRatio = isVolleyball ? 0.18 : 0.25;
        const timeRatio = 0.15;
        const periodRatio = 0.06;
        const setScoreRatio = 0.05;
        const pauseReasonRatio = 0.2;
        const sportNameRatio = 0.04;
        const pointsContainerPaddingXRatio = 0.02;
        const pointsContainerPaddingYRatio = 0.01;
        const pointsLabelRatio = 0.02;
        const pointsScoreRatio = 0.08;

        const clamp = (val: number, min: number, max: number) => Math.max(min, Math.min(val, max));

        return {
            name: { fontSize: `${clamp(width * nameRatio, 8, 80)}px` },
            score: { fontSize: `${clamp(width * scoreRatio, 12, 250)}px` },
            time: { fontSize: `${clamp(width * timeRatio, 10, 100)}px` },
            period: { fontSize: `${clamp(width * periodRatio, 6, 50)}px` },
            setScore: { fontSize: `${clamp(width * setScoreRatio, 5, 30)}px` },
            pauseReason: { fontSize: `${clamp(width * pauseReasonRatio, 24, 150)}px` },
            sportName: { fontSize: `${clamp(width * sportNameRatio, 5, 35)}px` },
            pointsContainer: { padding: `${clamp(width * pointsContainerPaddingYRatio, 2, 8)}px ${clamp(width * pointsContainerPaddingXRatio, 4, 16)}px` },
            pointsLabel: { fontSize: `${clamp(width * pointsLabelRatio, 6, 20)}px` },
            pointsScore: { fontSize: `${clamp(width * pointsScoreRatio, 10, 80)}px` },
        };
    }, [dimensions.width]);
    
    const responsiveStyles = getResponsiveStyles(isVolleyball);

    useEffect(() => {
        const channel = new BroadcastChannel('scoreboard-pro-updates');
        const handleUpdateFromStorage = () => {
            const rawData = localStorage.getItem(`match-state-${matchId}`);
            if (rawData) {
                try {
                    const historyData = JSON.parse(rawData);
                     if (historyData.states && historyData.states.length > 0 && typeof historyData.index === 'number') {
                        setLiveData(historyData.states[historyData.index]);
                    }
                } catch (e) {
                    console.error("Failed to parse match update from localStorage", e);
                }
            }
        };
        
        const messageHandler = (event: MessageEvent) => {
            if (event.data?.matchId === matchId && event.data?.data) {
                setLiveData(event.data.data);
            }
        };

        channel.addEventListener('message', messageHandler);
        window.addEventListener('focus', handleUpdateFromStorage);

        return () => {
            channel.removeEventListener('message', messageHandler);
            window.removeEventListener('focus', handleUpdateFromStorage);
            channel.close();
        };
    }, [matchId]);

    useEffect(() => {
        if (isPreview) {
            setControlsVisible(false);
            if(controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);
            return;
        }

        const hideControls = () => {
            if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);
            controlsTimeoutRef.current = window.setTimeout(() => setControlsVisible(false), 3000);
        };
        hideControls();
        const handleMouseMove = () => {
            setControlsVisible(true);
            hideControls();
        };
        window.addEventListener('mousemove', handleMouseMove);
        return () => {
            if (controlsTimeoutRef.current) clearTimeout(controlsTimeoutRef.current);
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, [isPreview]);
    
    const isDarkTheme = ['dark', 'viola', 'coder'].includes(theme);
    const themeClasses = isDarkTheme ? 'dark bg-dark-background text-dark-text' : 'bg-light-background text-light-text';
    const clockBgClass = isDarkTheme ? 'bg-black' : 'bg-light-text';
    
    const periodLabel = config.sport === Sport.Volleyball ? 'SET' : 'PERIOD';
    const { gameState, time: liveTime } = liveData;
    const isFinished = gameState.status === GameStatus.Finished;

    const scoreA = gameState.teamA.score;
    const scoreB = gameState.teamB.score;

    const effectiveLayout = isFinished
        ? Layout.Wide // ALWAYS use Wide layout for finished matches
        : dimensions.width < 450
        ? Layout.Compact
        : layout;

    const layoutClasses = {
        [Layout.Wide]: 'grid-cols-1 grid-rows-[1fr_auto_1fr] md:grid-rows-1 md:grid-cols-[1fr_auto_1fr]',
        [Layout.Compact]: 'grid-cols-1 grid-rows-3',
    };
    
    const containerClasses = `w-full h-full flex items-center justify-center relative overflow-hidden rounded-lg ${themeClasses}`;
    
    const timeToDisplay = isFinished ? 0 : liveTime;

    return (
        <div ref={containerRef} className={containerClasses}>
            
            {!isPreview && (
                <div className={`absolute top-4 right-4 flex gap-3 transition-opacity duration-300 ${controlsVisible ? 'opacity-100' : 'opacity-0'}`}>
                    <button onClick={onExit} className="p-3 rounded-full bg-dark-card/50 hover:bg-dark-card/80 text-white" title="Exit Audience View">
                        <ExitIcon />
                    </button>
                </div>
            )}

            <div className={`w-full h-full p-2 sm:p-4 grid gap-2 sm:gap-4 ${layoutClasses[effectiveLayout]}`}>
                 {isFinished && <div className="final-badge">FINAL</div>}
                {gameState.pauseReason && (
                    <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-10">
                        <h1 
                            className={`font-display text-yellow-400 uppercase tracking-widest animate-pulse font-${font}`}
                            style={responsiveStyles.pauseReason}
                        >
                            {gameState.pauseReason}
                        </h1>
                    </div>
                )}

                <AnimatedTeamScore 
                    name={gameState.teamA.name} 
                    score={isVolleyball && !isFinished ? (gameState.setScores?.a ?? 0) : scoreA}
                    color={config.teamA.color} 
                    font={font} 
                    styles={{ name: responsiveStyles.name, score: responsiveStyles.score, pointsContainer: responsiveStyles.pointsContainer, pointsLabel: responsiveStyles.pointsLabel, pointsScore: responsiveStyles.pointsScore }}
                    isVolleyball={isVolleyball && !isFinished}
                    pointScore={isVolleyball && !isFinished ? gameState.teamA.score : undefined}
                />

                <div className={`flex flex-col items-center justify-center ${clockBgClass} p-4 rounded-lg text-white`}>
                    {isFinished ? (
                        <>
                            <div className={`font-bold leading-none font-${font}`} style={responsiveStyles.time}>VS</div>
                            <div className={`font-semibold uppercase tracking-widest mt-2 font-${font}`} style={responsiveStyles.period}>FINAL</div>
                        </>
                    ) : (
                        <>
                             <div 
                                className={`font-bold leading-none font-${font}`}
                                style={responsiveStyles.time}
                            >
                                {formatTime(timeToDisplay)}
                            </div>
                            <div 
                                className={`font-semibold uppercase tracking-widest mt-2 font-${font}`}
                                style={responsiveStyles.period}
                            >
                                {periodLabel} {gameState.currentPeriod}
                            </div>
                        </>
                    )}
                     <div
                         className={`font-semibold uppercase tracking-wider mt-1 opacity-70 font-${font}`}
                         style={responsiveStyles.sportName}
                     >
                         {config.sport}
                     </div>
                </div>

                <AnimatedTeamScore 
                    name={gameState.teamB.name}
                    score={isVolleyball && !isFinished ? (gameState.setScores?.b ?? 0) : scoreB}
                    color={config.teamB.color} 
                    font={font} 
                    styles={{ name: responsiveStyles.name, score: responsiveStyles.score, pointsContainer: responsiveStyles.pointsContainer, pointsLabel: responsiveStyles.pointsLabel, pointsScore: responsiveStyles.pointsScore }}
                    isVolleyball={isVolleyball && !isFinished}
                    pointScore={isVolleyball && !isFinished ? gameState.teamB.score : undefined}
                />
            </div>
        </div>
    );
};

export default AudienceView;
--- END FILE: components\AudienceView.tsx ---

--- START FILE: components\BoxScore.tsx ---
import React from 'react';
import type { GameState, MatchConfig } from '../types';
import { Sport, GameStatus } from '../types';

interface BoxScoreProps {
    gameState: GameState;
    matchConfig: MatchConfig;
}

const BoxScore: React.FC<BoxScoreProps> = ({ gameState, matchConfig }) => {
    const isFinished = gameState.status === GameStatus.Finished;
    const isScoreBased = matchConfig.gameMode === 'score';

    // Special case for finished, score-based games to show a single "FINAL" column.
    if (isScoreBased && isFinished) {
        const finalScores = (gameState.periodScores || [])[0];
        // Don't render if the score data isn't available for some reason.
        if (!finalScores) return null;

        const renderScoreBasedRow = (team: 'A' | 'B') => {
            const teamData = gameState[team === 'A' ? 'teamA' : 'teamB'];
            const teamKey = team === 'A' ? 'a' : 'b';
            return (
                <tr>
                    <td className="p-3 font-bold text-left sticky left-0 bg-light-card dark:bg-dark-card" style={{ color: teamData.color }}>
                        {teamData.name}
                    </td>
                    <td className="p-3 text-center font-mono font-semibold">{finalScores[teamKey]}</td>
                    <td className="p-3 text-center font-mono font-bold text-lg">{teamData.score}</td>
                </tr>
            );
        };

        return (
            <div className="w-full max-w-7xl mx-auto mb-4 p-4 rounded-lg shadow-md bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text">
                <div className="overflow-x-auto">
                    <table className="w-full border-collapse">
                        <thead>
                            <tr className="bg-light-card-secondary dark:bg-dark-card-secondary text-light-text dark:text-dark-text">
                                <th className="p-3 text-sm font-bold uppercase text-left sticky left-0 bg-light-card-secondary dark:bg-dark-card-secondary">Team</th>
                                <th className="p-3 text-sm font-bold uppercase">FINAL</th>
                                <th className="p-3 text-sm font-bold uppercase">Total</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-light-border dark:divide-dark-border text-light-text dark:text-dark-text">
                            {renderScoreBasedRow('A')}
                            {renderScoreBasedRow('B')}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    }

    // Original logic for time-based games (live or finished)
    const periodLabel = matchConfig.sport === Sport.Volleyball ? 'S' : matchConfig.sport === Sport.Soccer ? 'H' : 'Q';
    const periods = Array.from({ length: matchConfig.periods }, (_, i) => i + 1);

    const getScoreForPeriod = (team: 'A' | 'B', period: number) => {
        const teamKey = team === 'A' ? 'a' : 'b';
        const periodScores = gameState.periodScores || [];

        // For finished games OR past periods, the periodScores array is the source of truth.
        if (periodScores[period - 1] !== undefined) {
            return periodScores[period - 1][teamKey];
        }
        
        // For the current, live period, calculate the score.
        if (period === gameState.currentPeriod && gameState.status !== GameStatus.Finished) {
            const sumOfPreviousScores = periodScores.reduce((sum, score) => sum + (score?.[teamKey] || 0), 0);
            return gameState[team === 'A' ? 'teamA' : 'teamB'].score - sumOfPreviousScores;
        }
        
        // It's a future period.
        return '-';
    };
    
    const lastFinalizedPeriod = (gameState.periodScores || []).length;

    const renderRow = (team: 'A' | 'B') => {
        const teamData = gameState[team === 'A' ? 'teamA' : 'teamB'];
        return (
            <tr>
                <td className="p-3 font-bold text-left sticky left-0 bg-light-card dark:bg-dark-card" style={{ color: teamData.color }}>
                    {teamData.name}
                </td>
                {periods.map(p => (
                    <td 
                      key={p} 
                      className={`p-3 text-center font-mono font-semibold ${p === lastFinalizedPeriod ? 'animate-[slide-in-left_0.5s_ease-out]' : ''}`}
                    >
                        {getScoreForPeriod(team, p)}
                    </td>
                ))}
                <td className="p-3 text-center font-mono font-bold text-lg">{teamData.score}</td>
            </tr>
        );
    };

    return (
        <div className="w-full max-w-7xl mx-auto mb-4 p-4 rounded-lg shadow-md bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text">
            <div className="overflow-x-auto">
                <table className="w-full border-collapse">
                    <thead>
                        <tr className="bg-light-card-secondary dark:bg-dark-card-secondary text-light-text dark:text-dark-text">
                            <th className="p-3 text-sm font-bold uppercase text-left sticky left-0 bg-light-card-secondary dark:bg-dark-card-secondary">Team</th>
                            {periods.map(p => (
                                <th key={p} className="p-3 text-sm font-bold uppercase">{`${periodLabel}${p}`}</th>
                            ))}
                            <th className="p-3 text-sm font-bold uppercase">Total</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-light-border dark:divide-dark-border text-light-text dark:text-dark-text">
                        {renderRow('A')}
                        {renderRow('B')}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default BoxScore;
--- END FILE: components\BoxScore.tsx ---

--- START FILE: components\charts\BarChart.tsx ---
import React from 'react';

interface BarChartProps {
    data: Array<{
        label: string;
        color: string;
        totalGames: number;
        values: Array<{ value: number; color: string; label: string; }>;
    }>;
    title: string;
}

const BarChart: React.FC<BarChartProps> = ({ data, title }) => {

    const legendItems = data.length > 0
        ? data[0].values.map(v => ({ label: v.label, color: v.color }))
        : [];

    return (
        <div className="bg-light-card dark:bg-dark-card p-6 rounded-xl shadow-sm">
            <h2 className="text-xl font-bold mb-4">{title}</h2>
            <div className="space-y-4">
                {data.map((d, index) => {
                    return (
                        <div 
                            key={d.label}
                            className="animate-slide-in-bottom bar-row-hover"
                            style={{ animationDelay: `${index * 100}ms` }}
                        >
                            <div className="flex justify-between items-center mb-1 text-sm">
                                <span className="font-bold" style={{ color: d.color }}>{d.label}</span>
                                <span className="font-mono font-semibold">{d.totalGames} GP</span>
                            </div>
                            <div className="w-full bg-light-card-secondary dark:bg-dark-card-secondary rounded-full h-6 flex overflow-hidden">
                                {d.values.map(v => {
                                    const barWidth = d.totalGames > 0 ? (v.value / d.totalGames) * 100 : 0;
                                    return (
                                        <div
                                            key={v.label}
                                            className="h-full animate-chart-bar"
                                            style={{
                                                width: `${barWidth}%`,
                                                backgroundColor: v.color,
                                            }}
                                        />
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
            <div className="flex justify-end items-center gap-4 mt-4 text-xs">
                {legendItems.map(item => (
                    <div key={item.label} className="flex items-center gap-1.5">
                        <span className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: item.color }}></span>
                        <span>{item.label}</span>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default BarChart;
--- END FILE: components\charts\BarChart.tsx ---

--- START FILE: components\charts\DonutChart.tsx ---
import React, { useState, useEffect } from 'react';

interface DonutChartProps {
    data: Array<{ label: string; value: number; color: string }>;
    title: string;
}

const DonutChart: React.FC<DonutChartProps> = ({ data, title }) => {
    const [isMounted, setIsMounted] = useState(false);
    const [hoveredLabel, setHoveredLabel] = useState<string | null>(null);

    useEffect(() => {
        const timer = setTimeout(() => setIsMounted(true), 100);
        return () => clearTimeout(timer);
    }, []);

    const size = 180;
    const strokeWidth = 22;
    const radius = (size - strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    const total = data.reduce((sum, item) => sum + item.value, 0);

    const sortedData = [...data].sort((a, b) => b.value - a.value);

    let cumulativePct = 0;

    return (
        <div className="bg-light-card dark:bg-dark-card p-6 rounded-xl shadow-sm">
            <h2 className="text-xl font-bold mb-4">{title}</h2>
            <div className="flex flex-col md:flex-row items-center gap-6">
                <div className="relative flex-shrink-0" style={{ width: size, height: size }}>
                    <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`} className="-rotate-90">
                         <defs>
                            {data.map(item => (
                                <filter key={`glow-${item.label}`} id={`glow-${item.label}`}>
                                    <feDropShadow dx="0" dy="1" stdDeviation="2" floodColor={item.color} floodOpacity="0.7" />
                                </filter>
                            ))}
                        </defs>
                        <circle
                            cx={size / 2}
                            cy={size / 2}
                            r={radius}
                            fill="none"
                            strokeWidth={strokeWidth}
                            className="stroke-light-card-secondary dark:stroke-dark-card-secondary"
                        />
                        {sortedData.map((item, index) => {
                            const pct = total > 0 ? item.value / total : 0;
                            const dashOffset = circumference * (1 - pct);
                            const rotation = cumulativePct * 360;
                            cumulativePct += pct;
                            
                            const isHovered = hoveredLabel === item.label;
                            const isDimmed = hoveredLabel !== null && !isHovered;

                            return (
                                <g 
                                    key={item.label}
                                    transform={`rotate(${rotation} ${size / 2} ${size / 2})`}
                                    onMouseEnter={() => setHoveredLabel(item.label)}
                                    onMouseLeave={() => setHoveredLabel(null)}
                                >
                                    <circle
                                        cx={size / 2}
                                        cy={size / 2}
                                        r={radius}
                                        fill="none"
                                        stroke={item.color}
                                        strokeWidth={strokeWidth}
                                        strokeDasharray={circumference}
                                        strokeDashoffset={isMounted ? dashOffset : circumference}
                                        filter={isHovered ? `url(#glow-${item.label})` : undefined}
                                        style={{
                                            transition: 'stroke-dashoffset 1s cubic-bezier(0.5, 0, 0.5, 1), transform 0.3s, opacity 0.3s, filter 0.3s',
                                            transitionDelay: `${index * 150}ms`,
                                            strokeLinecap: 'round',
                                            transformOrigin: '50% 50%',
                                            transform: `scale(${isHovered ? 1.05 : 1})`,
                                            opacity: isDimmed ? 0.3 : 1
                                        }}
                                    />
                                </g>
                            );
                        })}
                    </svg>
                    <div className="absolute inset-0 flex flex-col items-center justify-center">
                        <span className="text-3xl font-bold font-display">{total}</span>
                        <span className="text-sm text-light-text-muted dark:text-dark-text-muted">Matches</span>
                    </div>
                </div>
                <ul className="space-y-2 text-sm w-full">
                    {data.map(item => {
                        const isHovered = hoveredLabel === item.label;
                        const isDimmed = hoveredLabel !== null && !isHovered;
                        return (
                            <li 
                                key={item.label} 
                                className={`flex items-center gap-2 cursor-pointer transition-all duration-200 ${isHovered ? 'scale-110 font-bold -translate-y-px' : ''} ${isDimmed ? 'opacity-50' : ''}`}
                                onMouseEnter={() => setHoveredLabel(item.label)}
                                onMouseLeave={() => setHoveredLabel(null)}
                            >
                                <span className="w-3 h-3 rounded-full flex-shrink-0" style={{ backgroundColor: item.color }} />
                                <span className="font-semibold truncate">{item.label}:</span>
                                <span className="text-light-text-muted dark:text-dark-text-muted whitespace-nowrap">{item.value} ({total > 0 ? ((item.value / total) * 100).toFixed(0) : 0}%)</span>
                            </li>
                        );
                    })}
                </ul>
            </div>
        </div>
    );
};

export default DonutChart;
--- END FILE: components\charts\DonutChart.tsx ---

--- START FILE: components\ControlPanel.tsx ---
import React, { useState, useEffect } from 'react';
import type { GameState, MatchConfig, PauseReason } from '../types';
import { Sport, GameStatus } from '../types';
import PlayIcon from './icons/PlayIcon';
import PauseIcon from './icons/PauseIcon';
import ResetIcon from './icons/ResetIcon';
import FullScreenIcon from './icons/FullScreenIcon';
import MinusIcon from './icons/MinusIcon';
import CheckIcon from './icons/CheckIcon';
import DashboardIcon from './icons/DashboardIcon';
import SettingsIcon from './icons/SettingsIcon';
import PictureInPictureIcon from './icons/PictureInPictureIcon';
import LayoutCenterIcon from './icons/LayoutCenterIcon';
import LayoutSplitIcon from './icons/LayoutSplitIcon';
import UndoIcon from './icons/UndoIcon';
import RedoIcon from './icons/RedoIcon';
import MatchActions from './MatchActions';

interface ControlPanelProps {
    actions: {
        start: () => void;
        pause: () => void;
        reset: () => void;
        updateScore: (team: 'A' | 'B', delta: number) => void;
        setPauseReason: (reason: PauseReason) => void;
        startNextPeriod: () => void;
        goToNextPeriod: () => void;
        goToPreviousPeriod: () => void;
        finishMatchManually: () => void;
        undo: () => void;
        redo: () => void;
    },
    onToggleFullScreen: () => void;
    onToggleMiniAudience: () => void;
    onLeaveMatch: () => void;
    onUpdateMatchConfig: (newConfig: Partial<MatchConfig>) => void;
    clock: {
        isRunning: boolean;
    };
    gameState: GameState;
    matchConfig: MatchConfig;
    currentLayout: 'center' | 'side-by-side';
    onToggleLayout: () => void;
    canUndo: boolean;
    canRedo: boolean;
    onShowResetConfirm: () => void;
    showGlobalActions?: boolean;
}

const ControlButton: React.FC<{ onClick?: () => void; children: React.ReactNode; className?: string, title?: string, disabled?: boolean }> = ({ onClick, children, className = '', title, disabled = false }) => (
    <button
        onClick={onClick}
        title={title}
        disabled={disabled}
        className={`flex items-center justify-center p-3 rounded-lg font-semibold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-dark-card disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
    >
        {children}
    </button>
);

const ControlPanel: React.FC<ControlPanelProps> = ({
    actions,
    onToggleFullScreen,
    onToggleMiniAudience,
    onLeaveMatch,
    onUpdateMatchConfig,
    clock,
    gameState,
    matchConfig,
    currentLayout,
    onToggleLayout,
    canUndo,
    canRedo,
    onShowResetConfirm,
    showGlobalActions = true,
}) => {
    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
    
    const isFinished = gameState.status === GameStatus.Finished;
    const isRunning = clock.isRunning;

    const scoreIncrements: Record<Sport, number[]> = {
        [Sport.Basketball]: [1, 2, 3],
        [Sport.Soccer]: [1],
        [Sport.Volleyball]: [1],
    };

    const pauseReasons: PauseReason[] = matchConfig.sport === Sport.Volleyball
        ? ['Timeout', 'Violation', 'Challenge']
        : ['Timeout', 'Foul', 'Violation', 'Challenge'];
    
    const pauseReasonGridClass = pauseReasons.length === 4 ? 'grid-cols-2 sm:grid-cols-4' : 'grid-cols-3';
        
    const periodLabel = matchConfig.sport === Sport.Volleyball ? 'Set' : 'Period';
    
    const mainGridContainerClasses = currentLayout === 'center'
        ? "grid grid-cols-1 lg:grid-cols-3 gap-6"
        : "grid grid-cols-1 gap-6";

    const mainControlsOrderClass = currentLayout === 'center'
        ? "order-first lg:order-none"
        : "";

    const renderMainActionButton = () => {
        switch (gameState.status) {
            case GameStatus.NotStarted:
            case GameStatus.Paused:
                return (
                    <ControlButton onClick={actions.start} className="bg-green-600 hover:bg-green-500 text-white w-20 h-20 rounded-full" title="Start Clock">
                        <PlayIcon />
                    </ControlButton>
                );
            case GameStatus.InProgress:
                 return (
                    <ControlButton onClick={actions.pause} className="bg-yellow-500 hover:bg-yellow-400 text-black w-20 h-20 rounded-full" title="Pause Clock">
                        <PauseIcon />
                    </ControlButton>
                );
            case GameStatus.PeriodBreak:
                 return (
                    <ControlButton onClick={actions.startNextPeriod} className="bg-blue-500 hover:bg-blue-400 text-white px-6 h-20 rounded-lg text-lg" title="Start Next Period">
                        Start Next {periodLabel}
                    </ControlButton>
                );
            case GameStatus.TieBreak:
                return (
                    <ControlButton disabled className="bg-gray-600 text-white w-20 h-20 rounded-full flex flex-col items-center" title="Tie-Break in Progress">
                        <PauseIcon />
                        <span className="text-xs mt-1 font-bold">TIE-BREAK</span>
                    </ControlButton>
                );
            case GameStatus.Finished:
                 return (
                     <ControlButton disabled className="bg-gray-600 text-white w-20 h-20 rounded-full" title="Match Finished">
                        <PlayIcon />
                    </ControlButton>
                 )
        }
    }

    const SettingsModal = () => {
        const [localConfig, setLocalConfig] = useState(matchConfig);

        useEffect(() => {
            setLocalConfig(matchConfig);
        }, [isSettingsOpen]);

        const handleSave = () => {
            // FIX: Ensure targetScore has a value when saving in score mode.
            const configToSave = {...localConfig};
            if (configToSave.gameMode === 'score' && !configToSave.targetScore) {
                configToSave.targetScore = 21; // Default if somehow not set
            }
            onUpdateMatchConfig(configToSave);
            setIsSettingsOpen(false);
        };
        
        const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";
        const segmentedButtonClasses = (isActive: boolean) => 
          `w-full px-4 py-2 text-sm font-semibold rounded-md focus:outline-none ${
            isActive ? 'bg-brand-blue text-white' : 'bg-light-card hover:bg-light-border dark:bg-dark-card dark:hover:bg-dark-border'
          }`;

        return (
             <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
                <div className="rounded-xl p-8 w-full max-w-md mx-4 bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text shadow-2xl">
                    <h3 className="text-2xl font-bold font-display mb-6">Game Settings</h3>
                     
                    <div className="space-y-6">
                        <div>
                           <label className="block text-sm font-medium mb-2">Game Mode</label>
                           <div className="p-1 rounded-lg flex space-x-1 bg-light-card-secondary dark:bg-dark-card-secondary">
                                <button type="button" onClick={() => setLocalConfig(c => ({...c, gameMode: 'time'}))} className={segmentedButtonClasses(localConfig.gameMode === 'time')}>Time Based</button>
                                <button type="button" onClick={() => setLocalConfig(c => ({...c, gameMode: 'score', targetScore: c.targetScore || 21}))} className={segmentedButtonClasses(localConfig.gameMode === 'score')}>Score Based</button>
                            </div>
                        </div>

                        {localConfig.gameMode === 'time' ? (
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div className={matchConfig.sport === Sport.Volleyball ? 'sm:col-span-3' : ''}>
                                    <label htmlFor="periods" className="block text-sm font-medium mb-1">{matchConfig.sport === Sport.Volleyball ? 'Best of Sets' : 'Periods'}</label>
                                    <input id="periods" type="number" min="1" value={localConfig.periods} onChange={e => setLocalConfig(c=>({...c, periods: parseInt(e.target.value)}))} className={inputClasses} />
                                </div>
                                {matchConfig.sport !== Sport.Volleyball && (
                                    <>
                                        <div>
                                            <label htmlFor="durationMinutes" className="block text-sm font-medium mb-1">Minutes</label>
                                            <input id="durationMinutes" type="number" min="0" value={localConfig.durationMinutes} onChange={e => setLocalConfig(c=>({...c, durationMinutes: parseInt(e.target.value)}))} className={inputClasses} />
                                        </div>
                                         <div>
                                            <label htmlFor="durationSeconds" className="block text-sm font-medium mb-1">Seconds</label>
                                            <input id="durationSeconds" type="number" min="0" max="59" value={localConfig.durationSeconds} onChange={e => setLocalConfig(c=>({...c, durationSeconds: parseInt(e.target.value)}))} className={inputClasses} />
                                        </div>
                                    </>
                                )}
                            </div>
                        ) : (
                             <div>
                                <label htmlFor="targetScore" className="block text-sm font-medium mb-1">Target Score</label>
                                <input id="targetScore" type="number" min="1" value={localConfig.targetScore || 21} onChange={e => setLocalConfig(c=>({...c, targetScore: parseInt(e.target.value)}))} className={inputClasses} />
                            </div>
                        )}
                    </div>

                    <div className="flex justify-end gap-4 mt-8">
                        <button
                            onClick={() => setIsSettingsOpen(false)}
                            className="font-bold py-2 px-6 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            className="bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2 px-6 rounded-lg"
                        >
                            Save Settings
                        </button>
                    </div>
                </div>
            </div>
        )
    }

    return (
        <div className="w-full h-full p-4 md:p-6 rounded-lg">
            {isSettingsOpen && <SettingsModal />}
            <div className={mainGridContainerClasses}>

                {/* Team A Controls */}
                <div className="flex flex-col items-center justify-between p-4 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg space-y-4">
                    <h3 className="text-3xl font-display font-bold uppercase truncate" style={{color: gameState.teamA.color}}>{gameState.teamA.name}</h3>
                    <p className="text-7xl font-mono font-bold">{gameState.teamA.score}</p>
                    <div className="flex items-center space-x-2">
                        <ControlButton onClick={() => actions.updateScore('A', -1)} className="bg-brand-red hover:bg-opacity-80 text-white w-14 h-14" title="Decrement score" disabled={isFinished}><MinusIcon /></ControlButton>
                        {scoreIncrements[matchConfig.sport].map(inc => (
                             <ControlButton key={inc} onClick={() => actions.updateScore('A', inc)} className="bg-green-600 hover:bg-green-500 text-white w-14 h-14 text-2xl font-bold" title={`Increment score by ${inc}`} disabled={isFinished}>{`+${inc}`}</ControlButton>
                        ))}
                    </div>
                </div>

                {/* Main Controls */}
                <div className={`flex flex-col items-center p-4 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg space-y-4 ${mainControlsOrderClass}`}>
                     <div className="w-full flex justify-between items-center">
                        <button onClick={onToggleLayout} className="p-2 rounded-full hover:bg-light-border dark:hover:bg-dark-border" title="Toggle Layout">
                            {currentLayout === 'center' ? <LayoutSplitIcon /> : <LayoutCenterIcon />}
                        </button>
                        <h3 className="text-2xl font-bold font-display uppercase">Game Controls</h3>
                        <button onClick={() => setIsSettingsOpen(true)} className="p-2 rounded-full hover:bg-light-border dark:hover:bg-dark-border" title="Game Settings" disabled={isFinished}>
                            <SettingsIcon className="h-6 w-6" />
                        </button>
                     </div>
                     <div className="flex items-center space-x-4 h-20">
                        {renderMainActionButton()}
                        {matchConfig.gameMode === 'time' && (
                            <ControlButton onClick={onShowResetConfirm} className="bg-gray-500 hover:bg-gray-400 text-white w-20 h-20 rounded-full" title="Reset Clock" disabled={isFinished}><ResetIcon /></ControlButton>
                        )}
                     </div>
                     <div className="w-full flex justify-center items-center gap-4 pt-2">
                        <ControlButton onClick={actions.undo} disabled={!canUndo || isFinished} className="bg-gray-500 hover:bg-gray-400 text-white w-20 h-12" title="Undo">
                            <UndoIcon />
                        </ControlButton>
                        <ControlButton onClick={actions.redo} disabled={!canRedo || isFinished} className="bg-gray-500 hover:bg-gray-400 text-white w-20 h-12" title="Redo">
                            <RedoIcon />
                        </ControlButton>
                    </div>
                     
                    {gameState.status === GameStatus.Paused && (
                        <div className="w-full p-3 mt-2 rounded-lg border-2 border-dashed border-yellow-500 bg-yellow-500/10 animate-fade-in">
                            <h4 className="text-sm font-bold text-center text-yellow-500 uppercase mb-3 animate-pulse">GAME PAUSED - SET REASON</h4>
                            <div className={`grid ${pauseReasonGridClass} gap-2`}>
                                {pauseReasons.map(reason => (
                                    <button 
                                        key={reason}
                                        onClick={() => actions.setPauseReason(reason)}
                                        className="bg-yellow-500/20 text-yellow-200 hover:bg-yellow-500/40 font-semibold py-2 px-2 rounded-md text-sm transition-colors">
                                        {reason}
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}

                    {matchConfig.gameMode !== 'score' && (
                        <div className="flex items-center space-x-2">
                            <ControlButton onClick={actions.goToPreviousPeriod} disabled={isRunning || isFinished || gameState.currentPeriod <= 1} className="bg-light-border text-light-text dark:bg-dark-border dark:text-dark-text px-4 h-10">{`< ${periodLabel}`}</ControlButton>
                            <span className="font-bold text-lg w-24 text-center">{`${periodLabel} ${gameState.currentPeriod}`}</span>
                            <ControlButton onClick={actions.goToNextPeriod} disabled={isRunning || isFinished || gameState.currentPeriod >= matchConfig.periods} className="bg-light-border text-light-text dark:bg-dark-border dark:text-dark-text px-4 h-10">{`${periodLabel} >`}</ControlButton>
                        </div>
                    )}
                </div>

                {/* Team B Controls */}
                <div className="flex flex-col items-center justify-between p-4 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg space-y-4">
                    <h3 className="text-3xl font-display font-bold uppercase truncate" style={{color: gameState.teamB.color}}>{gameState.teamB.name}</h3>
                    <p className="text-7xl font-mono font-bold">{gameState.teamB.score}</p>
                    <div className="flex items-center space-x-2">
                        <ControlButton onClick={() => actions.updateScore('B', -1)} className="bg-brand-red hover:bg-opacity-90 text-white w-14 h-14" title="Decrement score" disabled={isFinished}><MinusIcon /></ControlButton>
                        {scoreIncrements[matchConfig.sport].map(inc => (
                             <ControlButton key={inc} onClick={() => actions.updateScore('B', inc)} className="bg-green-600 hover:bg-green-500 text-white w-14 h-14 text-2xl font-bold" title={`Increment score by ${inc}`} disabled={isFinished}>{`+${inc}`}</ControlButton>
                        ))}
                    </div>
                </div>
            </div>
            {showGlobalActions && 
                <MatchActions 
                    matchConfig={matchConfig}
                    gameState={gameState}
                    isFinished={isFinished}
                    actions={actions}
                    onToggleFullScreen={onToggleFullScreen}
                    onToggleMiniAudience={onToggleMiniAudience}
                    onLeaveMatch={onLeaveMatch}
                    onShowResetConfirm={onShowResetConfirm}
                />
            }
        </div>
    );
};

export default ControlPanel;
--- END FILE: components\ControlPanel.tsx ---

--- START FILE: components\CreateEditTeamModal.tsx ---
import React, { useState, useEffect } from 'react';
import type { SavedTeam } from '../types';
import { Sport } from '../types';
import ColorPicker from './form/ColorPicker';
import { TEAM_COLORS } from '../constants';

interface CreateEditTeamModalProps {
    onClose: () => void;
    onSave: (team: Omit<SavedTeam, 'id'> & { id?: string }) => void;
    initialData?: SavedTeam | null;
}

const CreateEditTeamModal: React.FC<CreateEditTeamModalProps> = ({ onClose, onSave, initialData }) => {
    const [name, setName] = useState('');
    const [color, setColor] = useState(TEAM_COLORS[0]);
    const [sport, setSport] = useState<Sport | 'Universal'>('Universal');

    useEffect(() => {
        if (initialData) {
            setName(initialData.name);
            setColor(initialData.color);
            setSport(initialData.sport || 'Universal');
        }
    }, [initialData]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onSave({ id: initialData?.id, name, color, sport });
    };

    const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";
    const sportButtonClasses = (s: string) => `p-3 rounded-md text-sm font-semibold text-center ${sport === s ? 'bg-brand-blue text-white ring-2 ring-brand-blue' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'}`;

    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-fade-in" 
            onClick={onClose}
        >
            <div 
                className="bg-light-background dark:bg-dark-card rounded-2xl w-full max-w-md p-6 md:p-8 shadow-2xl relative animate-modal-scale-in" 
                onClick={e => e.stopPropagation()}
            >
                <form onSubmit={handleSubmit}>
                    <h2 className="text-3xl font-bold font-display text-center mb-6">
                        {initialData ? 'Edit Team' : 'Create New Team'}
                    </h2>
                    
                    <div className="space-y-6">
                        <div>
                            <label htmlFor="teamName" className="block text-sm font-medium mb-1">Team Name</label>
                            <input
                                id="teamName"
                                type="text"
                                value={name}
                                onChange={e => setName(e.target.value)}
                                className={inputClasses}
                                required
                                autoFocus
                            />
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-2">Team Color</label>
                            <ColorPicker selectedColor={color} onSelect={setColor} />
                        </div>
                        <div>
                            <label className="block text-sm font-medium mb-2">Team Sport Association</label>
                            <div className="grid grid-cols-2 gap-2">
                                {['Universal', ...Object.values(Sport)].map(s => (
                                    <button
                                        key={s}
                                        type="button"
                                        onClick={() => setSport(s as Sport | 'Universal')}
                                        className={sportButtonClasses(s)}
                                    >
                                        {s}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="flex justify-end gap-4 mt-8">
                        <button
                            type="button"
                            onClick={onClose}
                            className="font-bold py-2 px-6 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                        >
                            Cancel
                        </button>
                        <button
                            type="submit"
                            className="bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2 px-6 rounded-lg"
                        >
                            {initialData ? 'Save Changes' : 'Create Team'}
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
};

export default CreateEditTeamModal;
--- END FILE: components\CreateEditTeamModal.tsx ---

--- START FILE: components\Dashboard.tsx ---
import React, { useState, useMemo } from 'react';
import { Sport, type Match, type MatchStatus } from '../types';
import SportIcon from './SportIcon';
import PlusIcon from './icons/PlusIcon';
import TrashIcon from './icons/TrashIcon';
import ArchiveIcon from './icons/ArchiveIcon';
import UnarchiveIcon from './icons/UnarchiveIcon';
import ListIcon from './icons/ListIcon';
import CheckIcon from './icons/CheckIcon';
import DeleteConfirmationModal from './DeleteConfirmationModal';

interface DashboardProps {
  matches: Match[];
  onManageMatch: (match: Match) => void;
  onGoToAudienceView: (match: Match) => void;
  onCreateMatch: () => void;
  onDeleteMatch: (matchId: string) => void;
  onArchiveMatch: (matchId: string) => void;
  onUnarchiveMatch: (matchId: string) => void;
  onGoToHistory: () => void;
  onToggleCompleteMatch: (matchId: string, isCompleted: boolean) => void;
  searchQuery: string;
}

const StatusBadge: React.FC<{ status: MatchStatus }> = ({ status }) => {
    const baseClasses = 'px-3 py-1 text-sm font-bold rounded-full';
    const statusClasses: Record<MatchStatus, string> = {
        'In Progress': 'bg-green-500/20 text-green-400',
        'Finished': 'bg-gray-500/20 text-gray-400',
        'Upcoming': 'bg-indigo-500/20 text-indigo-400',
    };
    return <span className={`${baseClasses} ${statusClasses[status]}`}>{status}</span>;
};

const dashboardFilters = ['All', Sport.Basketball, Sport.Soccer, Sport.Volleyball, 'Finished'];

const ConfirmationModal: React.FC<{
  title: string;
  description: string;
  onCancel: () => void;
  onConfirm: () => void;
  confirmText: string;
  confirmClass: string;
}> = ({ title, description, onCancel, onConfirm, confirmText, confirmClass }) => (
   <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50">
        <div className="rounded-xl p-8 w-full max-w-md mx-4 bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text shadow-2xl">
            <h3 className="text-2xl font-bold font-display mb-4">{title}</h3>
            <p className="text-light-text-muted dark:text-dark-text-muted mb-8">
                {description}
            </p>
            <div className="flex justify-end gap-4">
                <button
                    onClick={onCancel}
                    className="font-bold py-2 px-6 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                >
                    Cancel
                </button>
                <button
                    onClick={onConfirm}
                    className={`${confirmClass} text-white font-bold py-2 px-6 rounded-lg`}
                >
                    {confirmText}
                </button>
            </div>
        </div>
    </div>
);

const Dashboard: React.FC<DashboardProps> = ({ matches, onManageMatch, onGoToAudienceView, onCreateMatch, onDeleteMatch, onArchiveMatch, onUnarchiveMatch, onGoToHistory, onToggleCompleteMatch, searchQuery }) => {
    const [activeFilter, setActiveFilter] = useState<typeof dashboardFilters[number]>('All');
    const [viewMode, setViewMode] = useState<'active' | 'archived' | 'completed'>('active');
    const [archivingId, setArchivingId] = useState<string | null>(null);
    const [unarchivingId, setUnarchivingId] = useState<string | null>(null);
    const [completingId, setCompletingId] = useState<string | null>(null);
    const [bringingBackId, setBringingBackId] = useState<string | null>(null);
    const [confirmationState, setConfirmationState] = useState<{ match: Match; intent: 'archive' } | null>(null);
    const [completeConfirmationState, setCompleteConfirmationState] = useState<Match | null>(null);
    const [bringBackConfirmationState, setBringBackConfirmationState] = useState<Match | null>(null);
    const [matchToDelete, setMatchToDelete] = useState<Match | null>(null);

    const sportColorClasses: Record<Sport, { icon: string; filter: string }> = {
        [Sport.Basketball]: { icon: 'text-orange-500', filter: 'bg-orange-500 text-white' },
        [Sport.Soccer]: { icon: 'text-green-500', filter: 'bg-green-500 text-white' },
        [Sport.Volleyball]: { icon: 'text-sky-500', filter: 'bg-sky-500 text-white' },
    };

    const getFilterButtonClass = (filter: typeof dashboardFilters[number]) => {
        const baseClass = 'px-4 py-2 text-sm font-semibold rounded-full';
        const inactiveClass = 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border';
        
        if (activeFilter !== filter) {
            return `${baseClass} ${inactiveClass}`;
        }

        if (filter === 'All') return `${baseClass} bg-brand-blue text-white`;
        if (filter === 'Finished') return `${baseClass} bg-gray-500 text-white`;
        return `${baseClass} ${sportColorClasses[filter as Sport].filter}`;
    };

    const handleArchiveClick = (matchId: string) => {
        setArchivingId(matchId);
        setTimeout(() => {
            onArchiveMatch(matchId);
            setArchivingId(null);
            setConfirmationState(null); // Close modal after action
        }, 500); // Match animation duration
    };
    
    const handleMarkCompleteClick = (matchId: string) => {
        setCompletingId(matchId);
        setTimeout(() => {
            onToggleCompleteMatch(matchId, true);
            setCompletingId(null);
        }, 500); // Match animation duration
    };

    const handleUnarchiveClick = (matchId: string) => {
        setUnarchivingId(matchId);
        setTimeout(() => {
            onUnarchiveMatch(matchId);
            setUnarchivingId(null);
        }, 500); // Match animation duration
    };
    
    const handleBringBackClick = (matchId: string) => {
        setBringingBackId(matchId);
        setTimeout(() => {
            onToggleCompleteMatch(matchId, false);
            setBringingBackId(null);
            setBringBackConfirmationState(null);
        }, 500);
    };
    
    const getButtonText = (status: MatchStatus) => {
        switch (status) {
            case 'In Progress': return 'Resume Match';
            case 'Upcoming': return 'Start Match';
            case 'Finished': return 'View Results';
        }
    };

    const filteredMatches = useMemo(() => {
        const active: Match[] = [];
        const archived: Match[] = [];
        const completed: Match[] = [];

        for (const match of matches) {
            if (match.isArchived) {
                archived.push(match);
            } else if (match.isCompleted) {
                completed.push(match);
            } else {
                active.push(match);
            }
        }
        
        let sourceMatches: Match[];
        switch(viewMode) {
            case 'archived':
                sourceMatches = archived;
                break;
            case 'completed':
                sourceMatches = completed;
                break;
            default:
                sourceMatches = active;
                break;
        }
        
        return sourceMatches.filter(match => {
            // Category Filter (only for 'active' view)
            if (viewMode === 'active') {
                let passesCategoryFilter = true;
                if (activeFilter === 'Finished') {
                    passesCategoryFilter = match.status === 'Finished';
                } else if (activeFilter !== 'All' && Object.values(Sport).includes(activeFilter as Sport)) {
                    passesCategoryFilter = match.sport === activeFilter;
                }

                if (!passesCategoryFilter) return false;
            }


            // Global Search Filter
            if (searchQuery) {
                const lowerQuery = searchQuery.toLowerCase();
                const passesSearch =
                    match.teamA.name.toLowerCase().includes(lowerQuery) ||
                    match.teamB.name.toLowerCase().includes(lowerQuery) ||
                    match.sport.toLowerCase().includes(lowerQuery);
                if (!passesSearch) return false;
            }

            return true;
        });

    }, [matches, activeFilter, viewMode, searchQuery]);

    const dashboardTitle = useMemo(() => {
        switch (viewMode) {
            case 'archived': return 'Archived Matches';
            case 'completed': return 'Completed Matches';
            default: return 'Dashboard';
        }
    }, [viewMode]);

    return (
        <div className="p-4 sm:p-6 md:p-8">
            {matchToDelete && (
                <DeleteConfirmationModal
                    itemName={`${matchToDelete.teamA.name} vs ${matchToDelete.teamB.name}`}
                    itemType="match"
                    onCancel={() => setMatchToDelete(null)}
                    onConfirm={() => {
                        onDeleteMatch(matchToDelete.id);
                        setMatchToDelete(null);
                    }}
                />
            )}
            {confirmationState && (
                <ConfirmationModal
                    title="Archive Match?"
                    description="This will move the match to your archive. You can view or restore it from the 'Archived' screen."
                    onCancel={() => setConfirmationState(null)}
                    onConfirm={() => handleArchiveClick(confirmationState.match.id)}
                    confirmText="Archive"
                    confirmClass="bg-brand-blue hover:bg-opacity-90"
                />
            )}
             {completeConfirmationState && (
                <ConfirmationModal
                    title="Mark Match as Complete?"
                    description="This will move the match to your 'Completed' section. You can always move it back to the dashboard later."
                    onCancel={() => setCompleteConfirmationState(null)}
                    onConfirm={() => {
                        if (completeConfirmationState) {
                            handleMarkCompleteClick(completeConfirmationState.id);
                        }
                        setCompleteConfirmationState(null);
                    }}
                    confirmText="Mark Complete"
                    confirmClass="bg-purple-600 hover:bg-opacity-90"
                />
            )}
            {bringBackConfirmationState && (
                <ConfirmationModal
                    title="Bring Match Back?"
                    description="This will move the match back to your main dashboard in the 'Finished' state."
                    onCancel={() => setBringBackConfirmationState(null)}
                    onConfirm={() => handleBringBackClick(bringBackConfirmationState.id)}
                    confirmText="Bring Back"
                    confirmClass="bg-green-600 hover:bg-opacity-90"
                />
            )}
            <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4 mb-8">
                <h1 className="text-4xl md:text-5xl font-bold font-display">
                    {dashboardTitle}
                </h1>
                <div className="flex items-center gap-4">
                     {viewMode !== 'active' ? (
                        <button
                            onClick={() => setViewMode('active')}
                            className="flex items-center gap-2 font-semibold py-3 px-5 rounded-lg text-base sm:text-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                        >
                            &larr; Back to Dashboard
                        </button>
                    ) : (
                        <>
                            <button
                                onClick={() => setViewMode('archived')}
                                className="hidden sm:flex items-center gap-2 font-semibold py-3 px-5 rounded-lg text-base sm:text-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                            >
                                <ArchiveIcon />
                                View Archived
                            </button>
                             <button
                                onClick={() => setViewMode('completed')}
                                className="hidden sm:flex items-center gap-2 font-semibold py-3 px-5 rounded-lg text-base sm:text-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                            >
                                <CheckIcon className="h-6 w-6" />
                                Completed
                            </button>
                            <button
                                onClick={onGoToHistory}
                                className="hidden sm:flex items-center gap-2 font-semibold py-3 px-5 rounded-lg text-base sm:text-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                            >
                                <ListIcon />
                                History
                            </button>
                            <button
                                onClick={onCreateMatch}
                                className="flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-3 px-5 rounded-lg text-base sm:text-lg transition-transform duration-200 transform hover:scale-105 whitespace-nowrap"
                            >
                                <PlusIcon />
                                Create New Match
                            </button>
                        </>
                    )}
                </div>
            </div>

            {viewMode === 'active' && (
                 <div className="mb-6 flex flex-wrap items-center gap-2">
                    {dashboardFilters.map(filter => (
                        <button
                            key={filter}
                            onClick={() => setActiveFilter(filter)}
                            className={getFilterButtonClass(filter)}
                        >
                            {filter}
                        </button>
                    ))}
                </div>
            )}

            <main key={viewMode} className="animate-fade-in">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {filteredMatches.map(match => {
                        const colorClass = sportColorClasses[match.sport].icon;
                        return (
                        <div
                            key={match.id}
                            className={`bg-light-card dark:bg-dark-card rounded-xl shadow-lg p-6 flex flex-col justify-between hover:shadow-xl hover:-translate-y-1 ${
                                completingId === match.id ? 'animate-complete-fly-out' : ''
                            } ${
                                archivingId === match.id ? 'animate-archive-fly-out' : ''
                            } ${
                                unarchivingId === match.id ? 'animate-unarchive-fly-out' : ''
                            } ${
                                bringingBackId === match.id ? 'animate-unarchive-fly-out' : ''
                            } ${
                                viewMode !== 'active' ? 'grayscale opacity-75 hover:grayscale-0 hover:opacity-100' : ''
                            }`}
                        >
                            <div>
                                <div className="flex justify-between items-center mb-4">
                                    <div className={`flex items-center gap-3 font-semibold text-lg ${colorClass}`}>
                                        <SportIcon sport={match.sport} />
                                        <span>{match.sport}</span>
                                    </div>
                                    <StatusBadge status={match.status} />
                                </div>
                                <div className="text-center my-6">
                                    <p className="text-2xl font-bold truncate" style={{ color: match.teamA.color }}>{match.teamA.name}</p>
                                    <p className="text-xl font-mono text-light-text-muted dark:text-dark-text-muted my-1">vs</p>
                                    <p className="text-2xl font-bold truncate" style={{ color: match.teamB.color }}>{match.teamB.name}</p>
                                </div>
                            </div>
                             <div className="mt-4 space-y-2">
                                {viewMode === 'completed' ? (
                                    <div className="space-y-2">
                                        <button
                                            onClick={() => onManageMatch(match)}
                                            className="w-full flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2.5 px-3 rounded-lg text-sm"
                                        >
                                            <ListIcon /> View Match
                                        </button>
                                        <div className="grid grid-cols-3 gap-2">
                                            <button 
                                                onClick={() => onGoToAudienceView(match)}
                                                className="bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-semibold py-2 px-3 rounded-lg text-sm truncate">
                                                Audience
                                            </button>
                                            <button 
                                                onClick={() => setBringBackConfirmationState(match)}
                                                aria-label="Bring match back to dashboard"
                                                className="bg-green-600/20 hover:bg-green-600/30 text-green-400 font-semibold py-2 px-3 rounded-lg flex items-center justify-center gap-1 text-sm">
                                                <UnarchiveIcon /> Bring Back?
                                            </button>
                                            <button 
                                                onClick={() => setMatchToDelete(match)}
                                                aria-label="Delete match"
                                                className="border border-brand-red/50 text-brand-red hover:bg-brand-red hover:text-white font-semibold py-2 px-3 rounded-lg flex items-center justify-center transition-colors"
                                            >
                                                <TrashIcon />
                                            </button>
                                        </div>
                                    </div>
                                ) : viewMode === 'archived' ? (
                                    <div className="grid grid-cols-2 gap-2">
                                        <button 
                                            onClick={() => handleUnarchiveClick(match.id)}
                                            className="flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2.5 px-3 rounded-lg text-sm">
                                            <UnarchiveIcon /> Unarchive
                                        </button>
                                        <button 
                                            onClick={() => setMatchToDelete(match)}
                                            aria-label="Delete match"
                                            className="flex items-center justify-center gap-2 border border-brand-red/50 text-brand-red hover:bg-brand-red hover:text-white font-semibold py-2.5 px-3 rounded-lg transition-colors"
                                        >
                                            <TrashIcon /> Delete
                                        </button>
                                    </div>
                                ) : (
                                    <>
                                        {match.status === 'Finished' ? (
                                            <div className="space-y-2">
                                                <div className="grid grid-cols-2 gap-2">
                                                    <button
                                                        onClick={() => onManageMatch(match)}
                                                        className="w-full flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2.5 px-3 rounded-lg text-sm"
                                                    >
                                                        <CheckIcon /> View Results
                                                    </button>
                                                    <button 
                                                        onClick={() => setCompleteConfirmationState(match)}
                                                        className="w-full bg-purple-600/20 hover:bg-purple-600/30 text-purple-500 font-semibold py-2.5 px-3 rounded-lg flex items-center justify-center gap-2 text-sm"
                                                    >
                                                        <CheckIcon /> Mark as Complete
                                                    </button>
                                                </div>
                                                <div className="grid grid-cols-3 gap-2">
                                                    <button 
                                                        onClick={() => onGoToAudienceView(match)}
                                                        className="bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-semibold py-2 px-3 rounded-lg text-sm truncate">
                                                        Audience
                                                    </button>
                                                    <button 
                                                        onClick={() => setConfirmationState({ match, intent: 'archive' })}
                                                        aria-label="Archive match"
                                                        className="bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-semibold py-2 px-3 rounded-lg flex items-center justify-center">
                                                        <ArchiveIcon />
                                                    </button>
                                                    <button 
                                                        onClick={() => setMatchToDelete(match)}
                                                        aria-label="Delete match"
                                                        className="border border-brand-red/50 text-brand-red hover:bg-brand-red hover:text-white font-semibold py-2 px-3 rounded-lg flex items-center justify-center transition-colors"
                                                    >
                                                        <TrashIcon />
                                                    </button>
                                                </div>
                                            </div>
                                        ) : (
                                            <>
                                                <button 
                                                    onClick={() => onManageMatch(match)}
                                                    className={`w-full text-white font-bold py-2.5 px-3 rounded-lg text-sm ${
                                                        match.status === 'In Progress' ? 'bg-green-600 hover:bg-green-500' : 'bg-brand-blue hover:bg-opacity-90'
                                                    }`}>
                                                    {getButtonText(match.status)}
                                                </button>
                                                <div className="grid grid-cols-3 gap-2">
                                                    <button 
                                                        onClick={() => onGoToAudienceView(match)}
                                                        className="bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-semibold py-2 px-3 rounded-lg text-sm truncate">
                                                        Audience
                                                    </button>
                                                    <button 
                                                        onClick={() => setConfirmationState({ match, intent: 'archive' })}
                                                        aria-label="Archive match"
                                                        className="bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-semibold py-2 px-3 rounded-lg flex items-center justify-center">
                                                        <ArchiveIcon />
                                                    </button>
                                                    <button 
                                                        onClick={() => setMatchToDelete(match)}
                                                        aria-label="Delete match"
                                                        className="border border-brand-red/50 text-brand-red hover:bg-brand-red hover:text-white font-semibold py-2 px-3 rounded-lg flex items-center justify-center transition-colors"
                                                    >
                                                        <TrashIcon />
                                                    </button>
                                                </div>
                                            </>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    )})}
                </div>
            </main>
        </div>
    );
};

export default Dashboard;
--- END FILE: components\Dashboard.tsx ---

--- START FILE: components\DeleteConfirmationModal.tsx ---
import React, { useState, useEffect } from 'react';

interface DeleteConfirmationModalProps {
  itemName: string;
  onCancel: () => void;
  onConfirm: () => void;
  itemType: string; // e.g., 'match' or 'team'
}

const DeleteConfirmationModal: React.FC<DeleteConfirmationModalProps> = ({ itemName, onCancel, onConfirm, itemType }) => {
    const [inputValue, setInputValue] = useState('');
    const [isConfirmed, setIsConfirmed] = useState(false);

    useEffect(() => {
        // Trim whitespace and compare case-insensitively
        setIsConfirmed(inputValue.trim().toLowerCase() === itemName.trim().toLowerCase());
    }, [inputValue, itemName]);

    return (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fade-in">
            <div className="rounded-xl p-8 w-full max-w-md mx-4 bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text shadow-2xl border border-brand-red/50 animate-modal-scale-in">
                <h3 className="text-2xl font-bold font-display mb-4 text-brand-red">Confirm Deletion</h3>
                <p className="text-light-text-muted dark:text-dark-text-muted mb-6">
                    This action is irreversible. The {itemType} will be permanently deleted.
                    To confirm, please type "<strong className="text-light-text dark:text-dark-text break-all">{itemName}</strong>" in the box below.
                </p>
                
                <input
                    type="text"
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    className="w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-red focus:border-brand-red outline-none mb-6 font-mono"
                    aria-label={`Type ${itemName} to confirm deletion`}
                    autoFocus
                />

                <div className="flex justify-end gap-4">
                    <button
                        onClick={onCancel}
                        className="font-bold py-2 px-6 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={onConfirm}
                        disabled={!isConfirmed}
                        className="bg-brand-red hover:bg-opacity-90 disabled:bg-brand-red/40 disabled:cursor-not-allowed text-white font-bold py-2 px-6 rounded-lg"
                    >
                        Delete
                    </button>
                </div>
            </div>
        </div>
    );
};

export default DeleteConfirmationModal;
--- END FILE: components\DeleteConfirmationModal.tsx ---

--- START FILE: components\form\ColorPicker.tsx ---
import React, { useRef } from 'react';
import { TEAM_COLORS } from '../../constants';
import PaletteIcon from '../icons/PaletteIcon';

interface ColorPickerProps {
    selectedColor: string;
    onSelect: (color: string) => void;
}

const ColorPicker: React.FC<ColorPickerProps> = ({ selectedColor, onSelect }) => {
    const colorInputRef = useRef<HTMLInputElement>(null);
    
    // Normalize for comparison to handle hex case differences.
    const isCustomColorSelected = !TEAM_COLORS.some(c => c.toLowerCase() === selectedColor.toLowerCase());

    const handleCustomColorClick = () => {
        if (colorInputRef.current) {
            colorInputRef.current.click();
        }
    };
    
    const handleCustomColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        onSelect(e.target.value);
    };

    return (
        <div className="flex flex-wrap items-center gap-2">
            {TEAM_COLORS.map(color => (
                <button
                    key={color}
                    type="button"
                    onClick={() => onSelect(color)}
                    className={`w-8 h-8 rounded-full border-2 transition-transform duration-150 ${selectedColor.toLowerCase() === color.toLowerCase() ? 'border-light-text dark:border-dark-text scale-110' : 'border-transparent'}`}
                    style={{ backgroundColor: color }}
                    aria-label={`Select color ${color}`}
                />
            ))}
            
            <div className="relative">
                <button
                    type="button"
                    onClick={handleCustomColorClick}
                    className={`w-8 h-8 rounded-full border-2 flex items-center justify-center transition-transform duration-150
                    ${isCustomColorSelected ? 'border-light-text dark:border-dark-text scale-110' : 'border-transparent bg-light-card-secondary dark:bg-dark-card-secondary hover:border-light-text-muted dark:hover:border-dark-text-muted'}`}
                    style={{ 
                        backgroundColor: isCustomColorSelected ? selectedColor : undefined,
                    }}
                    aria-label="Select a custom color"
                >
                    {!isCustomColorSelected && <PaletteIcon className="w-5 h-5 text-light-text-muted dark:text-dark-text-muted" />}
                </button>
                <input
                    ref={colorInputRef}
                    type="color"
                    value={selectedColor}
                    onChange={handleCustomColorChange}
                    className="absolute opacity-0 w-0 h-0 pointer-events-none"
                    aria-hidden="true"
                    tabIndex={-1}
                />
            </div>
        </div>
    );
};

export default ColorPicker;
--- END FILE: components\form\ColorPicker.tsx ---

--- START FILE: components\HighestScoringGamesModal.tsx ---
import React, { useState, useMemo } from 'react';
import type { Match } from '../types';
import { Sport } from '../types';
import SportIcon from './SportIcon';
import TrophyIcon from './icons/TrophyIcon';
import FireIcon from './icons/FireIcon';

const getDateFromId = (id: string): string => {
    try {
        const timestamp = parseInt(id.split('-')[1], 10);
        if (isNaN(timestamp)) return 'Unknown Date';
        return new Date(timestamp).toLocaleDateString(undefined, {
            year: 'numeric', month: 'short', day: 'numeric'
        });
    } catch (e) {
        return 'Unknown Date';
    }
};

interface SportRecordCardProps {
    sport: Sport;
    record: { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; total: number };
    index: number;
}

const sportColorClasses: Record<Sport, { bg: string; text: string; }> = {
    [Sport.Basketball]: { bg: 'bg-orange-500/10', text: 'text-orange-500' },
    [Sport.Soccer]: { bg: 'bg-green-500/10', text: 'text-green-500' },
    [Sport.Volleyball]: { bg: 'bg-sky-500/10', text: 'text-sky-500' },
};


const SportRecordCard: React.FC<SportRecordCardProps> = ({ sport, record, index }) => {
    const { match, total } = record;
    const colorClass = sportColorClasses[sport];

    const setScores = useMemo(() => {
        if (sport !== Sport.Volleyball || !match?.periodScores) {
            return null;
        }
        return match.periodScores.reduce((acc, score) => {
            if (score.a > score.b) {
                acc.a++;
            } else if (score.b > score.a) {
                acc.b++;
            }
            return acc;
        }, { a: 0, b: 0 });
    }, [sport, match]);

    if (!match) {
        return (
            <div className={`bg-light-card-secondary dark:bg-dark-card-secondary p-5 rounded-lg flex flex-col items-center justify-center text-center animate-slide-in-bottom h-full`} style={{ animationDelay: `${index * 100}ms` }}>
                <div className={`p-3 rounded-full mb-3 ${colorClass.bg}`}>
                    <SportIcon sport={sport} className={`h-8 w-8 ${colorClass.text}`} />
                </div>
                <h3 className={`font-bold text-xl ${colorClass.text}`}>{sport}</h3>
                <p className="text-light-text-muted dark:text-dark-text-muted mt-2">No games played yet.</p>
            </div>
        );
    }
    
    const isTie = match.finalScoreA === match.finalScoreB;
    const isAWinner = match.finalScoreA > match.finalScoreB;
    const winner = isAWinner ? match.teamA : (match.finalScoreB > match.finalScoreA ? match.teamB : null);

    return (
        <div className={`bg-light-card-secondary dark:bg-dark-card-secondary p-5 rounded-lg flex flex-col animate-slide-in-bottom h-full`} style={{ animationDelay: `${index * 100}ms` }}>
            <div className={`flex items-center gap-3 mb-4 pb-4 border-b border-light-border dark:border-dark-border ${colorClass.text}`}>
                <SportIcon sport={sport} className="h-7 w-7" />
                <h3 className="font-bold text-xl">{sport}</h3>
            </div>

            <div className="text-sm text-light-text-muted dark:text-dark-text-muted mb-3 flex justify-between items-center">
                <span>{getDateFromId(match.id)}</span>
                <span className="flex items-center gap-1 font-semibold">
                    <FireIcon />
                    {total} Total Points
                </span>
            </div>
            
            <div className="grid grid-cols-[1fr_auto_1fr] items-center gap-2 text-center mb-4">
                <span className="text-lg font-bold truncate" style={{ color: match.teamA.color }}>{match.teamA.name}</span>
                <span className="text-lg font-mono text-light-text-muted dark:text-dark-text-muted">vs</span>
                <span className="text-lg font-bold truncate" style={{ color: match.teamB.color }}>{match.teamB.name}</span>
            </div>

            <div className={`text-center font-mono font-bold text-3xl ${setScores ? 'mb-2' : 'mb-4'}`}>
                {match.finalScoreA} - {match.finalScoreB}
            </div>

            {setScores && (
                <div className="text-center text-sm font-semibold text-light-text-muted dark:text-dark-text-muted mb-4">
                    Set Score: {setScores.a} - {setScores.b}
                </div>
            )}

            <div className="text-center font-semibold mb-4 text-sm">
                {isTie ? "It's a Tie!" : (
                    <div className="flex items-center justify-center gap-2 text-yellow-500">
                        <TrophyIcon className="h-5 w-5" />
                        <span>Winner: {winner?.name}</span>
                    </div>
                )}
            </div>

            {match.periodScores && match.periodScores.length > 0 && (
                <div className="mt-auto pt-4 border-t border-light-border dark:border-dark-border text-xs">
                    <p className="font-bold text-center mb-2">Score Breakdown</p>
                    <div className="flex justify-between items-center text-light-text-muted dark:text-dark-text-muted mb-1">
                        <span style={{color: match.teamA.color}}>{match.teamA.name}</span>
                        <span style={{color: match.teamB.color}}>{match.teamB.name}</span>
                    </div>
                    <div className="flex justify-between items-center font-mono">
                        <span>{match.periodScores.map(p => p.a).join(' | ')}</span>
                        <span>{match.periodScores.map(p => p.b).join(' | ')}</span>
                    </div>
                </div>
            )}
        </div>
    );
};


interface HighestScoringGamesModalProps {
    highestGamesBySportTime: Record<Sport, { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; total: number }>;
    highestGamesBySportScore: Record<Sport, { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; total: number }>;
    onClose: () => void;
}

const HighestScoringGamesModal: React.FC<HighestScoringGamesModalProps> = ({ highestGamesBySportTime, highestGamesBySportScore, onClose }) => {
    const [activeMode, setActiveMode] = useState<'time' | 'score'>('time');
    
    const dataToDisplay = activeMode === 'time' ? highestGamesBySportTime : highestGamesBySportScore;
    const sports = Object.keys(dataToDisplay) as Sport[];

    const segmentedButtonClasses = (isActive: boolean) => 
      `w-full px-4 py-2 text-sm font-semibold rounded-md focus:outline-none ${
        isActive ? 'bg-brand-blue text-white' : 'bg-light-card hover:bg-light-border dark:bg-dark-card dark:hover:bg-dark-border'
      }`;


    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-fade-in" 
            onClick={onClose}
            role="dialog"
            aria-modal="true"
            aria-labelledby="highest-scoring-title"
        >
            <div 
                className="bg-light-background dark:bg-dark-card rounded-2xl w-full max-w-5xl max-h-[90vh] flex flex-col p-6 md:p-8 shadow-2xl relative animate-modal-scale-in" 
                onClick={e => e.stopPropagation()}
            >
                <button 
                    onClick={onClose} 
                    className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                    aria-label="Close highest scoring games"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>

                <div className="flex-shrink-0 pb-4 mb-4 border-b border-light-border dark:border-dark-border">
                    <h2 id="highest-scoring-title" className="text-3xl font-bold font-display text-center">
                        Highest Scoring Games by Sport
                    </h2>
                    <div className="mt-4 max-w-xs mx-auto p-1 rounded-lg flex space-x-1 bg-light-card-secondary dark:bg-dark-card-secondary">
                        <button onClick={() => setActiveMode('time')} className={segmentedButtonClasses(activeMode === 'time')}>Time-based</button>
                        <button onClick={() => setActiveMode('score')} className={segmentedButtonClasses(activeMode === 'score')}>Score-based</button>
                    </div>
                </div>
                
                <div className="flex-grow overflow-y-auto pr-2 -mr-4">
                     <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        {sports.map((sport, index) => (
                           <SportRecordCard
                                key={sport}
                                sport={sport}
                                record={dataToDisplay[sport]}
                                index={index}
                           />
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default HighestScoringGamesModal;
--- END FILE: components\HighestScoringGamesModal.tsx ---

--- START FILE: components\icons\ArchiveIcon.tsx ---
import React from 'react';

const ArchiveIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M8 4H6a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-2m-4-1v8m0 0l3-3m-3 3L9 8m-5 5h2.586a1 1 0 01.707.293l2.414 2.414a1 1 0 001.414 0l2.414-2.414a1 1 0 01.707-.293H21" />
    </svg>
);

export default ArchiveIcon;
--- END FILE: components\icons\ArchiveIcon.tsx ---

--- START FILE: components\icons\BasketballIcon.tsx ---
import React from 'react';

interface IconProps {
    className?: string;
}

const BasketballIcon: React.FC<IconProps> = ({ className = "h-7 w-7" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 2a10 10 0 0 0-10 10c0 9 5 10 5 10"></path>
        <path d="M12 22a10 10 0 0 0 10-10c0-9-5-10-5-10"></path>
        <path d="M2 12h20"></path>
    </svg>
);

export default BasketballIcon;
--- END FILE: components\icons\BasketballIcon.tsx ---

--- START FILE: components\icons\CalendarIcon.tsx ---
import React from 'react';

const CalendarIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
    </svg>
);

export default CalendarIcon;
--- END FILE: components\icons\CalendarIcon.tsx ---

--- START FILE: components\icons\ChartBarIcon.tsx ---
import React from 'react';

const ChartBarIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9.5a2.5 2.5 0 015 0V19m-5 0h5m6-5a2 2 0 00-2-2h-2a2 2 0 00-2 2v5a2 2 0 002 2h2a2 2 0 002-2v-5z" />
    </svg>
);

export default ChartBarIcon;
--- END FILE: components\icons\ChartBarIcon.tsx ---

--- START FILE: components\icons\CheckIcon.tsx ---
import React from 'react';

const CheckIcon: React.FC<{className?: string}> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
    </svg>
);

export default CheckIcon;
--- END FILE: components\icons\CheckIcon.tsx ---

--- START FILE: components\icons\ClipboardListIcon.tsx ---
import React from 'react';

const ClipboardListIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
    </svg>
);

export default ClipboardListIcon;
--- END FILE: components\icons\ClipboardListIcon.tsx ---

--- START FILE: components\icons\ClockIcon.tsx ---
import React from 'react';

const ClockIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

export default ClockIcon;
--- END FILE: components\icons\ClockIcon.tsx ---

--- START FILE: components\icons\CopyIcon.tsx ---
import React from 'react';

const CopyIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
    </svg>
);

export default CopyIcon;
--- END FILE: components\icons\CopyIcon.tsx ---

--- START FILE: components\icons\DashboardIcon.tsx ---
import React from 'react';

const DashboardIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
    </svg>
);

export default DashboardIcon;
--- END FILE: components\icons\DashboardIcon.tsx ---

--- START FILE: components\icons\DatabaseIcon.tsx ---
import React from 'react';

const DatabaseIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7a8 8 0 0116 0" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 11c0 2.21 3.582 4 8 4s8-1.79 8-4" />
    </svg>
);

export default DatabaseIcon;
--- END FILE: components\icons\DatabaseIcon.tsx ---

--- START FILE: components\icons\DocumentTextIcon.tsx ---
import React from 'react';

const DocumentTextIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
    </svg>
);

export default DocumentTextIcon;
--- END FILE: components\icons\DocumentTextIcon.tsx ---

--- START FILE: components\icons\DownloadIcon.tsx ---
import React from 'react';

const DownloadIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
    </svg>
);

export default DownloadIcon;
--- END FILE: components\icons\DownloadIcon.tsx ---

--- START FILE: components\icons\EditIcon.tsx ---
import React from 'react';

const EditIcon: React.FC<{className?: string}> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
    </svg>
);

export default EditIcon;
--- END FILE: components\icons\EditIcon.tsx ---

--- START FILE: components\icons\ExitIcon.tsx ---
import React from 'react';

const ExitIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
    </svg>
);

export default ExitIcon;
--- END FILE: components\icons\ExitIcon.tsx ---

--- START FILE: components\icons\FireIcon.tsx ---
import React from 'react';

const FireIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7.014A8.003 8.003 0 0117.657 18.657z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.879 16.121A3 3 0 1012.014 13.986m-2.135 2.135L6 21m11.657-11.657L19.5 6.5" />
    </svg>
);

export default FireIcon;
--- END FILE: components\icons\FireIcon.tsx ---

--- START FILE: components\icons\FullScreenIcon.tsx ---

import React from 'react';

const FullScreenIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 8V4h4m12 4V4h-4m-8 12v4h4m8-4v4h-4" />
    </svg>
);

export default FullScreenIcon;
--- END FILE: components\icons\FullScreenIcon.tsx ---

--- START FILE: components\icons\LayoutCenterIcon.tsx ---
import React from 'react';

const LayoutCenterIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" stroke="none" fill="currentColor" fillOpacity="0.1"/>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
);

export default LayoutCenterIcon;
--- END FILE: components\icons\LayoutCenterIcon.tsx ---

--- START FILE: components\icons\LayoutSplitIcon.tsx ---
import React from 'react';

const LayoutSplitIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M2 6a2 2 0 012-2h16a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" fill="currentColor" fillOpacity="0.1" stroke="none"/>
      <path strokeLinecap="round" strokeLinejoin="round" d="M2 6a2 2 0 012-2h16a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V6zM12 4v16" />
    </svg>
);

export default LayoutSplitIcon;
--- END FILE: components\icons\LayoutSplitIcon.tsx ---

--- START FILE: components\icons\ListIcon.tsx ---
import React from 'react';

const ListIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
    </svg>
);

export default ListIcon;
--- END FILE: components\icons\ListIcon.tsx ---

--- START FILE: components\icons\MenuIcon.tsx ---
import React from 'react';

const MenuIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 12h16M4 18h16" />
    </svg>
);

export default MenuIcon;
--- END FILE: components\icons\MenuIcon.tsx ---

--- START FILE: components\icons\MinimizeIcon.tsx ---
import React from 'react';

const MinimizeIcon: React.FC<{ className?: string }> = ({ className = "h-4 w-4" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20 12H4" />
    </svg>
);

export default MinimizeIcon;
--- END FILE: components\icons\MinimizeIcon.tsx ---

--- START FILE: components\icons\MinusIcon.tsx ---

import React from 'react';

const MinusIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20 12H4" />
    </svg>
);

export default MinusIcon;
--- END FILE: components\icons\MinusIcon.tsx ---

--- START FILE: components\icons\MoonIcon.tsx ---
import React from 'react';

const MoonIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
    </svg>
);

export default MoonIcon;
--- END FILE: components\icons\MoonIcon.tsx ---

--- START FILE: components\icons\PaletteIcon.tsx ---
import React from 'react';

const PaletteIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01" />
    </svg>
);

export default PaletteIcon;
--- END FILE: components\icons\PaletteIcon.tsx ---

--- START FILE: components\icons\PauseIcon.tsx ---

import React from 'react';

const PauseIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" viewBox="0 0 24 24" fill="currentColor">
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
    </svg>
);

export default PauseIcon;
--- END FILE: components\icons\PauseIcon.tsx ---

--- START FILE: components\icons\PictureInPictureIcon.tsx ---
import React from 'react';

const PictureInPictureIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v-4a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M20 12V8a2 2 0 00-2-2H8a2 2 0 00-2 2v4" />
    </svg>
);

export default PictureInPictureIcon;
--- END FILE: components\icons\PictureInPictureIcon.tsx ---

--- START FILE: components\icons\PlayIcon.tsx ---
import React from 'react';

interface PlayIconProps {
  className?: string;
}

const PlayIcon: React.FC<PlayIconProps> = ({ className = "h-8 w-8" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="currentColor">
        <path d="M8 5v14l11-7z" />
    </svg>
);

export default PlayIcon;
--- END FILE: components\icons\PlayIcon.tsx ---

--- START FILE: components\icons\PlusIcon.tsx ---

import React from 'react';

const PlusIcon: React.FC<{className?: string}> = ({className = "h-6 w-6"}) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" />
    </svg>
);

export default PlusIcon;
--- END FILE: components\icons\PlusIcon.tsx ---

--- START FILE: components\icons\RedoIcon.tsx ---
import React from 'react';

const RedoIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M14 5l7 7m0 0l-7 7m7-7H3" transform="scale(-1, 1) translate(-24, 0)" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 1 1-9-9" />
    </svg>
);

export default RedoIcon;
--- END FILE: components\icons\RedoIcon.tsx ---

--- START FILE: components\icons\ResetIcon.tsx ---

import React from 'react';

const ResetIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 4v5h5M20 20v-5h-5" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 9a9 9 0 0114.13-6.36M20 15a9 9 0 01-14.13 6.36" />
    </svg>
);

export default ResetIcon;
--- END FILE: components\icons\ResetIcon.tsx ---

--- START FILE: components\icons\RestoreIcon.tsx ---
import React from 'react';

const RestoreIcon: React.FC<{ className?: string }> = ({ className = "h-4 w-4" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v-4a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2H6a2 2 0 01-2-2z" />
    </svg>
);

export default RestoreIcon;
--- END FILE: components\icons\RestoreIcon.tsx ---

--- START FILE: components\icons\SearchIcon.tsx ---
import React from 'react';

const SearchIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
    </svg>
);

export default SearchIcon;
--- END FILE: components\icons\SearchIcon.tsx ---

--- START FILE: components\icons\SettingsIcon.tsx ---
import React from 'react';

interface SettingsIconProps {
    className?: string;
}

const SettingsIcon: React.FC<SettingsIconProps> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

export default SettingsIcon;
--- END FILE: components\icons\SettingsIcon.tsx ---

--- START FILE: components\icons\SlidersIcon.tsx ---
import React from 'react';

const SlidersIcon: React.FC<{ className?: string }> = ({ className = "h-5 w-5" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6V4m0 16v-2m8-10V4m0 16v-2M4 14V4m0 16v-2m8-4v-2m0 6v2M4 8h16M4 16h16" />
    </svg>
);

export default SlidersIcon;
--- END FILE: components\icons\SlidersIcon.tsx ---

--- START FILE: components\icons\SoccerIcon.tsx ---
import React from 'react';

interface IconProps {
    className?: string;
}

const SoccerIcon: React.FC<IconProps> = ({ className = "h-7 w-7" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 2l-2.8 4.8-4.8 2.8 2.8 4.8 4.8-2.8z"></path>
        <path d="M12 22l2.8-4.8 4.8-2.8-2.8-4.8-4.8 2.8z"></path>
        <path d="M2 12l4.8 2.8 2.8-4.8-4.8-2.8z"></path>
        <path d="M22 12l-4.8-2.8-2.8 4.8 4.8 2.8z"></path>
    </svg>
);

export default SoccerIcon;
--- END FILE: components\icons\SoccerIcon.tsx ---

--- START FILE: components\icons\SparkleIcon.tsx ---
import React from 'react';

const SparkleIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-brand-blue" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M5 3v4M3 5h4M16 17v4m-2-2h4M19 3l-1.414 1.414M5 19l1.414-1.414M12 2v2m0 16v2M3 12h2m14 0h2" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 5a2 2 0 100 4 2 2 0 000-4zM12 15a2 2 0 100 4 2 2 0 000-4z" />
    </svg>
);

export default SparkleIcon;
--- END FILE: components\icons\SparkleIcon.tsx ---

--- START FILE: components\icons\SunIcon.tsx ---
import React from 'react';

const SunIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
    </svg>
);

export default SunIcon;
--- END FILE: components\icons\SunIcon.tsx ---

--- START FILE: components\icons\TrashIcon.tsx ---
import React from 'react';

const TrashIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </svg>
);

export default TrashIcon;
--- END FILE: components\icons\TrashIcon.tsx ---

--- START FILE: components\icons\TrendingUpIcon.tsx ---
import React from 'react';

const TrendingUpIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
    </svg>
);

export default TrendingUpIcon;
--- END FILE: components\icons\TrendingUpIcon.tsx ---

--- START FILE: components\icons\TrophyIcon.tsx ---
import React from 'react';

interface TrophyIconProps {
    className?: string;
}

const TrophyIcon: React.FC<TrophyIconProps> = ({ className = "h-20 w-20 md:h-24 md:w-24 text-yellow-400" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 18.75h-9a9.75 9.75 0 011.05-4.293l.25-1.002a2.25 2.25 0 011.968-1.63H12a2.25 2.25 0 011.968 1.63l.25 1.002A9.75 9.75 0 0116.5 18.75z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M18.75 9.75h.008v.008h-.008v-.008zm-13.5 0h.008v.008h-.008v-.008z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 11.25V21M8.25 6h7.5" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 2.25c2.485 0 4.5 2.015 4.5 4.5v.75H7.5V6.75c0-2.485 2.015-4.5 4.5-4.5z" />
    </svg>
);

export default TrophyIcon;
--- END FILE: components\icons\TrophyIcon.tsx ---

--- START FILE: components\icons\UnarchiveIcon.tsx ---
import React from 'react';

const UnarchiveIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1" />
    </svg>
);

export default UnarchiveIcon;
--- END FILE: components\icons\UnarchiveIcon.tsx ---

--- START FILE: components\icons\UndoIcon.tsx ---
import React from 'react';

const UndoIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" transform="scale(-1, 1) translate(-24, 0)" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 12a9 9 0 1 0 9-9" />
    </svg>
);

export default UndoIcon;
--- END FILE: components\icons\UndoIcon.tsx ---

--- START FILE: components\icons\UploadIcon.tsx ---
import React from 'react';

const UploadIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
    </svg>
);

export default UploadIcon;
--- END FILE: components\icons\UploadIcon.tsx ---

--- START FILE: components\icons\UserIcon.tsx ---
import React from 'react';

const UserIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-10 w-10 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
    </svg>
);

export default UserIcon;
--- END FILE: components\icons\UserIcon.tsx ---

--- START FILE: components\icons\UsersIcon.tsx ---
import React from 'react';

const UsersIcon: React.FC<{ className?: string }> = ({ className = "h-7 w-7" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.653-.122-1.28-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.653.122-1.28.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
    </svg>
);

export default UsersIcon;
--- END FILE: components\icons\UsersIcon.tsx ---

--- START FILE: components\icons\VolleyballIcon.tsx ---
import React from 'react';

interface IconProps {
    className?: string;
}

const VolleyballIcon: React.FC<IconProps> = ({ className = "h-7 w-7" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M12 2c-3 3-3 8 0 10s3 7 0 10"></path>
        <path d="M12 2c3 3 3 8 0 10s-3 7 0 10"></path>
        <path d="M2 12c3-3 8-3 10 0s7 3 10 0"></path>
    </svg>
);

export default VolleyballIcon;
--- END FILE: components\icons\VolleyballIcon.tsx ---

--- START FILE: components\icons\WarningIcon.tsx ---
import React from 'react';

const WarningIcon: React.FC<{ className?: string }> = ({ className = "h-6 w-6" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
);

export default WarningIcon;
--- END FILE: components\icons\WarningIcon.tsx ---

--- START FILE: components\LandingPage.tsx ---
import React from 'react';
import TrophyIcon from './icons/TrophyIcon';
import BasketballIcon from './icons/BasketballIcon';
import SoccerIcon from './icons/SoccerIcon';
import VolleyballIcon from './icons/VolleyballIcon';
import { Sport, type Theme } from '../types';
import PaletteIcon from './icons/PaletteIcon';

interface LandingPageProps {
    onGetStarted: () => void;
    toggleTheme: () => void;
    theme: Theme;
}

const SportCard: React.FC<{ icon: React.ReactNode, title: string }> = ({ icon, title }) => (
    <div className="bg-light-card/80 dark:bg-dark-card/50 p-6 rounded-xl flex flex-col items-center justify-center text-center ring-1 ring-white/10 transition-all duration-300 hover:-translate-y-2 hover:shadow-2xl hover:shadow-brand-blue/20">
        <div className="mb-4 text-brand-blue">{icon}</div>
        <h3 className="font-bold text-2xl font-display text-light-text dark:text-dark-text">{title}</h3>
    </div>
);

const LandingPage: React.FC<LandingPageProps> = ({ onGetStarted, toggleTheme, theme }) => {
    
    const getTitleClass = (theme: Theme) => {
        const themeClasses: Partial<Record<Theme, string>> = {
            viola: 'text-gradient-viola',
            dark: 'text-gradient-dark',
            coder: 'text-gradient-coder',
            light: 'text-gradient-light',
        };
        return themeClasses[theme] || 'text-brand-blue';
    };

    return (
        <div className="min-h-screen w-full bg-light-background dark:bg-dark-background text-light-text dark:text-dark-text flex items-center justify-center p-4 relative">
             <button
                onClick={toggleTheme}
                className="absolute top-6 right-6 p-3 rounded-full bg-light-card/80 dark:bg-dark-card/50 hover:bg-light-border dark:hover:bg-dark-border ring-1 ring-white/10 transition-colors"
                aria-label="Cycle theme"
            >
                <PaletteIcon className="h-6 w-6" />
            </button>
            <div className="max-w-3xl text-center">
                <div className="inline-block p-5 bg-light-card dark:bg-dark-card rounded-2xl mb-6 ring-1 ring-white/10">
                    <TrophyIcon className="h-16 w-16 text-brand-blue" />
                </div>
                <h1 className={`text-5xl md:text-7xl font-bold font-display mb-4 ${getTitleClass(theme)}`}>
                    Project: Iskor-App
                </h1>
                <p className="text-lg md:text-xl text-light-text-muted dark:text-dark-text-muted mb-10 max-w-2xl mx-auto">
                    Turning Sports Matches into Legendary Showdowns.
                </p>

                <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 mb-12">
                   <SportCard
                        icon={<BasketballIcon className="h-12 w-12" />}
                        title={Sport.Basketball}
                    />
                    <SportCard
                        icon={<SoccerIcon className="h-12 w-12" />}
                        title={Sport.Soccer}
                    />
                    <SportCard
                        icon={<VolleyballIcon className="h-12 w-12" />}
                        title={Sport.Volleyball}
                    />
                </div>

                <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
                    <button
                        onClick={onGetStarted}
                        className="w-full sm:w-auto bg-brand-blue hover:bg-opacity-90 text-white get-started-btn font-bold py-3 px-8 rounded-lg text-lg transition-transform duration-200 transform hover:scale-105"
                    >
                        Get Started
                    </button>
                </div>

                <p className="text-sm text-light-text-muted dark:text-dark-text-muted mb-4">
                    Perfect for sports organizers, coaches, PE teachers, and live streamers
                </p>
                <p className="text-xs text-light-text-muted/50 dark:text-dark-text-muted/50">
                    made by KPD13
                </p>
            </div>
        </div>
    );
};

export default LandingPage;
--- END FILE: components\LandingPage.tsx ---

--- START FILE: components\layout\Header.tsx ---


import React from 'react';
import type { Theme, View } from '../../types';
import PaletteIcon from '../icons/PaletteIcon';
import TrophyIcon from '../icons/TrophyIcon';
import SearchIcon from '../icons/SearchIcon';

interface HeaderProps {
    activeView: View;
    navigateTo: (view: View) => void;
    theme: Theme;
    toggleTheme: () => void;
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}

const NavLink: React.FC<{
    label: string;
    isActive: boolean;
    onClick: () => void;
}> = ({ label, isActive, onClick }) => {
    return (
        <button
            onClick={onClick}
            className={`px-3 py-2 rounded-md font-semibold whitespace-nowrap ${
                isActive
                    ? 'text-light-text dark:text-dark-text'
                    : 'text-light-text-muted hover:text-light-text dark:text-dark-text-muted dark:hover:text-dark-text'
            }`}
        >
            {label}
             {isActive && (
                <div className="mt-1 h-0.5 w-full bg-brand-blue rounded-full" />
            )}
        </button>
    );
};

const Header: React.FC<HeaderProps> = ({ activeView, navigateTo, theme, toggleTheme, searchQuery, setSearchQuery }) => {
    return (
        <header className="sticky top-0 z-20 w-full bg-light-card/80 dark:bg-dark-card/80 backdrop-blur-sm shadow-sm">
            <div className="max-w-screen-xl mx-auto px-4 sm:px-6 md:px-8 flex items-center justify-between h-16 gap-4">
                <button onClick={() => navigateTo('landing')} className="flex items-center gap-2 flex-shrink-0">
                    <TrophyIcon className="h-8 w-8 text-brand-blue" />
                    <h1 className="text-xl font-bold font-display hidden sm:block">
                        Project: Iskor-App
                    </h1>
                </button>

                {(activeView === 'dashboard' || activeView === 'teams') && (
                    <div className="relative flex-1 max-w-lg mx-auto hidden md:block">
                        <input
                            type="text"
                            placeholder="Search teams, sports, matches..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className="w-full bg-light-background dark:bg-dark-background border border-light-border dark:border-dark-border rounded-lg py-2 pl-10 pr-4 focus:ring-2 focus:ring-brand-blue outline-none"
                        />
                        <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                            <SearchIcon className="h-5 w-5 text-light-text-muted dark:text-dark-text-muted" />
                        </div>
                    </div>
                )}
                
                <div className="flex items-center flex-shrink-0">
                    <nav className="hidden lg:flex items-center gap-1">
                        <NavLink label="Dashboard" isActive={activeView === 'dashboard'} onClick={() => navigateTo('dashboard')} />
                        <NavLink label="Teams" isActive={activeView === 'teams'} onClick={() => navigateTo('teams')} />
                        <NavLink label="Analytics" isActive={activeView === 'analytics'} onClick={() => navigateTo('analytics')} />
                        <NavLink label="History" isActive={activeView === 'history'} onClick={() => navigateTo('history')} />
                        <NavLink label="Settings" isActive={activeView === 'settings'} onClick={() => navigateTo('settings')} />
                    </nav>
                     <button
                        onClick={toggleTheme}
                        className="p-2 rounded-full hover:bg-light-card-secondary dark:hover:bg-dark-card-secondary"
                        aria-label="Cycle theme"
                     >
                        <PaletteIcon className="h-6 w-6" />
                     </button>
                </div>
            </div>
        </header>
    );
};

export default Header;
--- END FILE: components\layout\Header.tsx ---

--- START FILE: components\layout\Layout.tsx ---
import React from 'react';
import Header from './Header';
import type { Theme, View } from '../../types';

interface LayoutProps {
    children: React.ReactNode;
    activeView: View;
    navigateTo: (view: View) => void;
    theme: Theme;
    toggleTheme: () => void;
    searchQuery: string;
    setSearchQuery: (query: string) => void;
}

const Layout: React.FC<LayoutProps> = ({ children, activeView, navigateTo, theme, toggleTheme, searchQuery, setSearchQuery }) => {
    return (
        <div className="min-h-screen flex flex-col bg-light-background text-light-text dark:bg-dark-background dark:text-dark-text">
            <Header 
                activeView={activeView}
                navigateTo={navigateTo}
                theme={theme}
                toggleTheme={toggleTheme}
                searchQuery={searchQuery}
                setSearchQuery={setSearchQuery}
            />
            <main className="flex-1 w-full max-w-screen-xl mx-auto">
                {children}
            </main>
        </div>
    );
};

export default Layout;
--- END FILE: components\layout\Layout.tsx ---

--- START FILE: components\layout\Sidebar.tsx ---
import React from 'react';
import type { Theme, View, GameStatus } from '../../types';
import { GameStatus as GameStatusEnum } from '../../types';
import DashboardIcon from '../icons/DashboardIcon';
import SettingsIcon from '../icons/SettingsIcon';
import SunIcon from '../icons/SunIcon';
import MoonIcon from '../icons/MoonIcon';
import CheckIcon from '../icons/CheckIcon';

interface SidebarProps {
    isOpen: boolean;
    setIsOpen: (isOpen: boolean) => void;
    theme: Theme;
    toggleTheme: () => void;
    navigateTo: (view: View) => void;
    isMatchActive: boolean;
    matchStatus: GameStatus | null;
}

const NavLink: React.FC<{ icon: React.ReactNode, label: string, onClick: () => void }> = ({ icon, label, onClick }) => (
    <button onClick={onClick} className="flex items-center w-full px-4 py-3 rounded-lg text-light-text-muted hover:bg-light-card-secondary hover:text-light-text dark:text-dark-text-muted dark:hover:bg-dark-card-secondary dark:hover:text-dark-text">
        <span className="mr-4">{icon}</span>
        <span className="font-semibold">{label}</span>
    </button>
);

const Sidebar: React.FC<SidebarProps> = ({ isOpen, setIsOpen, theme, toggleTheme, navigateTo, isMatchActive, matchStatus }) => {
    const renderMatchStatusIndicator = () => {
        if (!isMatchActive) return null;

        if (matchStatus === GameStatusEnum.Finished) {
            return (
                <div className="mb-4 px-4 py-2 bg-green-500/20 rounded-lg flex items-center justify-center text-green-400">
                    <CheckIcon />
                    <span className="font-semibold text-sm ml-2">Match Finished</span>
                </div>
            );
        }

        return (
            <div className="mb-4 px-4 py-2 bg-green-500/10 rounded-lg flex items-center justify-center">
               <span className="relative flex h-3 w-3 mr-3">
                 <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                 <span className="relative inline-flex rounded-full h-3 w-3 bg-green-500"></span>
               </span>
               <span className="text-green-400 font-semibold text-sm">Match Active</span>
            </div>
        );
    };

    return (
        <>
            {/* Overlay for mobile */}
            <div
                className={`fixed inset-0 z-20 bg-black/50 transition-opacity lg:hidden ${isOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}
                onClick={() => setIsOpen(false)}
            />

            {/* Sidebar */}
            <aside
                className={`fixed top-0 left-0 z-30 h-full w-64 transform transition-transform duration-300 ease-in-out lg:relative lg:translate-x-0 lg:w-72 flex flex-col p-4 bg-light-card dark:bg-dark-card shadow-lg
                ${isOpen ? 'translate-x-0' : '-translate-x-full'}`}
            >
                <div className="flex items-center mb-10 px-2">
                    <h1 className="text-2xl font-bold font-display">Sports Scoreboard Pro</h1>
                </div>

                <nav className="flex-1 space-y-2">
                    <NavLink icon={<DashboardIcon />} label="Dashboard" onClick={() => navigateTo('dashboard')} />
                    <NavLink icon={<SettingsIcon />} label="Settings" onClick={() => navigateTo('settings')} />
                </nav>
                
                {renderMatchStatusIndicator()}

                <div className="space-y-4">
                    <button
                        onClick={toggleTheme}
                        title="Toggle Theme"
                        className="w-full flex items-center justify-center gap-3 p-3 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                    >
                        {theme === 'dark' ? <><SunIcon /> Light Mode</> : <><MoonIcon /> Dark Mode</>}
                    </button>
                </div>
            </aside>
        </>
    );
};

export default Sidebar;
--- END FILE: components\layout\Sidebar.tsx ---

--- START FILE: components\MatchActions.tsx ---
import React from 'react';
import type { GameState, MatchConfig } from '../types';
import CheckIcon from './icons/CheckIcon';
import PictureInPictureIcon from './icons/PictureInPictureIcon';
import FullScreenIcon from './icons/FullScreenIcon';
import DashboardIcon from './icons/DashboardIcon';
import ResetIcon from './icons/ResetIcon';

// This is a local, self-contained definition to avoid creating another new file.
const ControlButton: React.FC<{ onClick?: () => void; children: React.ReactNode; className?: string, title?: string, disabled?: boolean }> = ({ onClick, children, className = '', title, disabled = false }) => (
    <button
        onClick={onClick}
        title={title}
        disabled={disabled}
        className={`flex items-center justify-center p-3 rounded-lg font-semibold transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-dark-card disabled:opacity-50 disabled:cursor-not-allowed ${className}`}
    >
        {children}
    </button>
);


interface MatchActionsProps {
    matchConfig: MatchConfig;
    gameState: GameState;
    isFinished: boolean;
    actions: {
        finishMatchManually: () => void;
    };
    onToggleMiniAudience: () => void;
    onToggleFullScreen: () => void;
    onLeaveMatch: () => void;
    onShowResetConfirm: () => void;
}

const MatchActions: React.FC<MatchActionsProps> = ({
    matchConfig,
    gameState,
    isFinished,
    actions,
    onToggleMiniAudience,
    onToggleFullScreen,
    onLeaveMatch,
    onShowResetConfirm,
}) => {
    return (
        <div className="mt-6 flex justify-center space-x-4">
            {matchConfig.gameMode !== 'score' && gameState.currentPeriod === matchConfig.periods && !isFinished && (
                <ControlButton onClick={actions.finishMatchManually} className="bg-green-600 hover:bg-green-500 text-white flex gap-2 px-6 py-3 text-lg" title="Finish Match">
                    <CheckIcon />
                    Finish Match
                </ControlButton>
            )}
            <ControlButton onClick={onToggleMiniAudience} className="bg-indigo-500 hover:bg-indigo-400 text-white flex gap-2 px-6 py-3 text-lg" title="Project Mini-View">
                <PictureInPictureIcon />
                Project
            </ControlButton>
            <ControlButton onClick={onToggleFullScreen} className="bg-brand-blue hover:bg-opacity-90 text-white flex gap-2 px-6 py-3 text-lg" title="Toggle Fullscreen View">
                <FullScreenIcon />
                Audience View
            </ControlButton>
            {isFinished ? (
                <ControlButton onClick={onLeaveMatch} className="bg-brand-blue hover:bg-opacity-90 text-white flex gap-2 px-6 py-3 text-lg" title="Back to Dashboard">
                    <DashboardIcon />
                    Dashboard
                </ControlButton>
            ) : (
                <ControlButton onClick={onShowResetConfirm} className="bg-brand-red hover:bg-opacity-90 text-white flex gap-2 px-6 py-3 text-lg" title="Reset match and start over">
                    <ResetIcon />
                    Reset Match
                </ControlButton>
            )}
        </div>
    );
};

export default MatchActions;
--- END FILE: components\MatchActions.tsx ---

--- START FILE: components\MatchDetailModal.tsx ---
import React, { useState } from 'react';
import type { Match, GameState } from '../types';
import { GameStatus } from '../types';
import BoxScore from './BoxScore';
import MiniAudienceWindow from './MiniAudienceWindow';
import PictureInPictureIcon from './icons/PictureInPictureIcon';
import MatchResult from './MatchResult';

interface MatchDetailModalProps {
    match: Match;
    onClose: () => void;
}

const MatchDetailModal: React.FC<MatchDetailModalProps> = ({ match, onClose }) => {
    const [isProjectorOpen, setIsProjectorOpen] = useState(false);

    // Construct a comprehensive GameState object from the match prop for child components.
    const displayGameState: GameState = {
        teamA: { ...match.teamA, score: match.finalScoreA ?? 0 },
        teamB: { ...match.teamB, score: match.finalScoreB ?? 0 },
        currentPeriod: match.periods,
        status: GameStatus.Finished,
        periodScores: match.periodScores ?? [],
        // Derive setScores for volleyball for backward compatibility with older match data.
        setScores: match.sport === 'Volleyball' ? (match.periodScores || []).reduce((acc, score) => {
            if (score && score.a > score.b) acc.a++;
            if (score && score.b > score.a) acc.b++;
            return acc;
        }, { a: 0, b: 0 }) : undefined,
    };
    
    const isAWinner = (match.finalScoreA ?? 0) > (match.finalScoreB ?? 0);
    const winner = isAWinner ? match.teamA : ((match.finalScoreB ?? 0) > (match.finalScoreA ?? 0) ? match.teamB : null);
    const winnerColor = winner?.color ?? '#4f46e5';
    
    const hasPeriodData = match.periodScores && match.periodScores.length > 0;

    return (
        <>
            {isProjectorOpen && (
                <MiniAudienceWindow
                    config={match}
                    matchId={match.id}
                    onClose={() => setIsProjectorOpen(false)}
                />
            )}
            <div 
                className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-modal-scale-in" 
                onClick={onClose}
                role="dialog"
                aria-modal="true"
                aria-labelledby="match-details-title"
            >
                <div 
                    className="bg-light-background dark:bg-dark-background rounded-2xl w-full max-w-5xl max-h-[90vh] overflow-y-auto p-6 md:p-8 shadow-2xl relative" 
                    onClick={e => e.stopPropagation()}
                >
                    <button 
                        onClick={() => setIsProjectorOpen(true)}
                        className="absolute top-4 left-4 p-2 flex items-center gap-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                        title="Project match results"
                    >
                        <PictureInPictureIcon />
                        <span className="text-sm font-semibold hidden sm:inline">Project</span>
                    </button>
                    <button 
                        onClick={onClose} 
                        className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                        aria-label="Close match details"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>

                    <h2 id="match-details-title" className="text-3xl font-bold font-display text-center mb-6">Match Details</h2>

                    <div 
                        className="mb-6 animate-content-slide-up"
                        style={{
                            boxShadow: `0 0 30px -10px ${winnerColor}`,
                            borderRadius: '0.5rem',
                            animationDelay: '100ms'
                        } as React.CSSProperties}
                    >
                        <MatchResult match={match} />
                    </div>
                    
                    <div 
                        className="animate-content-slide-up"
                        style={{ animationDelay: '250ms' } as React.CSSProperties}
                    >
                        {hasPeriodData ? (
                            <BoxScore gameState={displayGameState} matchConfig={match} />
                        ) : (
                            <div className="text-center p-6 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg border border-light-border dark:border-dark-border">
                                <p className="font-semibold text-light-text dark:text-dark-text">
                                    Detailed period-by-period stats are not available for this match.
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </>
    );
};

export default MatchDetailModal;
--- END FILE: components\MatchDetailModal.tsx ---

--- START FILE: components\MatchHistoryPage.tsx ---
import React, { useState, useMemo } from 'react';
import type { Match } from '../types';
import { Sport } from '../types';
import SportIcon from './SportIcon';
import CalendarIcon from './icons/CalendarIcon';
import TrophyIcon from './icons/TrophyIcon';
import MatchDetailModal from './MatchDetailModal';
import { getDateFromId } from '../utils';

const sportFilters = ['All', Sport.Basketball, Sport.Soccer, Sport.Volleyball];

const MatchHistoryCard: React.FC<{ match: Match; onClick: () => void; }> = ({ match, onClick }) => {
    const isTie = match.finalScoreA === match.finalScoreB;
    const isAWinner = (match.finalScoreA ?? 0) > (match.finalScoreB ?? 0);
    const isBWinner = (match.finalScoreB ?? 0) > (match.finalScoreA ?? 0);

    return (
        <button 
            onClick={onClick} 
            className="bg-light-card dark:bg-dark-card rounded-xl shadow-lg p-5 flex flex-col justify-between hover:shadow-xl hover:-translate-y-1 w-full text-left focus:outline-none focus:ring-2 focus:ring-brand-blue"
            aria-label={`View details for match ${match.teamA.name} vs ${match.teamB.name}`}
        >
            {/* Header */}
            <div className="flex justify-between items-center mb-4 text-sm text-light-text-muted dark:text-dark-text-muted">
                <div className="flex items-center gap-2 font-semibold">
                    <SportIcon sport={match.sport} className="h-5 w-5" />
                    <span>{match.sport}</span>
                </div>
                <span>{getDateFromId(match.id)}</span>
            </div>

            {/* Scores */}
            <div className="grid grid-cols-[1fr_auto_1fr] items-center gap-4 text-center">
                {/* Team A */}
                <div className="flex flex-col items-center">
                    <span className="text-lg font-bold truncate max-w-full" style={{ color: match.teamA.color }}>
                        {match.teamA.name}
                    </span>
                    <span className={`text-5xl font-display ${isAWinner ? 'font-bold' : 'font-normal'}`}>
                        {match.finalScoreA}
                    </span>
                </div>

                <span className="text-2xl font-semibold text-light-text-muted dark:text-dark-text-muted">VS</span>

                {/* Team B */}
                <div className="flex flex-col items-center">
                    <span className="text-lg font-bold truncate max-w-full" style={{ color: match.teamB.color }}>
                        {match.teamB.name}
                    </span>
                    <span className={`text-5xl font-display ${isBWinner ? 'font-bold' : 'font-normal'}`}>
                        {match.finalScoreB}
                    </span>
                </div>
            </div>

            {/* Footer / Winner Info */}
            <div className="mt-4 pt-4 border-t border-light-border dark:border-dark-border flex items-center justify-center text-center font-semibold">
                {isTie ? (
                    <span>It's a Tie!</span>
                ) : (
                    <div className="flex items-center gap-2 text-yellow-500">
                        <TrophyIcon className="h-5 w-5" />
                        <span>Winner: {isAWinner ? match.teamA.name : match.teamB.name}</span>
                    </div>
                )}
            </div>
        </button>
    );
};

const MatchHistoryPage: React.FC<{ matches: Match[] }> = ({ matches }) => {
    const [activeSportFilter, setActiveSportFilter] = useState('All');
    const [searchQuery, setSearchQuery] = useState('');
    const [dateRange, setDateRange] = useState({ start: '', end: '' });
    const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);


    const finishedMatches = useMemo(() =>
        matches
            .filter(m => m.status === 'Finished')
            .sort((a, b) => parseInt(b.id.split('-')[1]) - parseInt(a.id.split('-')[1])),
        [matches]
    );

    const filteredMatches = useMemo(() => {
        return finishedMatches.filter(match => {
            if (activeSportFilter !== 'All' && match.sport !== activeSportFilter) {
                return false;
            }

            if (searchQuery &&
                !match.teamA.name.toLowerCase().includes(searchQuery.toLowerCase()) &&
                !match.teamB.name.toLowerCase().includes(searchQuery.toLowerCase())) {
                return false;
            }

            const matchTimestamp = parseInt(match.id.split('-')[1], 10);
            if (isNaN(matchTimestamp)) return true;

            if (dateRange.start) {
                const startDate = new Date(dateRange.start).setHours(0, 0, 0, 0);
                if (matchTimestamp < startDate) return false;
            }
            if (dateRange.end) {
                const endDate = new Date(dateRange.end).setHours(23, 59, 59, 999);
                if (matchTimestamp > endDate) return false;
            }

            return true;
        });
    }, [finishedMatches, activeSportFilter, searchQuery, dateRange]);
    
    const inputClasses = "bg-light-card-secondary dark:bg-dark-card-secondary border border-light-border dark:border-dark-border rounded-lg p-2 focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";
    const sportButtonClasses = (filter: string) => `px-4 py-2 text-sm font-semibold rounded-full ${activeSportFilter === filter ? 'bg-brand-blue text-white' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'}`;

    return (
        <div className="p-4 sm:p-6 md:p-8 animate-fade-in">
            <h1 className="text-4xl md:text-5xl font-bold font-display mb-8">Match History</h1>

            <div className="bg-light-card dark:bg-dark-card p-4 rounded-xl shadow-sm mb-8 space-y-4 md:space-y-0 md:flex md:items-center md:justify-between gap-4">
                <div className="flex-1 min-w-0 md:min-w-[200px]">
                    <input
                        type="text"
                        placeholder="Search by team name..."
                        value={searchQuery}
                        onChange={e => setSearchQuery(e.target.value)}
                        className={`w-full ${inputClasses}`}
                    />
                </div>

                <div className="flex items-center gap-2">
                    <div className="relative">
                        <input type="date" value={dateRange.start} onChange={e => setDateRange(prev => ({ ...prev, start: e.target.value }))} className={`${inputClasses} pr-8`} />
                        <CalendarIcon className="absolute right-2 top-1/2 -translate-y-1/2 h-5 w-5 text-light-text-muted dark:text-dark-text-muted pointer-events-none" />
                    </div>
                    <span>-</span>
                     <div className="relative">
                        <input type="date" value={dateRange.end} onChange={e => setDateRange(prev => ({ ...prev, end: e.target.value }))} className={`${inputClasses} pr-8`} />
                        <CalendarIcon className="absolute right-2 top-1/2 -translate-y-1/2 h-5 w-5 text-light-text-muted dark:text-dark-text-muted pointer-events-none" />
                    </div>
                </div>
                
                <div className="flex flex-wrap items-center gap-2 justify-center">
                    {sportFilters.map(filter => (
                        <button key={filter} onClick={() => setActiveSportFilter(filter)} className={sportButtonClasses(filter)}>
                            {filter}
                        </button>
                    ))}
                </div>
            </div>

            {filteredMatches.length > 0 ? (
                 <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    {filteredMatches.map(match => (
                        <MatchHistoryCard key={match.id} match={match} onClick={() => setSelectedMatch(match)} />
                    ))}
                </div>
            ) : (
                <div className="bg-light-card dark:bg-dark-card rounded-lg p-8 text-center shadow-sm">
                    <h2 className="text-2xl font-bold mb-4">No Matches Found</h2>
                    <p className="text-light-text-muted dark:text-dark-text-muted">
                        No completed matches match your criteria. Try adjusting your filters or play a new game!
                    </p>
                </div>
            )}
            
            {selectedMatch && (
                <MatchDetailModal match={selectedMatch} onClose={() => setSelectedMatch(null)} />
            )}
        </div>
    );
};

export default MatchHistoryPage;
--- END FILE: components\MatchHistoryPage.tsx ---

--- START FILE: components\MatchResult.tsx ---
import React from 'react';
import type { Match } from '../types';
import SportIcon from './SportIcon';

const TeamResult: React.FC<{ name: string; score: number | undefined; color: string; isWinner: boolean; }> = ({ name, score, color, isWinner }) => (
    <div 
        className={`flex flex-col items-center justify-center text-center p-6 rounded-lg transition-all duration-300 ${isWinner ? 'shadow-lg scale-105' : 'opacity-80'}`} 
        style={{ backgroundColor: color }}
    >
        <h2 className="font-display font-bold uppercase text-shadow-heavy text-white tracking-wider truncate w-full" style={{ fontSize: 'clamp(1.5rem, 3vw, 2.5rem)' }}>
            {name}
        </h2>
        <p className="font-display font-bold text-shadow-heavy text-white leading-none" style={{ fontSize: 'clamp(4rem, 10vw, 10rem)' }}>
            {score ?? '-'}
        </p>
    </div>
);

const MatchResult: React.FC<{ match: Match }> = ({ match }) => {
    const { teamA, teamB, finalScoreA, finalScoreB, sport } = match;

    const isAWinner = (finalScoreA ?? -1) > (finalScoreB ?? -1);
    const isBWinner = (finalScoreB ?? -1) > (finalScoreA ?? -1);
    const isTie = finalScoreA === finalScoreB;

    return (
        <div className="relative bg-light-card dark:bg-dark-card rounded-lg">
            <div className="grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4 items-center">
                <TeamResult name={teamA.name} score={finalScoreA} color={teamA.color} isWinner={isAWinner} />
                
                <div className="text-center font-display uppercase text-light-text-muted dark:text-dark-text-muted my-4 md:my-0">
                    <p className="text-4xl md:text-6xl font-bold">VS</p>
                    <div className="flex items-center justify-center gap-2 mt-2">
                        <SportIcon sport={sport} className="h-6 w-6" />
                        <p className="text-lg md:text-xl font-semibold tracking-wider">{sport}</p>
                    </div>
                    {isTie && (
                        <p className="text-2xl font-bold uppercase mt-4">
                            Tie
                        </p>
                    )}
                </div>

                <TeamResult name={teamB.name} score={finalScoreB} color={teamB.color} isWinner={isBWinner} />
            </div>
        </div>
    );
};

export default MatchResult;
--- END FILE: components\MatchResult.tsx ---

--- START FILE: components\MatchView.tsx ---
import React, { useState, useEffect, useRef } from 'react';
import type { Match, MatchConfig, GameState, PauseReason, Theme } from '../types';
import { GameStatus, Sport } from '../types';
import Scoreboard from './Scoreboard';
import ControlPanel from './ControlPanel';
import BoxScore from './BoxScore';
import TrophyIcon from './icons/TrophyIcon';
import WarningIcon from './icons/WarningIcon';
import MiniAudienceWindow from './MiniAudienceWindow';
import MatchActions from './MatchActions';
import MatchResult from './MatchResult';
import FullScreenIcon from './icons/FullScreenIcon';
import DashboardIcon from './icons/DashboardIcon';

interface MatchViewProps {
    match: Match;
    matchConfig: MatchConfig;
    gameState: GameState;
    clock: {
        time: number;
        isRunning: boolean;
    };
    actions: {
        start: () => void;
        pause: () => void;
        reset: () => void;
        updateScore: (team: 'A' | 'B', delta: number) => void;
        setPauseReason: (reason: PauseReason) => void;
        startNextPeriod: () => void;
        goToNextPeriod: () => void;
        goToPreviousPeriod: () => void;
        finishMatchManually: () => void;
        undo: () => void;
        redo: () => void;
    };
    onLeaveMatch: () => void;
    activeMatchId: string;
    onUpdateMatchConfig: (newConfig: Partial<MatchConfig>) => void;
    canUndo: boolean;
    canRedo: boolean;
    theme: Theme;
    toggleTheme: () => void;
}

const useCountUp = (end: number, duration = 1000) => {
    const [count, setCount] = useState(0);
    useEffect(() => {
        if (end === 0) {
            setCount(0);
            return;
        }
        let startTime: number | null = null;
        const animate = (timestamp: number) => {
            if (!startTime) startTime = timestamp;
            const progress = timestamp - startTime;
            const percentage = Math.min(progress / duration, 1);
            const current = Math.floor(percentage * end);
            setCount(current);
            if (progress < duration) {
                requestAnimationFrame(animate);
            } else {
                setCount(end);
            }
        };
        requestAnimationFrame(animate);
    }, [end, duration]);
    return count;
};

const ConfettiContainer: React.FC<{ color: string }> = ({ color }) => {
    const numConfetti = 50;
    return (
        <div className="confetti-container">
            {Array.from({ length: numConfetti }).map((_, i) => (
                <div
                    key={i}
                    className="confetti"
                    style={{
                        left: `${Math.random() * 100}%`,
                        animationDelay: `${Math.random() * 5}s`,
                        transform: `scale(${Math.random() * 0.5 + 0.5})`,
                        '--winner-glow': color,
                    } as React.CSSProperties}
                />
            ))}
        </div>
    );
};

const MatchView: React.FC<MatchViewProps> = (props) => {
    const { match, matchConfig, gameState, clock, actions, onLeaveMatch, onUpdateMatchConfig, activeMatchId, canUndo, canRedo, theme, toggleTheme } = props;
    
    const [isFullScreen, setIsFullScreen] = useState(false);
    const fullscreenRef = useRef<HTMLDivElement>(null);
    const [isWinnerOverlayVisible, setWinnerOverlayVisible] = useState(gameState.status === GameStatus.Finished);
    const [isMiniAudienceOpen, setIsMiniAudienceOpen] = useState(false);
    const [layout, setLayout] = useState<'center' | 'side-by-side'>('center');
    const [tilt, setTilt] = useState({ x: 0, y: 0 });
    const [showResetConfirm, setShowResetConfirm] = useState(false);

    const isVolleyball = matchConfig.sport === Sport.Volleyball;
    const finalScoreA = isVolleyball ? (gameState.setScores?.a ?? 0) : gameState.teamA.score;
    const finalScoreB = isVolleyball ? (gameState.setScores?.b ?? 0) : gameState.teamB.score;
    
    const animatedScoreA = useCountUp(finalScoreA, 1200);
    const animatedScoreB = useCountUp(finalScoreB, 1200);

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        const card = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - card.left;
        const y = e.clientY - card.top;
        const rotateX = -1 * ((card.height / 2 - y) / (card.height / 2)) * 8;
        const rotateY = ((card.width / 2 - x) / (card.width / 2)) * 8;
        setTilt({ x: rotateX, y: rotateY });
    };

    const handleMouseLeave = () => {
        setTilt({ x: 0, y: 0 });
    };


    const toggleLayout = () => {
        setLayout(prev => prev === 'center' ? 'side-by-side' : 'center');
    };


    const toggleFullScreen = () => {
        if (!fullscreenRef.current) return;
        if (!isFullScreen) {
            fullscreenRef.current.requestFullscreen().then(() => setIsFullScreen(true));
        } else {
            document.exitFullscreen().then(() => setIsFullScreen(false));
        }
    };

    useEffect(() => {
        const handleFullScreenChange = () => {
            setIsFullScreen(!!document.fullscreenElement);
        };
        document.addEventListener('fullscreenchange', handleFullScreenChange);
        return () => document.removeEventListener('fullscreenchange', handleFullScreenChange);
    }, []);

    useEffect(() => {
        if (gameState.status === GameStatus.Finished) {
            setWinnerOverlayVisible(true);
        }
    }, [gameState.status]);
    
    const ConfirmationModal: React.FC<{
      title: string;
      description: string;
      onCancel: () => void;
      onConfirm: () => void;
      confirmText: string;
      confirmClass: string;
    }> = ({ title, description, onCancel, onConfirm, confirmText, confirmClass }) => (
       <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
            <div className="rounded-xl p-8 w-full max-w-md mx-4 bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text shadow-2xl">
                <h3 className="text-2xl font-bold font-display mb-4">{title}</h3>
                <p className="text-light-text-muted dark:text-dark-text-muted mb-8">
                    {description}
                </p>
                <div className="flex justify-end gap-4">
                    <button
                        onClick={onCancel}
                        className="font-bold py-2 px-6 rounded-lg bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={onConfirm}
                        className={`${confirmClass} text-white font-bold py-2 px-6 rounded-lg`}
                    >
                        {confirmText}
                    </button>
                </div>
            </div>
        </div>
    );


    const renderOverlay = () => {
        if (gameState.status === GameStatus.PeriodBreak) {
            return (
                <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 text-white p-8 text-center">
                    <h1 className="text-5xl md:text-7xl font-bold font-display mb-6">{gameState.message}</h1>
                    <button onClick={actions.startNextPeriod} className="bg-brand-blue hover:bg-opacity-90 text-white font-bold py-4 px-8 rounded-lg text-2xl transition-transform duration-200 transform hover:scale-105">
                        Start Next {matchConfig.sport === 'Volleyball' ? 'Set' : 'Period'}
                    </button>
                </div>
            )
        }

        if (gameState.status === GameStatus.Finished && isWinnerOverlayVisible) {
            const isTie = gameState.winner === 'TIE';
            const winnerData = gameState.winner === 'A' ? gameState.teamA : (gameState.winner === 'B' ? gameState.teamB : null);

            let totalPointsA = 0;
            let totalPointsB = 0;
            if (isVolleyball && gameState.periodScores) {
                gameState.periodScores.forEach(score => {
                    totalPointsA += score.a;
                    totalPointsB += score.b;
                });
            }

            let bestPeriodStat: string | null = null;
            let consistencyStat: string | null = null;
            const periodLabel = matchConfig.sport === 'Volleyball' ? 'Set' : (matchConfig.sport === 'Soccer' ? 'Half' : 'Period');

            if (winnerData && gameState.periodScores && gameState.periodScores.length > 0) {
                let maxDiff = -1;
                let bestPeriodIndex = -1;
            
                gameState.periodScores.forEach((score, index) => {
                    const diff = gameState.winner === 'A' ? score.a - score.b : score.b - score.a;
                    if (diff > maxDiff) {
                        maxDiff = diff;
                        bestPeriodIndex = index;
                    }
                });
            
                if (bestPeriodIndex !== -1) {
                    bestPeriodStat = `Best Performance: +${maxDiff} in ${periodLabel} ${bestPeriodIndex + 1}`;
                }
            
                const allPeriodsWon = gameState.periodScores.every(score => 
                    gameState.winner === 'A' ? score.a > score.b : score.b > score.a
                );
                if (allPeriodsWon) {
                    consistencyStat = "Dominant victory: Won every period!";
                }
            }


            return (
                 <div 
                    className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-30 p-4 animate-fade-in"
                    onMouseMove={handleMouseMove}
                    onMouseLeave={handleMouseLeave}
                 >
                    <div
                        className="relative w-full max-w-md rounded-2xl p-8 flex flex-col items-center shadow-2xl bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text transition-transform duration-200"
                        style={{
                            '--winner-glow': winnerData?.color ?? '#A855F7',
                            transform: `perspective(1000px) rotateX(${tilt.x}deg) rotateY(${tilt.y}deg) scale(1.02)`
                        } as React.CSSProperties}
                    >
                         <div className="absolute -inset-2 rounded-full bg-[--winner-glow] opacity-20 blur-3xl animate-glow"></div>
                         <div className="absolute inset-0 sunburst-bg rounded-2xl overflow-hidden"></div>
                         <ConfettiContainer color={winnerData?.color ?? '#A855F7'} />

                        <div className="relative animate-trophy-bounce-enhanced z-10">
                            <TrophyIcon className="h-28 w-28 text-yellow-400" />
                        </div>
                        
                        <div className="relative animate-fade-in-delay-1 z-10 text-center">
                            {!isTie && winnerData ? (
                                <>
                                    <h1 className="text-4xl md:text-5xl font-bold font-display uppercase mt-4">Winner</h1>
                                    <h2 className="text-3xl md:text-4xl font-bold font-display mt-2 truncate max-w-full" style={{ color: winnerData.color }}>
                                        {winnerData.name}
                                    </h2>
                                </>
                            ) : (
                                <h1 className="text-5xl md:text-6xl font-bold font-display uppercase">It's a Tie!</h1>
                            )}
                        </div>

                        <p className="relative text-4xl md:text-5xl font-mono font-bold my-6 animate-fade-in-delay-2 z-10">
                            {animatedScoreA} - {animatedScoreB}
                        </p>

                        {isVolleyball && (
                            <p className="relative text-base text-light-text-muted dark:text-dark-text-muted -mt-4 mb-6 animate-fade-in-delay-2 z-10">
                                Total Points: {totalPointsA} - {totalPointsB}
                            </p>
                        )}

                        {(bestPeriodStat || consistencyStat) && (
                            <div className="relative text-center my-4 space-y-2 p-4 bg-light-card-secondary/80 dark:bg-dark-card-secondary/80 rounded-lg animate-fade-in-delay-3 w-full z-10">
                                {bestPeriodStat && <p className="text-sm font-semibold">{bestPeriodStat}</p>}
                                {consistencyStat && <p className="text-sm font-semibold text-green-500">{consistencyStat}</p>}
                            </div>
                        )}
                        
                        <div className={`relative flex flex-col sm:flex-row items-center gap-4 mt-6 w-full z-10 ${(bestPeriodStat || consistencyStat) ? 'animate-fade-in-delay-4' : 'animate-fade-in-delay-3'}`}>
                            <button 
                                onClick={() => setWinnerOverlayVisible(false)} 
                                className="w-full font-bold py-3 px-6 rounded-lg text-lg transform hover:scale-105 bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border"
                            >
                                View Box Score
                            </button>
                            <button 
                                onClick={onLeaveMatch} 
                                className="w-full bg-brand-blue hover:bg-opacity-90 text-white font-bold py-3 px-6 rounded-lg text-lg transform hover:scale-105"
                            >
                                Dashboard
                            </button>
                        </div>
                    </div>
                </div>
            );
        }
        
        return null;
    }

    const TieBreakIndicator = (
        <div className="w-full max-w-7xl mx-auto mb-4 p-6 rounded-lg shadow-md bg-light-card text-light-text dark:bg-dark-card dark:text-dark-text border-2 border-dashed border-yellow-500 text-center animate-fade-in">
            <h2 className="text-4xl font-display font-bold text-yellow-500 mb-2">
                Set Tie-Break
            </h2>
            <p className="text-lg text-light-text-muted dark:text-dark-text-muted">
                A 2-point lead is required to win this set.
            </p>
            <p className="font-semibold mt-2">
                Continue using the score controls to determine the winner.
            </p>
        </div>
    );

    const ScoreOrTieBreak = gameState.status === GameStatus.TieBreak
        ? TieBreakIndicator
        : (matchConfig.gameMode !== 'score' && <BoxScore gameState={gameState} matchConfig={matchConfig} />);

    if (gameState.status === GameStatus.Finished && !isWinnerOverlayVisible) {
        return (
            <div className="p-4 md:p-6 w-full animate-fade-in">
                 <div className="w-full max-w-7xl mx-auto relative">
                     <button onClick={onLeaveMatch} className="absolute top-0 -left-2 md:-left-4 text-light-text-muted hover:text-light-text dark:text-dark-text-muted dark:hover:text-dark-text flex items-center gap-2 mb-4">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                        </svg>
                        Back to Dashboard
                    </button>
                    <div className="w-full relative pt-12 text-center">
                        <h2 className="text-2xl font-bold font-display uppercase text-light-text-muted dark:text-dark-text-muted mb-2">Final</h2>
                        <div className="mb-6">
                            <MatchResult match={match} />
                        </div>
                        <BoxScore gameState={gameState} matchConfig={matchConfig} />
                        <div className="mt-8 flex justify-center items-center gap-4">
                             <button onClick={toggleFullScreen} className="flex items-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform hover:scale-105">
                                <FullScreenIcon /> Audience View
                            </button>
                            <button onClick={onLeaveMatch} className="flex items-center gap-2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform hover:scale-105">
                                <DashboardIcon /> Dashboard
                            </button>
                        </div>
                     </div>
                 </div>
            </div>
        );
    }

    return (
        <div className="p-4 md:p-6 w-full">
            {showResetConfirm && (
                <ConfirmationModal 
                  title="Reset Match?"
                  description="This will reset all scores and the clock, allowing you to start the match over from Period 1. This action cannot be undone."
                  onCancel={() => setShowResetConfirm(false)}
                  onConfirm={() => {
                      actions.reset();
                      setShowResetConfirm(false);
                  }}
                  confirmText="Confirm Reset"
                  confirmClass="bg-brand-red hover:bg-opacity-90"
                />
            )}
            <div className="w-full max-w-7xl mx-auto relative">
                {isMiniAudienceOpen && (
                    <MiniAudienceWindow
                        config={matchConfig}
                        matchId={activeMatchId}
                        onClose={() => setIsMiniAudienceOpen(false)}
                        theme={theme}
                        toggleTheme={toggleTheme}
                    />
                )}
                {gameState.notification && (
                    <div className="fixed bottom-8 left-1/2 -translate-x-1/2 z-40 animate-slide-in-bottom">
                        <div className="bg-brand-red text-white font-semibold px-6 py-3 rounded-lg shadow-lg flex items-center gap-3">
                            <WarningIcon className="h-6 w-6" />
                            <span>{gameState.notification.message}</span>
                        </div>
                    </div>
                )}
                <button onClick={onLeaveMatch} className="absolute top-0 -left-2 md:-left-4 text-light-text-muted hover:text-light-text dark:text-dark-text-muted dark:hover:text-dark-text flex items-center gap-2 mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                    Back to Dashboard
                </button>
                <div className="w-full relative pt-12">
                     {renderOverlay()}
                     {layout === 'center' ? (
                        <>
                             <div ref={fullscreenRef} className="bg-light-card dark:bg-dark-card rounded-lg shadow-lg">
                                <div className={`transition-all duration-300 ease-in-out relative ${isFullScreen ? 'h-screen w-screen flex items-center justify-center fixed inset-0 z-50' : 'p-2'}`}>
                                    <Scoreboard
                                        config={matchConfig}
                                        state={gameState}
                                        time={clock.time}
                                        isFullScreen={isFullScreen}
                                    />
                                </div>
                            </div>
                            
                            <div className={`transition-opacity duration-300 mt-4 ${isFullScreen ? 'opacity-0 h-0 overflow-hidden' : 'opacity-100'}`}>
                                {ScoreOrTieBreak}
                                <ControlPanel {...props} onToggleFullScreen={toggleFullScreen} onToggleMiniAudience={() => setIsMiniAudienceOpen(true)} onToggleLayout={toggleLayout} currentLayout={layout} canUndo={canUndo} canRedo={canRedo} onShowResetConfirm={() => setShowResetConfirm(true)} />
                            </div>
                        </>
                     ) : (
                         <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                            <div className="space-y-6 lg:col-span-2">
                                <div ref={fullscreenRef} className="bg-light-card dark:bg-dark-card rounded-lg shadow-lg">
                                    <div className="p-2">
                                         <Scoreboard
                                            config={matchConfig}
                                            state={gameState}
                                            time={clock.time}
                                            isFullScreen={false} 
                                        />
                                    </div>
                                </div>
                                {ScoreOrTieBreak}
                                <MatchActions 
                                    matchConfig={matchConfig}
                                    gameState={gameState}
                                    isFinished={gameState.status === GameStatus.Finished}
                                    actions={actions}
                                    onToggleMiniAudience={() => setIsMiniAudienceOpen(true)}
                                    onToggleFullScreen={toggleFullScreen}
                                    onLeaveMatch={onLeaveMatch}
                                    onShowResetConfirm={() => setShowResetConfirm(true)}
                                />
                            </div>
                            <div className="bg-light-card dark:bg-dark-card rounded-lg shadow-lg">
                                 <ControlPanel 
                                    {...props} 
                                    onToggleFullScreen={toggleFullScreen} 
                                    onToggleMiniAudience={() => setIsMiniAudienceOpen(true)} 
                                    onToggleLayout={toggleLayout} 
                                    currentLayout={layout} 
                                    canUndo={canUndo} 
                                    canRedo={canRedo} 
                                    showGlobalActions={false} 
                                    onShowResetConfirm={() => setShowResetConfirm(true)} 
                                />
                            </div>
                         </div>
                     )}
                </div>
            </div>
        </div>
    );
};

export default MatchView;
--- END FILE: components\MatchView.tsx ---

--- START FILE: components\MiniAudienceWindow.tsx ---
import React, { useState, useRef, useEffect, useCallback } from 'react';
import type { MatchConfig, Theme } from '../types';
import AudienceView from './AudienceView';
import PictureInPictureIcon from './icons/PictureInPictureIcon';
import MinimizeIcon from './icons/MinimizeIcon';
import RestoreIcon from './icons/RestoreIcon';
import SunIcon from './icons/SunIcon';
import MoonIcon from './icons/MoonIcon';

interface MiniAudienceWindowProps {
    config: MatchConfig;
    matchId: string;
    onClose: () => void;
    theme: Theme;
    toggleTheme: (e: React.MouseEvent) => void;
}

const useDraggable = (ref: React.RefObject<HTMLDivElement>) => {
    const [position, setPosition] = useState({ x: 50, y: 50 });
    const isDraggingRef = useRef(false);
    const offsetRef = useRef({ x: 0, y: 0 });

    const onMouseDown = useCallback((e: React.MouseEvent) => {
        if (ref.current && !(e.target as HTMLElement).closest('button')) {
            isDraggingRef.current = true;
            const rect = ref.current.getBoundingClientRect();
            offsetRef.current = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
            };
            document.body.style.cursor = 'grabbing';
            document.body.style.userSelect = 'none';
        }
    }, [ref]);

    const onMouseUp = useCallback(() => {
        isDraggingRef.current = false;
        document.body.style.cursor = 'default';
        document.body.style.userSelect = 'auto';
    }, []);

    const onMouseMove = useCallback((e: MouseEvent) => {
        if (isDraggingRef.current) {
            setPosition({
                x: e.clientX - offsetRef.current.x,
                y: e.clientY - offsetRef.current.y,
            });
        }
    }, []);

    useEffect(() => {
        const mouseMoveHandler = (e: MouseEvent) => onMouseMove(e);
        const mouseUpHandler = () => onMouseUp();
        
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
        
        return () => {
            document.removeEventListener('mousemove', mouseMoveHandler);
            document.removeEventListener('mouseup', mouseUpHandler);
        };
    }, [onMouseMove, onMouseUp]);

    return { position, onMouseDown };
};


const MiniAudienceWindow: React.FC<MiniAudienceWindowProps> = ({ config, matchId, onClose, theme, toggleTheme }) => {
    const windowRef = useRef<HTMLDivElement>(null);
    const { position, onMouseDown } = useDraggable(windowRef);
    const [isMinimized, setIsMinimized] = useState(false);
    const lastSizeRef = useRef({ width: 480, height: 270 });
    
    const isDarkTheme = ['dark', 'viola', 'coder'].includes(theme);

    const toggleMinimize = () => {
        const element = windowRef.current;
        if (!element) return;

        if (isMinimized) {
            // Restore: apply the last known size before restoring state
            element.style.width = `${lastSizeRef.current.width}px`;
            element.style.height = `${lastSizeRef.current.height}px`;
        } else {
             const rect = element.getBoundingClientRect();
             lastSizeRef.current = { width: rect.width, height: rect.height };
        }
        setIsMinimized(p => !p);
    };

    return (
        <div
            ref={windowRef}
            className={`fixed z-50 bg-dark-card shadow-2xl rounded-lg border border-dark-border overflow-hidden transition-all duration-300 w-[480px]`}
            style={{ 
                left: `${position.x}px`, 
                top: `${position.y}px`, 
                aspectRatio: isMinimized ? 'auto' : '16 / 9',
                resize: isMinimized ? 'none' : 'both',
                ...(isMinimized && { width: '240px', height: 'auto' })
            }}
        >
            <div 
                className="h-8 bg-dark-card-secondary flex items-center justify-between px-2 cursor-grab"
                onMouseDown={onMouseDown}
            >
                <div className="flex items-center gap-2 text-xs text-dark-text-muted">
                    <PictureInPictureIcon />
                    <span>Audience Projector</span>
                </div>
                <div className="flex items-center gap-1">
                    <button onClick={toggleTheme} className="p-1 rounded-full hover:bg-dark-border text-dark-text-muted hover:text-dark-text" title="Toggle Theme">
                        {isDarkTheme ? <SunIcon className="h-4 w-4" /> : <MoonIcon className="h-4 w-4" />}
                    </button>
                    <button onClick={toggleMinimize} className="p-1 rounded-full hover:bg-dark-border text-dark-text-muted hover:text-dark-text" title={isMinimized ? 'Restore' : 'Minimize'}>
                        {isMinimized ? <RestoreIcon /> : <MinimizeIcon />}
                    </button>
                    <button onClick={onClose} className="p-1 rounded-full hover:bg-dark-border text-dark-text-muted hover:text-dark-text" title="Close">
                         <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>
            {!isMinimized && (
                <div className="w-full h-[calc(100%-2rem)]">
                     <AudienceView
                        config={config}
                        matchId={matchId}
                        onExit={onClose} 
                        theme={theme}
                        isPreview={true} // Set to true to hide internal controls
                    />
                </div>
            )}
        </div>
    );
};

export default MiniAudienceWindow;
--- END FILE: components\MiniAudienceWindow.tsx ---

--- START FILE: components\MostDecisiveVictoryModal.tsx ---
import React, { useState, useMemo } from 'react';
import type { Match } from '../types';
import { Sport } from '../types';
import SportIcon from './SportIcon';
import TrophyIcon from './icons/TrophyIcon';
import TrendingUpIcon from './icons/TrendingUpIcon';

const getDateFromId = (id: string): string => {
    try {
        const timestamp = parseInt(id.split('-')[1], 10);
        if (isNaN(timestamp)) return 'Unknown Date';
        return new Date(timestamp).toLocaleDateString(undefined, {
            year: 'numeric', month: 'short', day: 'numeric'
        });
    } catch (e) {
        return 'Unknown Date';
    }
};

interface SportRecordCardProps {
    sport: Sport;
    record: { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; diff: number };
    index: number;
}

const sportColorClasses: Record<Sport, { bg: string; text: string; }> = {
    [Sport.Basketball]: { bg: 'bg-orange-500/10', text: 'text-orange-500' },
    [Sport.Soccer]: { bg: 'bg-green-500/10', text: 'text-green-500' },
    [Sport.Volleyball]: { bg: 'bg-sky-500/10', text: 'text-sky-500' },
};


const SportRecordCard: React.FC<SportRecordCardProps> = ({ sport, record, index }) => {
    const { match, diff } = record;
    const colorClass = sportColorClasses[sport];

    const setScores = useMemo(() => {
        if (sport !== Sport.Volleyball || !match?.periodScores) {
            return null;
        }
        return match.periodScores.reduce((acc, score) => {
            if (score.a > score.b) {
                acc.a++;
            } else if (score.b > score.a) {
                acc.b++;
            }
            return acc;
        }, { a: 0, b: 0 });
    }, [sport, match]);

    if (!match) {
        return (
            <div className={`bg-light-card-secondary dark:bg-dark-card-secondary p-5 rounded-lg flex flex-col items-center justify-center text-center animate-slide-in-bottom h-full`} style={{ animationDelay: `${index * 100}ms` }}>
                <div className={`p-3 rounded-full mb-3 ${colorClass.bg}`}>
                    <SportIcon sport={sport} className={`h-8 w-8 ${colorClass.text}`} />
                </div>
                <h3 className={`font-bold text-xl ${colorClass.text}`}>{sport}</h3>
                <p className="text-light-text-muted dark:text-dark-text-muted mt-2">No games played yet.</p>
            </div>
        );
    }
    
    const isAWinner = match.finalScoreA > match.finalScoreB;
    const winner = isAWinner ? match.teamA : match.teamB;

    return (
        <div className={`bg-light-card-secondary dark:bg-dark-card-secondary p-5 rounded-lg flex flex-col animate-slide-in-bottom h-full`} style={{ animationDelay: `${index * 100}ms` }}>
            <div className={`flex items-center gap-3 mb-4 pb-4 border-b border-light-border dark:border-dark-border ${colorClass.text}`}>
                <SportIcon sport={sport} className="h-7 w-7" />
                <h3 className="font-bold text-xl">{sport}</h3>
            </div>

            <div className="text-sm text-light-text-muted dark:text-dark-text-muted mb-3 flex justify-between items-center">
                <span>{getDateFromId(match.id)}</span>
                <span className="flex items-center gap-1 font-semibold">
                    <TrendingUpIcon />
                    +{diff} Point Victory
                </span>
            </div>
            
            <div className="grid grid-cols-[1fr_auto_1fr] items-center gap-2 text-center mb-4">
                <span className="text-lg font-bold truncate" style={{ color: match.teamA.color }}>{match.teamA.name}</span>
                <span className="text-lg font-mono text-light-text-muted dark:text-dark-text-muted">vs</span>
                <span className="text-lg font-bold truncate" style={{ color: match.teamB.color }}>{match.teamB.name}</span>
            </div>

            <div className={`text-center font-mono font-bold text-3xl ${setScores ? 'mb-2' : 'mb-4'}`}>
                {match.finalScoreA} - {match.finalScoreB}
            </div>

            {setScores && (
                <div className="text-center text-sm font-semibold text-light-text-muted dark:text-dark-text-muted mb-4">
                    Set Score: {setScores.a} - {setScores.b}
                </div>
            )}

            <div className="mt-auto pt-4 border-t border-light-border dark:border-dark-border text-center font-semibold text-sm">
                <div className="flex items-center justify-center gap-2 text-yellow-500">
                    <TrophyIcon className="h-5 w-5" />
                    <span>Winner: {winner?.name}</span>
                </div>
            </div>
        </div>
    );
};


interface MostDecisiveVictoryModalProps {
    mostDecisiveVictoriesBySportTime: Record<Sport, { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; diff: number }>;
    mostDecisiveVictoriesBySportScore: Record<Sport, { match: (Match & { finalScoreA: number, finalScoreB: number }) | null; diff: number }>;
    onClose: () => void;
}

const MostDecisiveVictoryModal: React.FC<MostDecisiveVictoryModalProps> = ({ mostDecisiveVictoriesBySportTime, mostDecisiveVictoriesBySportScore, onClose }) => {
    const [activeMode, setActiveMode] = useState<'time' | 'score'>('time');

    const dataToDisplay = activeMode === 'time' ? mostDecisiveVictoriesBySportTime : mostDecisiveVictoriesBySportScore;
    const sports = Object.keys(dataToDisplay) as Sport[];
    
    const segmentedButtonClasses = (isActive: boolean) => 
      `w-full px-4 py-2 text-sm font-semibold rounded-md focus:outline-none ${
        isActive ? 'bg-brand-blue text-white' : 'bg-light-card hover:bg-light-border dark:bg-dark-card dark:hover:bg-dark-border'
      }`;

    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-fade-in" 
            onClick={onClose}
            role="dialog"
            aria-modal="true"
            aria-labelledby="decisive-victory-title"
        >
            <div 
                className="bg-light-background dark:bg-dark-card rounded-2xl w-full max-w-5xl max-h-[90vh] flex flex-col p-6 md:p-8 shadow-2xl relative animate-modal-scale-in" 
                onClick={e => e.stopPropagation()}
            >
                <button 
                    onClick={onClose} 
                    className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                    aria-label="Close decisive victory breakdown"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>

                <div className="flex-shrink-0 pb-4 mb-4 border-b border-light-border dark:border-dark-border">
                    <h2 id="decisive-victory-title" className="text-3xl font-bold font-display text-center">
                        Most Decisive Victories by Sport
                    </h2>
                     <div className="mt-4 max-w-xs mx-auto p-1 rounded-lg flex space-x-1 bg-light-card-secondary dark:bg-dark-card-secondary">
                        <button onClick={() => setActiveMode('time')} className={segmentedButtonClasses(activeMode === 'time')}>Time-based</button>
                        <button onClick={() => setActiveMode('score')} className={segmentedButtonClasses(activeMode === 'score')}>Score-based</button>
                    </div>
                </div>
                
                <div className="flex-grow overflow-y-auto pr-2 -mr-4">
                     <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        {sports.map((sport, index) => (
                           <SportRecordCard
                                key={sport}
                                sport={sport}
                                record={dataToDisplay[sport]}
                                index={index}
                           />
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MostDecisiveVictoryModal;
--- END FILE: components\MostDecisiveVictoryModal.tsx ---

--- START FILE: components\MostPlayedSportModal.tsx ---
import React from 'react';
import { Sport } from '../types';
import SportIcon from './SportIcon';

interface MostPlayedSportModalProps {
    onClose: () => void;
    matchesBySport: Record<Sport, number>;
}

const sportColorMap: Record<Sport, string> = {
    [Sport.Basketball]: '#F97316', // orange-500
    [Sport.Soccer]: '#10B981', // emerald-500
    [Sport.Volleyball]: '#0EA5E9', // sky-500
};

const SportPopularityItem: React.FC<{ sport: Sport; count: number; total: number; index: number }> = ({ sport, count, total, index }) => {
    const percentage = total > 0 ? (count / total) * 100 : 0;
    
    return (
        <div 
            className="bg-light-card-secondary dark:bg-dark-card-secondary p-4 rounded-lg animate-slide-in-bottom"
            style={{ animationDelay: `${index * 75}ms` }}
        >
            <div className="flex items-center justify-between mb-2">
{/* FIX: The SportIcon component does not accept a style prop. The style is applied to a wrapper div instead. */}
                <div className="flex items-center gap-3" style={{ color: sportColorMap[sport]}}>
                    <SportIcon sport={sport} className="h-6 w-6" />
                    <span className="font-bold text-lg">{sport}</span>
                </div>
                <span className="font-mono font-bold text-xl">{count}</span>
            </div>
            <div className="w-full bg-light-border dark:bg-dark-border rounded-full h-3 overflow-hidden">
                <div 
                    className="h-full rounded-full animate-chart-bar"
                    style={{ 
                        width: `${percentage}%`, 
                        backgroundColor: sportColorMap[sport],
                        animationDelay: `${index * 75 + 100}ms`
                    }}
                />
            </div>
        </div>
    );
};


const MostPlayedSportModal: React.FC<MostPlayedSportModalProps> = ({ onClose, matchesBySport }) => {
    const totalMatches = Object.values(matchesBySport).reduce((sum: number, count: number) => sum + count, 0);

    const sortedSports = (Object.entries(matchesBySport) as [Sport, number][])
        .sort(([, countA], [, countB]) => countB - countA);

    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-fade-in" 
            onClick={onClose}
            role="dialog"
            aria-modal="true"
            aria-labelledby="most-played-sport-title"
        >
            <div 
                className="bg-light-background dark:bg-dark-card rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col p-6 md:p-8 shadow-2xl relative animate-modal-scale-in" 
                onClick={e => e.stopPropagation()}
            >
                <button 
                    onClick={onClose} 
                    className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                    aria-label="Close sport breakdown"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>

                <div className="flex-shrink-0 pb-4 border-b border-light-border dark:border-dark-border">
                    <h2 id="most-played-sport-title" className="text-3xl font-bold font-display text-center">
                        Sport Popularity Breakdown
                    </h2>
                    <p className="text-center text-light-text-muted dark:text-dark-text-muted font-semibold">{totalMatches} Total Matches</p>
                </div>
                
                <div className="flex-grow overflow-y-auto mt-4 pr-2 -mr-4">
                     <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        {sortedSports.map(([sport, count], index) => (
                           <SportPopularityItem
                                key={sport}
                                sport={sport}
                                count={count}
                                total={totalMatches}
                                index={index}
                           />
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MostPlayedSportModal;
--- END FILE: components\MostPlayedSportModal.tsx ---

--- START FILE: components\Scoreboard.tsx ---
import React from 'react';
import type { MatchConfig, GameState } from '../types';
import { Sport, GameStatus } from '../types';

interface ScoreboardProps {
    config: MatchConfig;
    state: GameState;
    time: number;
    isFullScreen: boolean;
}

const formatTime = (totalSeconds: number) => {
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
};

const TeamScore: React.FC<{ name: string; score: number; color: string; isFinished: boolean }> = ({ name, score, color, isFinished }) => {
    return (
        <div className={`flex flex-col items-center justify-center text-center p-4 rounded-lg relative transition-all duration-300`} style={{ backgroundColor: color }}>
            <h2 
              className="font-display font-bold uppercase text-shadow-heavy text-white tracking-wider truncate w-full"
              style={{ fontSize: 'clamp(1.25rem, 2.5vw, 3.5rem)' }}
            >
              {name}
            </h2>
            <p 
              className="font-display font-bold text-shadow-heavy text-white leading-none"
              style={{ fontSize: 'clamp(4rem, 10vw, 15rem)' }}
            >
              {score}
            </p>
        </div>
    );
};

const VolleyballTeamScore: React.FC<{ name: string; setScore: number; pointScore: number; color: string; }> = ({ name, setScore, pointScore, color }) => (
    <div className={`flex flex-col items-center justify-between text-center p-4 rounded-lg relative transition-all duration-300 h-full`} style={{ backgroundColor: color }}>
        <h2 className="font-display font-bold uppercase text-shadow-heavy text-white tracking-wider truncate w-full" style={{ fontSize: 'clamp(1.25rem, 2.5vw, 3.5rem)' }}>
            {name}
        </h2>
        <p className="font-display font-bold text-shadow-heavy text-white leading-none" style={{ fontSize: 'clamp(4rem, 10vw, 15rem)' }}>
            {setScore}
        </p>
        <div className="bg-black/30 backdrop-blur-sm rounded-md px-4 py-1">
            <h3 className="text-sm font-semibold text-white/80 uppercase">Points</h3>
            <p className="font-mono font-bold text-white text-4xl">{pointScore}</p>
        </div>
    </div>
);


const Scoreboard: React.FC<ScoreboardProps> = ({ config, state, time, isFullScreen }) => {
    const periodLabel = config.sport === Sport.Volleyball ? 'SET' : 'PERIOD';
    const gridClasses = isFullScreen
        ? 'grid grid-cols-1 grid-rows-3 md:grid-rows-1 md:grid-cols-[1fr_auto_1fr] gap-4 w-full h-full'
        : 'grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4 w-full';

    const isFinished = state.status === GameStatus.Finished;

    return (
        <div className={`${gridClasses} relative`}>
             {isFinished && <div className="final-badge">FINAL</div>}
             {state.pauseReason && (
                <div className="absolute inset-0 bg-black/70 flex items-center justify-center z-10">
                    <h1 className="text-7xl md:text-9xl font-display text-yellow-400 uppercase tracking-widest animate-pulse">
                        {state.pauseReason}
                    </h1>
                </div>
            )}

            {config.sport === Sport.Volleyball ? (
                <VolleyballTeamScore name={state.teamA.name} setScore={state.setScores?.a ?? 0} pointScore={state.teamA.score} color={state.teamA.color} />
            ) : (
                <TeamScore name={state.teamA.name} score={state.teamA.score} color={state.teamA.color} isFinished={isFinished} />
            )}


            <div className="flex flex-col items-center justify-center bg-light-text dark:bg-black p-4 rounded-lg text-white">
                {config.gameMode === 'score' ? (
                    <>
                        <div className="font-mono font-bold leading-none" style={{ fontSize: 'clamp(2.5rem, 5vw, 6rem)' }}>{config.targetScore}</div>
                        <div className="font-display font-semibold uppercase tracking-widest" style={{ fontSize: 'clamp(1rem, 1.5vw, 2.5rem)' }}>
                            Target Score
                        </div>
                        <div className="mt-2 px-4 py-1 rounded-md bg-blue-600/75 backdrop-blur-sm border border-white/20">
                            <p className="font-sans font-semibold uppercase tracking-widest text-sm text-white">
                                {config.sport}
                            </p>
                        </div>
                    </>
                ) : (
                    <>
                        <div className="font-mono font-bold leading-none" style={{ fontSize: 'clamp(2.5rem, 5vw, 6rem)' }}>{formatTime(time)}</div>
                        <div className={`font-display font-semibold uppercase tracking-widest ${isFinished ? 'opacity-70' : ''}`} style={{ fontSize: 'clamp(1rem, 2vw, 2.5rem)' }}>
                            {periodLabel} {state.currentPeriod}
                        </div>
                        <div className="mt-2 px-4 py-1 rounded-md bg-blue-600/75 backdrop-blur-sm border border-white/20">
                            <p className="font-sans font-semibold uppercase tracking-widest text-sm text-white">
                                {config.sport}
                            </p>
                        </div>
                    </>
                )}
            </div>

            {config.sport === Sport.Volleyball ? (
                <VolleyballTeamScore name={state.teamB.name} setScore={state.setScores?.b ?? 0} pointScore={state.teamB.score} color={state.teamB.color} />
            ) : (
                <TeamScore name={state.teamB.name} score={state.teamB.score} color={state.teamB.color} isFinished={isFinished} />
            )}
        </div>
    );
};

export default Scoreboard;
--- END FILE: components\Scoreboard.tsx ---

--- START FILE: components\settings\AccountSettings.tsx ---
--- END FILE: components\settings\AccountSettings.tsx ---

--- START FILE: components\settings\DataSettings.tsx ---
import React, { useRef } from 'react';
import DownloadIcon from '../icons/DownloadIcon';
import UploadIcon from '../icons/UploadIcon';
import TrashIcon from '../icons/TrashIcon';
import DocumentTextIcon from '../icons/DocumentTextIcon';

interface DataSettingsProps {
    onExport: () => void;
    onImport: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onClear: () => void;
    onExportPdf: () => void;
    isExportingPdf: boolean;
}

const Section: React.FC<{ title: string; children: React.ReactNode; }> = ({ title, children }) => (
    <div className="bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <div className="p-6">
            <h2 className="text-xl font-bold mb-4">{title}</h2>
            {children}
        </div>
    </div>
);

const DataSettings: React.FC<DataSettingsProps> = ({ onExport, onImport, onClear, onExportPdf, isExportingPdf }) => {
    const importInputRef = useRef<HTMLInputElement>(null);

    const handleImportClick = () => {
        importInputRef.current?.click();
    };

    return (
        <div className="space-y-8 max-w-2xl">
            <Section title="Backup & Restore">
                <div className="space-y-4">
                    <p className="text-light-text-muted dark:text-dark-text-muted text-sm">
                        Export all your matches, teams, and settings into a single file for backup or migration. Choose your preferred format.
                    </p>
                    <div className="flex flex-wrap gap-4">
                        <button
                            onClick={onExport}
                            className="flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded-lg"
                        >
                            <DownloadIcon />
                            Export as JSON
                        </button>
                        <button
                            onClick={onExportPdf}
                            disabled={isExportingPdf}
                            className="flex items-center justify-center gap-2 bg-green-600 hover:bg-green-500 disabled:bg-green-400 disabled:cursor-wait text-white font-bold py-2 px-4 rounded-lg"
                        >
                            <DocumentTextIcon />
                            {isExportingPdf ? 'Generating PDF...' : 'Export as PDF'}
                        </button>
                    </div>
                </div>
                 <div className="mt-8 space-y-4">
                    <p className="text-light-text-muted dark:text-dark-text-muted text-sm">
                        Import data from a previously exported backup file (.json). This will overwrite your current data.
                    </p>
                    <button
                        onClick={handleImportClick}
                        className="w-full sm:w-auto flex items-center justify-center gap-2 bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border font-bold py-2 px-4 rounded-lg"
                    >
                        <UploadIcon />
                        Import Data
                    </button>
                    <input
                        type="file"
                        ref={importInputRef}
                        onChange={onImport}
                        className="hidden"
                        accept=".json"
                    />
                </div>
            </Section>

            <div className="bg-light-card dark:bg-dark-card rounded-lg shadow-sm border border-brand-red/50">
                <div className="p-6">
                    <h2 className="text-xl font-bold text-brand-red">Danger Zone</h2>
                    <p className="text-light-text-muted dark:text-dark-text-muted text-sm mt-2 mb-4">
                        This action is irreversible. All your match history, saved teams, and settings will be permanently deleted.
                    </p>
                    <button
                        onClick={onClear}
                        className="flex items-center gap-2 bg-brand-red/20 hover:bg-brand-red/30 text-brand-red font-bold py-2 px-4 rounded-lg"
                    >
                        <TrashIcon />
                        Clear All Data
                    </button>
                </div>
            </div>
        </div>
    );
};

export default DataSettings;
--- END FILE: components\settings\DataSettings.tsx ---

--- START FILE: components\settings\GeneralSettings.tsx ---
import React from 'react';
import type { Settings, Theme } from '../../types';

interface GeneralSettingsProps {
    settings: Settings;
    updateSettings: (newSettings: Partial<Settings>) => void;
}

const Section: React.FC<{ title: string; children: React.ReactNode; }> = ({ title, children }) => (
    <div className="bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <div className="p-6">
            <h2 className="text-xl font-bold mb-4">{title}</h2>
            {children}
        </div>
    </div>
);

const GeneralSettings: React.FC<GeneralSettingsProps> = ({ settings, updateSettings }) => {
    
    const themes: { id: Theme, name: string }[] = [
        { id: 'light', name: 'Light' },
        { id: 'dark', name: 'Dark' },
        { id: 'coder', name: 'Coder' },
        { id: 'viola', name: 'Viola' },
    ];
    
    const segmentedButtonClasses = (isActive: boolean) => 
      `w-full px-4 py-3 text-sm font-semibold rounded-md focus:outline-none ${
        isActive ? 'bg-brand-blue text-white ring-2 ring-offset-2 ring-offset-light-card dark:ring-offset-dark-card ring-brand-blue' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'
      }`;
    
    return (
        <div className="space-y-8 max-w-2xl">
            <Section title="Appearance">
                 <div>
                    <label className="block text-sm font-medium mb-2">Theme</label>
                    <div className="grid grid-cols-2 gap-3">
                        {themes.map(theme => (
                            <button key={theme.id} onClick={() => updateSettings({ theme: theme.id })} className={segmentedButtonClasses(settings.theme === theme.id)}>
                                {theme.name}
                            </button>
                        ))}
                    </div>
                </div>
            </Section>
        </div>
    );
};

export default GeneralSettings;
--- END FILE: components\settings\GeneralSettings.tsx ---

--- START FILE: components\settings\PreferencesSettings.tsx ---
import React, { useState } from 'react';
import type { Settings, SportDefaultSettings } from '../../types';
import { Sport } from '../../types';
import ColorPicker from '../form/ColorPicker';

interface PreferencesSettingsProps {
    settings: Settings;
    updateSettings: (newSettings: Partial<Settings>) => void;
}

const Section: React.FC<{ title: string; children: React.ReactNode; }> = ({ title, children }) => (
    <div className="bg-light-card dark:bg-dark-card rounded-lg shadow-sm">
        <div className="p-6">
            <h2 className="text-xl font-bold mb-4">{title}</h2>
            {children}
        </div>
    </div>
);

const PreferencesSettings: React.FC<PreferencesSettingsProps> = ({ settings, updateSettings }) => {
    
    const [activeSportTab, setActiveSportTab] = useState<Sport>(Sport.Basketball);

    const handleSportDefaultChange = (sport: Sport, field: keyof SportDefaultSettings, value: string) => {
        const numericValue = parseInt(value) || 0;
        updateSettings({
            sportDefaults: {
                ...settings.sportDefaults,
                [sport]: {
                    ...settings.sportDefaults[sport],
                    [field]: numericValue,
                },
            },
        });
    };
    
    const labelClasses = 'block text-sm font-medium mb-2';
    const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";

    const sportTabButtonClasses = (s: Sport) => `px-4 py-2 text-sm font-semibold rounded-md flex-1 ${activeSportTab === s ? 'bg-light-card dark:bg-dark-card shadow-sm text-brand-blue' : 'text-light-text-muted dark:text-dark-text-muted hover:text-light-text dark:hover:text-dark-text'}`;

    const renderSportSettings = (sport: Sport) => {
        const defaults = settings.sportDefaults[sport];
        if (sport === Sport.Volleyball) {
            return (
                 <div className="space-y-4 animate-fade-in">
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                         <div>
                            <label htmlFor={`${sport}-periods`} className={labelClasses}>Default 'Best of Sets'</label>
                             <input
                                id={`${sport}-periods`}
                                type="number"
                                min="1"
                                step="2" // Best of is usually odd
                                value={defaults.periods}
                                onChange={e => handleSportDefaultChange(sport, 'periods', e.target.value)}
                                className={inputClasses}
                            />
                        </div>
                        <div>
                             <label htmlFor={`${sport}-targetScore`} className={labelClasses}>Default Points per Set</label>
                            <input
                                id={`${sport}-targetScore`}
                                type="number"
                                value={defaults.targetScore}
                                onChange={e => handleSportDefaultChange(sport, 'targetScore', e.target.value)}
                                className={inputClasses}
                            />
                        </div>
                     </div>
                     <p className="text-xs text-light-text-muted dark:text-dark-text-muted">These settings apply to both time-based and score-based volleyball matches.</p>
                 </div>
            );
        }
        
        // For Basketball and Soccer
        return (
            <div className="space-y-4 animate-fade-in">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label htmlFor={`${sport}-targetScore`} className={labelClasses}>Default Target Score</label>
                        <input
                            id={`${sport}-targetScore`}
                            type="number"
                            value={defaults.targetScore}
                            onChange={e => handleSportDefaultChange(sport, 'targetScore', e.target.value)}
                            className={inputClasses}
                        />
                         <p className="text-xs text-light-text-muted dark:text-dark-text-muted mt-1">For score-based games.</p>
                    </div>
                    <div>
                        <label htmlFor={`${sport}-periods`} className={labelClasses}>Default Periods</label>
                        <input
                            id={`${sport}-periods`}
                            type="number"
                            value={defaults.periods}
                            onChange={e => handleSportDefaultChange(sport, 'periods', e.target.value)}
                            className={inputClasses}
                        />
                    </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                     <div>
                        <label htmlFor={`${sport}-durationMinutes`} className={labelClasses}>Default Minutes</label>
                        <input
                            id={`${sport}-durationMinutes`}
                            type="number"
                            value={defaults.durationMinutes}
                            onChange={e => handleSportDefaultChange(sport, 'durationMinutes', e.target.value)}
                            className={inputClasses}
                        />
                    </div>
                    <div>
                        <label htmlFor={`${sport}-durationSeconds`} className={labelClasses}>Default Seconds</label>
                        <input
                            id={`${sport}-durationSeconds`}
                            type="number"
                            max="59"
                            value={defaults.durationSeconds}
                            onChange={e => handleSportDefaultChange(sport, 'durationSeconds', e.target.value)}
                            className={inputClasses}
                        />
                    </div>
                </div>
                <p className="text-xs text-light-text-muted dark:text-dark-text-muted">Duration settings apply to time-based games.</p>
            </div>
        );
    };

    return (
        <div className="space-y-8 max-w-3xl">
            <Section title="Game Rule Defaults">
                 <div className="mb-6 flex flex-wrap items-center gap-2 p-1.5 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg">
                    {Object.values(Sport).map(sport => (
                        <button key={sport} onClick={() => setActiveSportTab(sport)} className={sportTabButtonClasses(sport)}>
                            {sport}
                        </button>
                    ))}
                </div>
                {renderSportSettings(activeSportTab)}
            </Section>

            <Section title="Match Creation Defaults">
                <div className="space-y-6">
                    <div>
                        <label htmlFor="defaultSport" className={labelClasses}>Default Sport on Setup Screen</label>
                        <select
                            id="defaultSport"
                            value={settings.defaultSport}
                            onChange={e => updateSettings({ defaultSport: e.target.value as Sport })}
                            className={inputClasses}
                        >
                            {Object.values(Sport).map(s => <option key={s} value={s}>{s}</option>)}
                        </select>
                    </div>
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label className={labelClasses}>Default Team A Color</label>
                            <ColorPicker
                                selectedColor={settings.defaultTeamAColor}
                                onSelect={color => updateSettings({ defaultTeamAColor: color })}
                            />
                        </div>
                         <div>
                            <label className={labelClasses}>Default Team B Color</label>
                            <ColorPicker
                                selectedColor={settings.defaultTeamBColor}
                                onSelect={color => updateSettings({ defaultTeamBColor: color })}
                            />
                        </div>
                    </div>
                </div>
            </Section>
        </div>
    );
};

export default PreferencesSettings;
--- END FILE: components\settings\PreferencesSettings.tsx ---

--- START FILE: components\settings\ThemeSettings.tsx ---
import React from 'react';
import { Sport, type Settings, Font, Layout } from '../../types';
import AudienceView from '../AudienceView';
import ColorPicker from '../form/ColorPicker';

interface ThemeSettingsProps {
    settings: Settings;
    updateSettings: (newSettings: Partial<Settings>) => void;
}

const mockConfig = {
    sport: Sport.Soccer,
    teamA: { name: 'REAL MADRID', color: '#FEBE10' },
    teamB: { name: 'BARCELONA', color: '#A50044' },
    durationMinutes: 45,
    durationSeconds: 0,
    periods: 2,
};

const ThemeSettings: React.FC<ThemeSettingsProps> = ({ settings, updateSettings }) => {
    
    const labelClasses = 'block text-sm font-medium mb-2';
    const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";

    const segmentedButtonClasses = (isActive: boolean) => 
      `w-full px-4 py-2 text-sm font-semibold rounded-md focus:outline-none ${
        isActive ? 'bg-brand-blue text-white' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'
      }`;

    return (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            {/* Controls */}
            <div className="lg:col-span-1 space-y-6">
                 <div className="bg-light-card dark:bg-dark-card p-6 rounded-lg shadow-sm">
                    <h3 className="text-lg font-bold mb-4">Audience View Customization</h3>
                    <div className="space-y-4">
                        <div>
                            <label htmlFor="font" className={labelClasses}>Font Style</label>
                            <select id="font" value={settings.font} onChange={e => updateSettings({ font: e.target.value as Font })} className={inputClasses}>
                                <option value={Font.Display}>Display (Teko)</option>
                                <option value={Font.Mono}>Mono (Roboto Mono)</option>
                                <option value={Font.Sans}>Sans (Inter)</option>
                            </select>
                        </div>
                        <div>
                            <label className={labelClasses}>Layout Style</label>
                             <div className="p-1 rounded-lg flex space-x-1 bg-light-card-secondary dark:bg-dark-card-secondary">
                                <button onClick={() => updateSettings({ layout: Layout.Wide })} className={segmentedButtonClasses(settings.layout === Layout.Wide)}>Wide</button>
                                <button onClick={() => updateSettings({ layout: Layout.Compact })} className={segmentedButtonClasses(settings.layout === Layout.Compact)}>Compact</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {/* Preview */}
            <div className="lg:col-span-2">
                 <div className="sticky top-24">
                    <p className="text-center font-semibold mb-2 text-light-text-muted dark:text-dark-text-muted">Live Preview</p>
                    <div className="aspect-[16/9] w-full rounded-lg overflow-hidden shadow-lg bg-light-card-secondary dark:bg-dark-card-secondary">
                        <AudienceView
                            config={mockConfig}
                            matchId="preview"
                            onExit={() => {}}
                            theme={settings.theme}
                            font={settings.font}
                            layout={settings.layout}
                            isPreview={true}
                         />
                    </div>
                 </div>
            </div>
        </div>
    );
};

export default ThemeSettings;
--- END FILE: components\settings\ThemeSettings.tsx ---

--- START FILE: components\SettingsPage.tsx ---
import React, { useState } from 'react';
import type { Settings } from '../types';
import GeneralSettings from './settings/GeneralSettings';
import ThemeSettings from './settings/ThemeSettings';
import PreferencesSettings from './settings/PreferencesSettings';
import DataSettings from './settings/DataSettings';
import SettingsIcon from './icons/SettingsIcon';
import PaletteIcon from './icons/PaletteIcon';
import ClipboardListIcon from './icons/ClipboardListIcon';
import DatabaseIcon from './icons/DatabaseIcon';

interface SettingsPageProps {
    settings: Settings;
    updateSettings: (newSettings: Partial<Settings>) => void;
    onExportData: () => void;
    onImportData: (event: React.ChangeEvent<HTMLInputElement>) => void;
    onClearData: () => void;
    onExportPdf: () => void;
    isExportingPdf: boolean;
}

type SettingsTab = 'general' | 'defaults' | 'layout' | 'data';

const settingsTabs: { id: SettingsTab; label: string; icon: React.ReactNode }[] = [
    { id: 'general', label: 'General', icon: <SettingsIcon className="h-5 w-5" /> },
    { id: 'defaults', label: 'Match Defaults', icon: <ClipboardListIcon /> },
    { id: 'layout', label: 'Layout & Style', icon: <PaletteIcon /> },
    { id: 'data', label: 'Data Management', icon: <DatabaseIcon /> },
];

const SettingsPage: React.FC<SettingsPageProps> = (props) => {
    const [activeTab, setActiveTab] = useState<SettingsTab>('general');

    const renderContent = () => {
        switch (activeTab) {
            case 'general':
                return <GeneralSettings settings={props.settings} updateSettings={props.updateSettings} />;
            case 'defaults':
                return <PreferencesSettings settings={props.settings} updateSettings={props.updateSettings} />;
            case 'layout':
                return <ThemeSettings settings={props.settings} updateSettings={props.updateSettings} />;
            case 'data':
                return <DataSettings onExport={props.onExportData} onImport={props.onImportData} onClear={props.onClearData} onExportPdf={props.onExportPdf} isExportingPdf={props.isExportingPdf} />;
            default:
                return null;
        }
    };

    return (
        <div className="p-4 sm:p-6 md:p-8">
            <h1 className="text-4xl md:text-5xl font-bold font-display mb-8">Settings</h1>
            
            <div className="grid grid-cols-1 md:grid-cols-[240px_1fr] gap-8">
                {/* Sidebar */}
                <aside className="md:sticky md:top-24 h-full">
                    <nav className="flex flex-row md:flex-col gap-2">
                        {settingsTabs.map(tab => (
                            <button
                                key={tab.id}
                                onClick={() => setActiveTab(tab.id)}
                                className={`flex items-center gap-3 w-full p-3 text-left font-semibold rounded-lg transition-colors duration-200 ${
                                    activeTab === tab.id
                                        ? 'bg-brand-blue/10 text-brand-blue'
                                        : 'text-light-text-muted hover:bg-light-card-secondary dark:text-dark-text-muted dark:hover:bg-dark-card-secondary'
                                }`}
                            >
                                {tab.icon}
                                {tab.label}
                            </button>
                        ))}
                    </nav>
                </aside>
                
                {/* Content */}
                <div className="min-w-0">
                    {renderContent()}
                </div>
            </div>
        </div>
    );
};

export default SettingsPage;
--- END FILE: components\SettingsPage.tsx ---

--- START FILE: components\SetupScreen.tsx ---
import React, { useState, useCallback, useEffect, useRef } from 'react';
import type { MatchConfig, SavedTeam, Settings } from '../types';
import { Sport } from '../types';
import { TEAM_COLORS } from '../constants';
import TeamSelector from './TeamSelector';
import CreateEditTeamModal from './CreateEditTeamModal';

interface SetupScreenProps {
  onStartMatch: (config: MatchConfig) => void;
  onBack: () => void;
  savedTeams: SavedTeam[];
  onSaveTeam: (team: Omit<SavedTeam, 'id'> & { id?: string }) => SavedTeam | void;
  settings: Settings;
}

const SetupScreen: React.FC<SetupScreenProps> = ({ onStartMatch, onBack, savedTeams, onSaveTeam, settings }) => {
    const [sport, setSport] = useState<Sport>(settings.defaultSport);
    
    const [teamA, setTeamA] = useState<SavedTeam | {name: string, color: string}>({ name: 'HOME', color: settings.defaultTeamAColor });
    const [teamB, setTeamB] = useState<SavedTeam | {name: string, color: string}>({ name: 'AWAY', color: settings.defaultTeamBColor });
    
    const [durationMinutes, setDurationMinutes] = useState(0);
    const [durationSeconds, setDurationSeconds] = useState(0);
    const [periods, setPeriods] = useState(0);
    const [gameMode, setGameMode] = useState<'time' | 'score'>('time');
    const [targetScore, setTargetScore] = useState(0);

    const [isCreateTeamModalOpen, setIsCreateTeamModalOpen] = useState(false);
    const [creatingFor, setCreatingFor] = useState<'A' | 'B' | null>(null);
    
    useEffect(() => {
        const defaults = settings.sportDefaults[sport];
        setDurationMinutes(defaults.durationMinutes);
        setDurationSeconds(defaults.durationSeconds);
        setPeriods(defaults.periods);
        setTargetScore(defaults.targetScore);
    }, [sport, settings.sportDefaults]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onStartMatch({
            sport,
            teamA: { name: teamA.name, color: teamA.color },
            teamB: { name: teamB.name, color: teamB.color },
            durationMinutes,
            durationSeconds,
            periods,
            gameMode,
            targetScore: gameMode === 'score' ? targetScore : undefined,
        });
    };

    const handleOpenCreateModal = (teamIdentifier: 'A' | 'B') => {
        setCreatingFor(teamIdentifier);
        setIsCreateTeamModalOpen(true);
    };

    const handleSaveFromModal = (team: Omit<SavedTeam, 'id'> & { id?: string }) => {
        const newTeam = onSaveTeam(team);
        setIsCreateTeamModalOpen(false);

        if (newTeam && creatingFor) {
            if (creatingFor === 'A') {
                setTeamA(newTeam);
            } else {
                setTeamB(newTeam);
            }
            setCreatingFor(null);
        }
    };
    
    const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";
    const sportButtonClasses = (s: Sport) => `p-4 rounded-lg text-center font-bold ${sport === s ? 'bg-brand-blue text-white ring-2 ring-brand-blue' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'}`;
    const segmentedButtonClasses = (isActive: boolean) => 
      `w-full px-4 py-2 text-sm font-semibold rounded-md focus:outline-none ${
        isActive ? 'bg-brand-blue text-white' : 'bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border'
      }`;

    return (
        <div className="p-4 md:p-6 w-full">
            {isCreateTeamModalOpen && (
                <CreateEditTeamModal
                    onClose={() => setIsCreateTeamModalOpen(false)}
                    onSave={handleSaveFromModal}
                />
            )}
            <div className="w-full max-w-4xl mx-auto relative">
                <button onClick={onBack} className="absolute top-0 -left-2 md:-left-4 text-light-text-muted hover:text-light-text dark:text-dark-text-muted dark:hover:text-dark-text flex items-center gap-2 mb-4">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />
                    </svg>
                    Back to Dashboard
                </button>
                <h1 className="text-4xl md:text-5xl font-bold text-center mb-2 font-display pt-12">Project: Iskor-App</h1>
                <p className="text-center text-light-text-muted dark:text-dark-text-muted mb-8">Create a new match</p>

                <form onSubmit={handleSubmit} className="space-y-8">
                    {/* Sport Selection */}
                    <div>
                        <label className="block text-lg font-semibold mb-3">Sport</label>
                        <div className="grid grid-cols-3 gap-4 p-4 rounded-lg bg-light-card dark:bg-dark-card shadow-sm">
                            {Object.values(Sport).map(s => (
                                <button
                                    key={s}
                                    type="button"
                                    onClick={() => setSport(s)}
                                    className={sportButtonClasses(s)}
                                >
                                    {s}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Team Configuration */}
                    <div className="grid md:grid-cols-2 gap-8">
                        {/* Team A */}
                        <div className="space-y-4 bg-light-card dark:bg-dark-card p-6 rounded-lg shadow-sm">
                             <h2 className="text-2xl font-bold text-center">Team A</h2>
                             <TeamSelector
                                label="Select Team A"
                                teams={savedTeams.filter(t => 'id' in teamB ? t.id !== teamB.id : true)}
                                selectedTeam={teamA}
                                onSelectTeam={setTeamA}
                                defaultColor={settings.defaultTeamAColor}
                                onCreateNewTeamRequest={() => handleOpenCreateModal('A')}
                                matchSport={sport}
                             />
                        </div>

                        {/* Team B */}
                         <div className="space-y-4 bg-light-card dark:bg-dark-card p-6 rounded-lg shadow-sm">
                             <h2 className="text-2xl font-bold text-center">Team B</h2>
                             <TeamSelector
                                label="Select Team B"
                                teams={savedTeams.filter(t => 'id' in teamA ? t.id !== teamA.id : true)}
                                selectedTeam={teamB}
                                onSelectTeam={setTeamB}
                                defaultColor={settings.defaultTeamBColor}
                                onCreateNewTeamRequest={() => handleOpenCreateModal('B')}
                                matchSport={sport}
                             />
                        </div>
                    </div>
                    
                     {/* Game Settings */}
                    <div className="bg-light-card dark:bg-dark-card p-6 rounded-lg shadow-sm">
                        <h2 className="text-2xl font-bold text-center mb-6">Game Settings</h2>
                        
                        <div className="max-w-md mx-auto mb-6">
                           <label className="block text-sm font-medium mb-2 text-center">Game Mode</label>
                           <div className="p-1 rounded-lg flex space-x-1 bg-light-card-secondary dark:bg-dark-card-secondary">
                                <button type="button" onClick={() => setGameMode('time')} className={segmentedButtonClasses(gameMode === 'time')}>Time Based</button>
                                <button type="button" onClick={() => setGameMode('score')} className={segmentedButtonClasses(gameMode === 'score')}>Score Based</button>
                            </div>
                        </div>

                        {gameMode === 'time' ? (
                            <div className={`grid grid-cols-1 ${sport === Sport.Volleyball ? 'md:grid-cols-1' : 'md:grid-cols-3'} gap-4`}>
                                <div className={sport === Sport.Volleyball ? 'w-1/2 mx-auto' : ''}>
                                    <label htmlFor="periods" className="block text-sm font-medium mb-1">{sport === Sport.Volleyball ? 'Best of Sets' : 'Periods'}</label>
                                    <input id="periods" type="number" min="1" value={periods} onChange={e => setPeriods(parseInt(e.target.value))} className={inputClasses} />
                                </div>
                                {sport !== Sport.Volleyball && (
                                    <>
                                        <div>
                                            <label htmlFor="durationMinutes" className="block text-sm font-medium mb-1">Minutes</label>
                                            <input id="durationMinutes" type="number" min="0" value={durationMinutes} onChange={e => setDurationMinutes(parseInt(e.target.value))} className={inputClasses} />
                                        </div>
                                         <div>
                                            <label htmlFor="durationSeconds" className="block text-sm font-medium mb-1">Seconds</label>
                                            <input id="durationSeconds" type="number" min="0" max="59" value={durationSeconds} onChange={e => setDurationSeconds(parseInt(e.target.value))} className={inputClasses} />
                                        </div>
                                    </>
                                )}
                            </div>
                        ) : (
                             <div className="w-1/2 mx-auto">
                                <label htmlFor="targetScore" className="block text-sm font-medium mb-1">Target Score</label>
                                <input id="targetScore" type="number" min="1" value={targetScore} onChange={e => setTargetScore(parseInt(e.target.value))} className={inputClasses} />
                            </div>
                        )}
                    </div>


                    {/* Start Button */}
                    <button type="submit" className="w-full bg-brand-blue hover:bg-opacity-90 text-white font-bold py-4 px-4 rounded-lg text-xl transition-transform duration-200 transform hover:scale-105">
                        Start Match
                    </button>
                </form>
            </div>
        </div>
    );
};

export default SetupScreen;
--- END FILE: components\SetupScreen.tsx ---

--- START FILE: components\SportIcon.tsx ---
import React from 'react';
import { Sport } from '../types';
import BasketballIcon from './icons/BasketballIcon';
import SoccerIcon from './icons/SoccerIcon';
import VolleyballIcon from './icons/VolleyballIcon';

const SportIcon: React.FC<{ sport: Sport, className?: string }> = ({ sport, className }) => {
    switch (sport) {
        case Sport.Basketball: return <BasketballIcon className={className} />;
        case Sport.Soccer: return <SoccerIcon className={className} />;
        case Sport.Volleyball: return <VolleyballIcon className={className} />;
        default: return null;
    }
};

export default SportIcon;
--- END FILE: components\SportIcon.tsx ---

--- START FILE: components\TeamDetailModal.tsx ---

import React, { useMemo } from 'react';
import type { Match, TeamStat } from '../types';

interface TeamDetailModalProps {
    team: TeamStat;
    matches: Match[];
    onClose: () => void;
}

const ResultLozenge: React.FC<{ didWin: boolean }> = ({ didWin }) => (
    <span className={`px-2 py-0.5 text-xs font-bold rounded-full ${didWin ? 'bg-green-500/20 text-green-400' : 'bg-brand-red/20 text-brand-red'}`}>
        {didWin ? 'WIN' : 'LOSS'}
    </span>
);

const TeamDetailModal: React.FC<TeamDetailModalProps> = ({ team, matches, onClose }) => {
    const teamMatches = useMemo(() => 
        matches
            .filter(m => m.teamA.name === team.teamConfig.name || m.teamB.name === team.teamConfig.name)
            .sort((a, b) => parseInt(b.id.split('-')[1]) - parseInt(a.id.split('-')[1])), 
        [matches, team.teamConfig.name]
    );

    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-modal-scale-in" 
            onClick={onClose}
            role="dialog"
            aria-modal="true"
            aria-labelledby="team-details-title"
        >
            <div 
                className="bg-light-background dark:bg-dark-background rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col p-6 md:p-8 shadow-2xl relative" 
                onClick={e => e.stopPropagation()}
            >
                <button 
                    onClick={onClose} 
                    className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                    aria-label="Close team details"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
                
                {/* Header */}
                <div className="flex-shrink-0 pb-4 border-b border-light-border dark:border-dark-border">
                    <h2 id="team-details-title" className="text-3xl font-bold font-display" style={{ color: team.teamConfig.color }}>
                        {team.teamConfig.name}
                    </h2>
                    <div className="flex items-center gap-4 mt-2 text-light-text-muted dark:text-dark-text-muted">
                        <span className="font-semibold">Record: <span className="text-green-500">{team.wins}</span> - <span className="text-brand-red">{team.losses}</span></span>
                        <span>|</span>
                        <span>Total Games: {team.totalGames}</span>
                    </div>
                </div>

                {/* Match History */}
                <div className="flex-grow overflow-y-auto mt-4 pr-2 -mr-2">
                    <h3 className="font-bold mb-4 text-lg">Match History</h3>
                    <ul className="space-y-3">
                        {teamMatches.map(match => {
                            const isTeamA = match.teamA.name === team.teamConfig.name;
                            const ownScore = isTeamA ? match.finalScoreA : match.finalScoreB;
                            const opponent = isTeamA ? match.teamB : match.teamA;
                            const opponentScore = isTeamA ? match.finalScoreB : match.finalScoreA;
                            const didWin = (ownScore ?? 0) > (opponentScore ?? 0);

                            return (
                                <li key={match.id} className="flex justify-between items-center p-3 rounded-lg bg-light-card-secondary dark:bg-dark-card-secondary">
                                    <div>
                                        <p className="font-semibold">
                                            vs <span style={{ color: opponent.color }}>{opponent.name}</span>
                                        </p>
                                        <p className="text-sm text-light-text-muted dark:text-dark-text-muted">{match.sport}</p>
                                    </div>
                                    <div className="flex items-center gap-4">
                                        <span className="font-mono font-bold text-lg">{ownScore} - {opponentScore}</span>
                                        <ResultLozenge didWin={didWin} />
                                    </div>
                                </li>
                            );
                        })}
                    </ul>
                </div>
            </div>
        </div>
    );
};

export default TeamDetailModal;
--- END FILE: components\TeamDetailModal.tsx ---

--- START FILE: components\TeamSelector.tsx ---
import React, { useState, useEffect, useMemo } from 'react';
import type { SavedTeam } from '../types';
import { Sport } from '../types';
import ColorPicker from './form/ColorPicker';
import PlusIcon from './icons/PlusIcon';

interface TeamSelectorProps {
    label: string;
    teams: SavedTeam[];
    selectedTeam: SavedTeam | { name: string, color: string };
    onSelectTeam: (team: SavedTeam | { name: string, color: string }) => void;
    defaultColor: string;
    onCreateNewTeamRequest: () => void;
    matchSport: Sport;
}

const TeamSelector: React.FC<TeamSelectorProps> = ({ label, teams, selectedTeam, onSelectTeam, defaultColor, onCreateNewTeamRequest, matchSport }) => {
    const isCustom = !('id' in selectedTeam);

    const filteredTeams = useMemo(() => {
        return teams.filter(team => !team.sport || team.sport === 'Universal' || team.sport === matchSport);
    }, [teams, matchSport]);

    const handleSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const value = e.target.value;
        if (value === 'custom') {
            onSelectTeam({ name: '', color: selectedTeam.color || defaultColor });
        } else {
            const team = teams.find(t => t.id === value);
            if (team) {
                onSelectTeam(team);
            }
        }
    };
    
    const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        onSelectTeam({ ...selectedTeam, name: e.target.value });
    };

    const handleColorChange = (color: string) => {
        onSelectTeam({ ...selectedTeam, color: color });
    };

    const inputClasses = "w-full bg-light-card-secondary border-light-border dark:bg-dark-card-secondary dark:border-dark-border p-2 rounded-md border focus:ring-2 focus:ring-brand-blue focus:border-brand-blue outline-none";

    return (
        <div className="space-y-4">
            <div>
                <label className="block text-sm font-medium mb-1">{label}</label>
                <select 
                    value={'id' in selectedTeam ? selectedTeam.id : 'custom'} 
                    onChange={handleSelectChange} 
                    className={inputClasses}
                >
                    <option value="custom">-- Custom Team --</option>
                    {filteredTeams.map(team => (
                        <option key={team.id} value={team.id}>
                            {team.name}
                        </option>
                    ))}
                </select>
            </div>

            <button
                type="button"
                onClick={onCreateNewTeamRequest}
                className="w-full text-sm font-semibold py-2 px-4 rounded-md bg-light-card-secondary hover:bg-light-border dark:bg-dark-card-secondary dark:hover:bg-dark-border flex items-center justify-center gap-2 text-brand-blue"
            >
                <PlusIcon className="h-5 w-5" />
                Make your Team and save it
            </button>
            
            {isCustom && (
                <>
                    <div>
                        <label htmlFor="customTeamName" className="block text-sm font-medium mb-1">Custom Name</label>
                        <input
                            id="customTeamName"
                            type="text"
                            value={selectedTeam.name}
                            onChange={handleNameChange}
                            className={inputClasses}
                            required
                            placeholder="Enter team name"
                        />
                    </div>
                     <div>
                        <label className="block text-sm font-medium mb-2">Color</label>
                        <ColorPicker selectedColor={selectedTeam.color} onSelect={handleColorChange} />
                    </div>
                </>
            )}

            {!isCustom && (
                 <div className="flex items-center gap-4 p-3 rounded-lg bg-light-card-secondary dark:bg-dark-card-secondary">
                    <div className="w-8 h-8 rounded-full" style={{backgroundColor: selectedTeam.color}}></div>
                    <span className="font-bold text-lg">{selectedTeam.name}</span>
                </div>
            )}
        </div>
    );
};

export default TeamSelector;
--- END FILE: components\TeamSelector.tsx ---

--- START FILE: components\TeamsPage.tsx ---
import React, { useState, useMemo } from 'react';
import type { SavedTeam } from '../types';
import { Sport } from '../types';
import PlusIcon from './icons/PlusIcon';
import CreateEditTeamModal from './CreateEditTeamModal';
import UsersIcon from './icons/UsersIcon';
import EditIcon from './icons/EditIcon';
import TrashIcon from './icons/TrashIcon';
import SportIcon from './SportIcon';
import SearchIcon from './icons/SearchIcon';
import DeleteConfirmationModal from './DeleteConfirmationModal';

interface TeamsPageProps {
    savedTeams: SavedTeam[];
    onSaveTeam: (team: Omit<SavedTeam, 'id'> & { id?: string }) => void;
    onDeleteTeam: (teamId: string) => void;
    searchQuery: string;
}

const TeamCard: React.FC<{ team: SavedTeam, onEdit: () => void, onDelete: () => void, index: number, isDeleting: boolean }> = ({ team, onEdit, onDelete, index, isDeleting }) => {
    return (
        <div
            className={`
                group relative bg-light-card dark:bg-dark-card rounded-xl shadow-lg
                overflow-hidden transition-all duration-300 ease-in-out
                hover:shadow-2xl hover:-translate-y-2
                min-h-[120px]
                ${isDeleting ? 'animate-shrink-and-fade' : 'animate-slide-in-bottom'}
            `}
            style={{ 
                '--team-color': team.color, 
                '--team-glow-color': `${team.color}55`,
                animationDelay: `${index * 75}ms`,
                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
            } as React.CSSProperties}
        >
            <div 
                className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300" 
                style={{ 
                    background: `radial-gradient(circle at 90% 10%, var(--team-glow-color), transparent 60%)`,
                    boxShadow: `0 8px 30px -5px var(--team-glow-color)`
                }}>
            </div>

            <div className="absolute top-0 left-0 h-full w-2.5" style={{ backgroundColor: 'var(--team-color)' }}></div>
            
            <div className="relative p-6 flex items-center justify-between h-full">
                <div className="pl-4">
                    <div className="flex items-center gap-3">
                        <h3 className="text-4xl font-bold font-display uppercase tracking-wider truncate" style={{ color: 'var(--team-color)' }}>
                            {team.name}
                        </h3>
                        {team.sport && team.sport !== 'Universal' && (
                            <SportIcon sport={team.sport as Sport} className="h-7 w-7 opacity-70" />
                        )}
                    </div>
                    <p className="text-sm font-mono text-light-text-muted dark:text-dark-text-muted">{team.sport || 'Universal'}</p>
                </div>
                <div className="flex items-center gap-3 opacity-0 group-hover:opacity-100 transition-all duration-300 transform group-hover:translate-x-0 translate-x-4">
                    <button 
                        onClick={onEdit} 
                        className="p-3 bg-light-card-secondary/50 dark:bg-dark-card/50 hover:bg-light-border dark:hover:bg-dark-border rounded-lg text-light-text-muted dark:text-dark-text-muted hover:text-light-text dark:hover:text-dark-text"
                        title="Edit Team"
                    >
                        <EditIcon className="h-6 w-6"/>
                    </button>
                    <button 
                        onClick={onDelete} 
                        className="p-3 border border-brand-red/50 text-brand-red hover:bg-brand-red hover:text-white rounded-lg transition-colors"
                        title="Delete Team"
                    >
                        <TrashIcon />
                    </button>
                </div>
            </div>
        </div>
    );
};

const TeamsPage: React.FC<TeamsPageProps> = ({ savedTeams, onSaveTeam, onDeleteTeam, searchQuery }) => {
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [teamToEdit, setTeamToEdit] = useState<SavedTeam | null>(null);
    const [teamToDelete, setTeamToDelete] = useState<SavedTeam | null>(null);
    const [deletingTeamId, setDeletingTeamId] = useState<string | null>(null);

    const handleOpenCreateModal = () => {
        setTeamToEdit(null);
        setIsModalOpen(true);
    };

    const handleOpenEditModal = (team: SavedTeam) => {
        setTeamToEdit(team);
        setIsModalOpen(true);
    };

    const handleSave = (team: Omit<SavedTeam, 'id'> & { id?: string }) => {
        onSaveTeam(team);
        setIsModalOpen(false);
    };
    
    const handleConfirmDelete = () => {
        if (!teamToDelete) return;
        setDeletingTeamId(teamToDelete.id);
        setTeamToDelete(null); // Close modal

        setTimeout(() => {
            onDeleteTeam(teamToDelete.id);
            setDeletingTeamId(null);
        }, 500); // Animation duration
    };

    const filteredTeams = useMemo(() => {
        if (!searchQuery) {
            return savedTeams;
        }
        return savedTeams.filter(team =>
            team.name.toLowerCase().includes(searchQuery.toLowerCase())
        );
    }, [savedTeams, searchQuery]);

    return (
        <div className="p-4 sm:p-6 md:p-8">
            {isModalOpen && (
                <CreateEditTeamModal
                    onClose={() => setIsModalOpen(false)}
                    onSave={handleSave}
                    initialData={teamToEdit}
                />
            )}
            {teamToDelete && (
                <DeleteConfirmationModal
                    itemName={teamToDelete.name}
                    itemType="team"
                    onCancel={() => setTeamToDelete(null)}
                    onConfirm={handleConfirmDelete}
                />
            )}


            <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4 mb-8">
                <h1 className="text-4xl md:text-5xl font-bold font-display">Manage Teams</h1>
                <button
                    onClick={handleOpenCreateModal}
                    className="flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-3 px-5 rounded-lg text-lg transition-transform duration-200 transform hover:scale-105"
                >
                    <PlusIcon />
                    Create New Team
                </button>
            </div>
            
            {savedTeams.length > 0 ? (
                filteredTeams.length > 0 ? (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                        {filteredTeams.map((team, index) => (
                            <TeamCard 
                                key={team.id} 
                                team={team}
                                onEdit={() => handleOpenEditModal(team)}
                                onDelete={() => setTeamToDelete(team)}
                                index={index}
                                isDeleting={deletingTeamId === team.id}
                            />
                        ))}
                    </div>
                ) : (
                    <div className="text-center bg-light-card dark:bg-dark-card p-12 rounded-xl techy-bg border-2 border-dashed border-light-border dark:border-dark-border mt-8">
                         <h2 className="text-2xl font-bold">No Teams Found</h2>
                         <p className="text-light-text-muted dark:text-dark-text-muted mt-2">
                            No teams match your search for "{searchQuery}".
                         </p>
                    </div>
                )
            ) : (
                <div className="text-center bg-light-card dark:bg-dark-card p-12 rounded-xl techy-bg border-2 border-dashed border-light-border dark:border-dark-border mt-8">
                    <UsersIcon className="h-24 w-24 mx-auto text-brand-blue/50 mb-6" />
                    <h2 className="text-4xl font-bold font-display">Your Roster is Empty</h2>
                    <p className="text-light-text-muted dark:text-dark-text-muted mt-4 mb-8 max-w-md mx-auto">
                        Create your first team to start building your league. Saved teams make creating new matches faster and more consistent.
                    </p>
                     <button
                        onClick={handleOpenCreateModal}
                        className="flex items-center justify-center gap-2 bg-brand-blue hover:bg-opacity-90 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform duration-200 transform hover:scale-105 mx-auto"
                    >
                        <PlusIcon />
                        Create Your First Team
                    </button>
                </div>
            )}
        </div>
    );
};

export default TeamsPage;
--- END FILE: components\TeamsPage.tsx ---

--- START FILE: components\TotalMatchesModal.tsx ---
import React from 'react';
import type { Match } from '../types';
import SportIcon from './SportIcon';
import TrophyIcon from './icons/TrophyIcon';
import { getDateFromId } from '../utils';

const MatchInfoCard: React.FC<{ match: Match & { finalScoreA: number, finalScoreB: number }; index: number }> = ({ match, index }) => {
    const isTie = match.finalScoreA === match.finalScoreB;
    const isAWinner = match.finalScoreA > match.finalScoreB;
    const isBWinner = match.finalScoreB > match.finalScoreA;

    const winner = isAWinner ? match.teamA : (isBWinner ? match.teamB : null);

    return (
        <div 
            className="bg-light-card-secondary dark:bg-dark-card-secondary p-4 rounded-lg animate-slide-in-bottom"
            style={{ animationDelay: `${index * 50}ms` }}
        >
            <div className="flex items-center gap-4">
                <div className="flex flex-col items-center justify-center w-20 text-center text-light-text-muted dark:text-dark-text-muted">
                    <SportIcon sport={match.sport} className="h-7 w-7" />
                    <div className="mt-1">
                        <span className="text-xs font-semibold block">{match.sport}</span>
                        <span className="text-xs font-mono">{getDateFromId(match.id, { year: 'numeric', month: 'short', day: 'numeric' })}</span>
                    </div>
                </div>
                <div className="flex-1 grid grid-cols-[1fr_auto_1fr] items-center gap-x-2 sm:gap-x-4">
                    <div className={`flex items-center justify-end gap-3 text-right ${isAWinner ? 'font-bold' : ''}`}>
                        <span className="text-base sm:text-lg truncate" style={{ color: match.teamA.color }}>{match.teamA.name}</span>
                        {isAWinner && <TrophyIcon className="h-5 w-5 text-yellow-400 order-first sm:order-last" />}
                    </div>

                    <div className="flex items-center gap-2 sm:gap-3 font-mono text-xl sm:text-2xl">
                        <span className={`px-2 py-1 rounded-md ${isAWinner ? 'bg-light-card dark:bg-dark-card shadow-sm' : ''}`}>{match.finalScoreA}</span>
                        <span>-</span>
                        <span className={`px-2 py-1 rounded-md ${isBWinner ? 'bg-light-card dark:bg-dark-card shadow-sm' : ''}`}>{match.finalScoreB}</span>
                    </div>

                    <div className={`flex items-center justify-start gap-3 text-left ${isBWinner ? 'font-bold' : ''}`}>
                         {isBWinner && <TrophyIcon className="h-5 w-5 text-yellow-400" />}
                        <span className="text-base sm:text-lg truncate" style={{ color: match.teamB.color }}>{match.teamB.name}</span>
                    </div>
                </div>
                 <div className="w-16 text-center">
                    {isTie && <span className="px-3 py-1 text-xs font-bold rounded-full bg-gray-500/20 text-gray-400">TIE</span>}
                    {winner && (
                         <div className="flex flex-col items-center text-xs font-semibold text-yellow-500">
                             <TrophyIcon className="h-4 w-4" />
                             <span>Winner</span>
                         </div>
                    )}
                </div>
            </div>
        </div>
    );
};

const TotalMatchesModal: React.FC<{ matches: (Match & { finalScoreA: number, finalScoreB: number })[]; onClose: () => void; }> = ({ matches, onClose }) => {
    return (
        <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center z-50 p-4 animate-fade-in" 
            onClick={onClose}
            role="dialog"
            aria-modal="true"
            aria-labelledby="total-matches-title"
        >
            <div 
                className="bg-light-background dark:bg-dark-card rounded-2xl w-full max-w-3xl max-h-[90vh] flex flex-col p-6 md:p-8 shadow-2xl relative animate-modal-scale-in" 
                onClick={e => e.stopPropagation()}
            >
                <button 
                    onClick={onClose} 
                    className="absolute top-4 right-4 p-2 rounded-full bg-light-card-secondary/80 hover:bg-light-border dark:bg-dark-card-secondary/80 dark:hover:bg-dark-border z-10"
                    aria-label="Close match list"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>

                <div className="flex-shrink-0 pb-4 border-b border-light-border dark:border-dark-border">
                    <h2 id="total-matches-title" className="text-3xl font-bold font-display text-center">
                        All Completed Matches
                    </h2>
                    <p className="text-center text-light-text-muted dark:text-dark-text-muted font-semibold">{matches.length} Total</p>
                </div>
                
                <div className="flex-grow overflow-y-auto mt-4 pr-2 -mr-4">
                     <div className="space-y-3">
                        {matches.map((match, index) => (
                            <MatchInfoCard key={match.id} match={match} index={index} />
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default TotalMatchesModal;
--- END FILE: components\TotalMatchesModal.tsx ---

--- START FILE: constants.ts ---

import { Sport } from './types';
import type { MatchConfig } from './types';

export const TEAM_COLORS = [
    '#EF4444', // Red
    '#3B82F6', // Blue
    '#10B981', // Emerald Green
    '#F59E0B', // Amber
    '#8B5CF6', // Violet
    '#EC4899', // Pink
    '#14B8A6', // Teal
    '#E5E7EB', // Light Gray (as White)
];
--- END FILE: constants.ts ---

--- START FILE: create_snapshot.py ---
import os
from pathlib import Path

# --- SCRIPT CONFIGURATION ---

# 1. SET YOUR PROJECT'S ROOT DIRECTORY HERE
#    - '.' means the script will run on the folder it's placed in.
#    - You can also use an absolute path, e.g., Path("C:/Users/YourUser/Projects/SPORTS-SCOREBOARD-PRO")
PROJECT_ROOT = Path('.')

# 2. SET THE NAME OF THE OUTPUT FILE
OUTPUT_FILENAME = "project_snapshot.txt"

# 3. ADD ANY FILES, FOLDERS, OR EXTENSIONS TO IGNORE
#    - This script already ignores common folders like '.git' and 'node_modules'.
#    - Add anything specific to your project you want to exclude.
#    - Wildcards like '*.log' are supported.
IGNORE_PATTERNS = {
    # Version Control & IDE
    '.git',
    '.vscode',
    '.idea',

    # Dependencies & Build Output
    'node_modules',
    'dist',
    'build',
    'out',
    'coverage',

    # Environment & System Files
    '.env',
    '.env.local',
    '.env.development.local',
    '.env.test.local',
    '.env.production.local',
    '.DS_Store',

    # Python specific
    '__pycache__',
    '*.pyc',
    '.venv',
    'venv',

    # Logs and the output file itself
    '*.log',
    OUTPUT_FILENAME,

    # Common binary file extensions (content will be skipped)
    '*.png', '*.jpg', '*.jpeg', '*.gif', '*.ico', '*.svg',
    '*.pdf', '*.zip', '*.gz', '*.tar', '*.rar',
    '*.woff', '*.woff2', '*.ttf', '*.eot', '*.otf',
    '*.mp3', '*.wav', '*.mp4', '*.mov', '*.webm',
}

def is_ignored(path: Path, root: Path, ignore_patterns: set) -> bool:
    """
    Checks if a file or directory should be ignored based on the patterns.
    """
    # Check against patterns relative to the project root
    try:
        relative_path_str = str(path.relative_to(root))
        if any(part in ignore_patterns for part in relative_path_str.split(os.sep)):
            return True
    except ValueError:
        pass  # Path is not within the root, should not happen in this script flow

    # Check against file/folder name and glob patterns
    return (
        path.name in ignore_patterns or
        any(path.match(p) for p in ignore_patterns if '*' in p)
    )

def generate_directory_tree(root_path: Path, ignore_patterns: set, prefix: str = "") -> list:
    """
    Generates a list of strings representing the directory tree view.
    """
    if not root_path.is_dir():
        return []

    items = sorted([item for item in root_path.iterdir() if not is_ignored(item, PROJECT_ROOT, ignore_patterns)])
    tree_lines = []
    for i, item in enumerate(items):
        connector = "└── " if i == len(items) - 1 else "├── "
        tree_lines.append(f"{prefix}{connector}{item.name}")
        if item.is_dir():
            extension = "    " if i == len(items) - 1 else "│   "
            tree_lines.extend(generate_directory_tree(item, ignore_patterns, prefix + extension))
    return tree_lines

def get_project_files(root_path: Path, ignore_patterns: set) -> list:
    """
    Walks the directory and returns a sorted list of file paths to include.
    """
    files_to_include = []
    for root, _, files in os.walk(root_path):
        root_path_obj = Path(root)
        if is_ignored(root_path_obj, root_path, ignore_patterns):
            continue
        for file in files:
            file_path = root_path_obj / file
            if not is_ignored(file_path, root_path, ignore_patterns):
                files_to_include.append(file_path)
    return sorted(files_to_include)

def main():
    """
    Main function to generate the project snapshot file.
    """
    print("Starting project snapshot generation...")
    
    output_file_path = PROJECT_ROOT / OUTPUT_FILENAME

    with open(output_file_path, "w", encoding="utf-8") as f:
        # --- 1. Write the Directory Tree ---
        f.write("PROJECT DIRECTORY TREE (Filtered View)\n")
        f.write("======================================================================\n")
        
        # Display the root folder name at the top of the tree
        f.write(f"{PROJECT_ROOT.resolve().name}\n")
        
        tree_lines = generate_directory_tree(PROJECT_ROOT, IGNORE_PATTERNS)
        f.write("\n".join(tree_lines))
        f.write("\n\n\n") # Add spacing before file contents

        # --- 2. Write File Contents ---
        project_files = get_project_files(PROJECT_ROOT, IGNORE_PATTERNS)
        
        print(f"Found {len(project_files)} files to include.")

        for file_path in project_files:
            try:
                relative_path = file_path.relative_to(PROJECT_ROOT)
                print(f"  -> Processing: {relative_path}")
                
                f.write(f"--- START FILE: {relative_path} ---\n")
                
                # Read file content with robust error handling
                try:
                    content = file_path.read_text(encoding="utf-8", errors="ignore")
                    f.write(content)
                    # Ensure a newline at the end of the file content
                    if content and not content.endswith('\n'):
                        f.write('\n')
                except Exception as e:
                    f.write(f"*** Error reading file: {e} ***\n")
                    
                f.write(f"--- END FILE: {relative_path} ---\n\n")
            except Exception as e:
                print(f"  -> ERROR processing file {file_path}: {e}")


    print("----------------------------------------------------------------------")
    print(f"Success! Project snapshot created at: {output_file_path.resolve()}")
    print("You can now copy the contents of this file.")
    print("----------------------------------------------------------------------")

if __name__ == "__main__":
    main()
--- END FILE: create_snapshot.py ---

--- START FILE: hooks\useGameClock.ts ---
import { useState, useEffect, useRef, useCallback } from 'react';

export const useGameClock = (initialTime: number, onEnd?: () => void, mode: 'countdown' | 'stopwatch' = 'countdown') => {
    const [time, setTime] = useState(initialTime);
    const timeRef = useRef(initialTime);
    const [isRunning, setIsRunning] = useState(false);
    const intervalRef = useRef<number | null>(null);
    const onEndRef = useRef(onEnd);

    useEffect(() => {
        timeRef.current = time;
    }, [time]);

    useEffect(() => {
        onEndRef.current = onEnd;
    }, [onEnd]);

    const cleanup = () => {
        if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
        }
    };

    useEffect(() => {
        if (isRunning) {
            intervalRef.current = window.setInterval(() => {
                if (mode === 'countdown') {
                    setTime(prevTime => {
                        if (prevTime <= 1) {
                            cleanup();
                            setIsRunning(false);
                            if (onEndRef.current) {
                               onEndRef.current();
                            }
                            return 0;
                        }
                        return prevTime - 1;
                    });
                } else { // stopwatch mode
                    setTime(prevTime => prevTime + 1);
                }
            }, 1000);
        } else {
            cleanup();
        }

        return cleanup;
    }, [isRunning, mode]);

    const start = useCallback(() => {
        // For countdown, don't start if time is 0
        if (mode === 'countdown' && time <= 0) {
            return;
        }
        setIsRunning(true);
    }, [time, mode]);

    const pause = useCallback(() => {
        setIsRunning(false);
    }, []);
    
    const reset = useCallback((newTime: number) => {
        setIsRunning(false);
        setTime(newTime);
    }, []);

    return { time, timeRef, isRunning, start, pause, reset, setTime };
};
--- END FILE: hooks\useGameClock.ts ---

--- START FILE: hooks\useGameLogic.ts ---
import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { useGameClock } from './useGameClock';
import type { MatchConfig, GameState, PauseReason } from '../types';
import { Sport, GameStatus } from '../types';

type HistoryEntry = { gameState: GameState, time: number };
type History = {
    states: HistoryEntry[];
    index: number;
};

const createInitialState = (config: MatchConfig): GameState => ({
  teamA: { ...config.teamA, score: 0 },
  teamB: { ...config.teamB, score: 0 },
  currentPeriod: 1,
  status: GameStatus.NotStarted,
  periodScores: [],
  ...(config.sport === Sport.Volleyball && { setScores: { a: 0, b: 0 } }),
});

const clearNotification = (state: GameState): GameState => {
    if (!state.notification) return state;
    const { notification, ...rest } = state;
    return rest;
};

export const useGameLogic = (config: MatchConfig | null, matchId: string | null) => {
    const [history, setHistory] = useState<History>({ states: [], index: -1 });
    const prevMatchIdRef = useRef<string | null>(null);
    const channel = useRef(new BroadcastChannel('scoreboard-pro-updates'));

    const currentHistoryEntry = useMemo(() => {
        if (history.index < 0 || history.index >= history.states.length) {
            return null;
        }
        return history.states[history.index];
    }, [history]);

    const gameState = currentHistoryEntry?.gameState ?? null;
    
    const isStopwatch = useMemo(() => config?.sport === Sport.Volleyball && config?.gameMode !== 'score', [config]);

    const handleEndOfPeriod = useCallback((currentState: GameState): GameState => {
        if (!config || config.gameMode === 'score') return currentState;

        const sumOfPreviousScoresA = (currentState.periodScores || []).reduce((sum, score) => sum + (score?.a || 0), 0);
        const sumOfPreviousScoresB = (currentState.periodScores || []).reduce((sum, score) => sum + (score?.b || 0), 0);

        const currentPeriodScoreA = currentState.teamA.score - sumOfPreviousScoresA;
        const currentPeriodScoreB = currentState.teamB.score - sumOfPreviousScoresB;

        if (config.sport === Sport.Volleyball && config.gameMode === 'time' && currentPeriodScoreA === currentPeriodScoreB) {
            return {
                ...currentState,
                status: GameStatus.TieBreak,
                message: null, // Set message to null to prevent the old overlay
            };
        }

        const updatedPeriodScores = [...(currentState.periodScores || []), { a: currentPeriodScoreA, b: currentPeriodScoreB }];

        let newSetScores = currentState.setScores;
        if (config.sport === Sport.Volleyball) {
            newSetScores = (updatedPeriodScores).reduce((acc, score) => {
                if (score.a > score.b) acc.a++;
                else if (score.b > score.a) acc.b++;
                return acc;
            }, { a: 0, b: 0 });
            
            const setsToWin = Math.ceil(config.periods / 2);
            const matchWinner = newSetScores.a === setsToWin ? 'A' : (newSetScores.b === setsToWin ? 'B' : null);

            if (matchWinner) {
                const winnerName = matchWinner === 'A' ? currentState.teamA.name : currentState.teamB.name;
                return {
                    ...currentState,
                    status: GameStatus.Finished,
                    winner: matchWinner,
                    message: `Match Over - ${winnerName} Wins!`,
                    periodScores: updatedPeriodScores,
                    setScores: newSetScores
                };
            }
        }

        if (currentState.currentPeriod >= config.periods) {
            // End of Match
            if (config.sport === Sport.Volleyball && newSetScores) {
                const winner: 'A' | 'B' | 'TIE' = newSetScores.a > newSetScores.b ? 'A' : (newSetScores.b > newSetScores.a ? 'B' : 'TIE');
                const winnerName = winner === 'A' ? currentState.teamA.name : (winner === 'B' ? currentState.teamB.name : null);
                return {
                     ...currentState,
                    status: GameStatus.Finished,
                    winner,
                    message: winner === 'TIE' ? "Match Over - It's a Tie!" : `Match Over - ${winnerName} Wins!`,
                    periodScores: updatedPeriodScores,
                    setScores: newSetScores
                };
            }
            
            const winner: 'A' | 'B' | 'TIE' = currentState.teamA.score > currentState.teamB.score ? 'A' : (currentState.teamB.score > currentState.teamA.score ? 'B' : 'TIE');
            const winnerName = winner === 'A' ? currentState.teamA.name : (winner === 'B' ? currentState.teamB.name : null);
            return {
                ...currentState,
                status: GameStatus.Finished,
                winner,
                message: winner === 'TIE' ? "Match Over - It's a Tie!" : `Match Over - ${winnerName} Wins!`,
                periodScores: updatedPeriodScores,
            };
        } else {
            // End of Period
            return {
                ...currentState,
                status: GameStatus.PeriodBreak,
                message: `End of ${config.sport === Sport.Volleyball ? 'Set' : (config.sport === Sport.Soccer ? 'Half' : 'Quarter')} ${currentState.currentPeriod}`,
                periodScores: updatedPeriodScores,
                ...(config.sport === Sport.Volleyball && { setScores: newSetScores }),
            };
        }
    }, [config]);

    const recordState = useCallback((stateProducer: (prevGameState: GameState) => GameState) => {
        setHistory(prevHistory => {
            const currentGameState = prevHistory.states[prevHistory.index]?.gameState;
            if (!currentGameState) return prevHistory;
            
            const newGameState = stateProducer(currentGameState);

            // This comparison is imperfect for complex objects but works for this state.
            if (JSON.stringify(currentGameState) === JSON.stringify(newGameState)) {
                return prevHistory;
            }

            const newEntry: HistoryEntry = {
                gameState: newGameState,
                time: 0, // Placeholder, will be replaced by timeRef below
            };

            const newStates = prevHistory.states.slice(0, prevHistory.index + 1);
            newStates.push(newEntry);
            
            return {
                states: newStates,
                index: newStates.length - 1
            };
        });
    }, []);

    const setGameState = useCallback((stateProducer: (prevGameState: GameState) => GameState) => {
        recordState(stateProducer);
    }, [recordState]);
    
    // Effect to auto-dismiss notifications
    useEffect(() => {
        if (gameState?.notification) {
            const timer = setTimeout(() => {
                setGameState(s => clearNotification(s));
            }, 3000); // Notification disappears after 3 seconds
            return () => clearTimeout(timer);
        }
    }, [gameState?.notification, setGameState]);


    const handleTimeUp = useCallback(() => {
        if (isStopwatch || config?.gameMode === 'score') return;
        setGameState(prev => handleEndOfPeriod(prev));
    }, [isStopwatch, handleEndOfPeriod, config, setGameState]);

    const initialTime = useMemo(() => {
        if (!config) return 0;
        return isStopwatch || config.gameMode === 'score' ? 0 : config.durationMinutes * 60 + config.durationSeconds;
    }, [config, isStopwatch]);

    const { time, timeRef, isRunning, start, pause, reset: resetClock, setTime: setClockTime } = useGameClock(
        initialTime, 
        handleTimeUp,
        isStopwatch ? 'stopwatch' : 'countdown'
    );
    
    useEffect(() => {
        // When state is recorded, it doesn't know the current time yet.
        // This effect runs after render and patches the latest history entry with the correct time.
        if (history.index > -1) {
            const currentEntry = history.states[history.index];
            if (currentEntry && timeRef.current !== currentEntry.time) {
                const newStates = [...history.states];
                newStates[history.index] = { ...currentEntry, time: timeRef.current };
                setHistory(h => ({ ...h, states: newStates }));
            }
        }
    }, [history, timeRef]);


    useEffect(() => {
        if (!config || !matchId) {
            setHistory({ states: [], index: -1 });
            prevMatchIdRef.current = null;
            return;
        }

        const isNewMatchId = prevMatchIdRef.current !== matchId;

        if (isNewMatchId) {
            prevMatchIdRef.current = matchId;

            const savedDataRaw = localStorage.getItem(`match-state-${matchId}`);
            if (savedDataRaw) {
                try {
                    const savedHistory = JSON.parse(savedDataRaw);
                    if (savedHistory.states && savedHistory.states.length > 0 && typeof savedHistory.index === 'number') {
                        setHistory(savedHistory);
                        setClockTime(savedHistory.states[savedHistory.index].time);
                        return; // Successfully loaded, stop here.
                    }
                } catch (e) {
                    console.error("Failed to parse saved match history", e);
                }
            }
            // If no valid saved data, create a fresh history.
            const initialGameState = createInitialState(config);
            setHistory({
                states: [{ gameState: initialGameState, time: initialTime }],
                index: 0
            });
            resetClock(initialTime);

        } else {
            // This case handles mid-game config changes. We reset the history.
            const newInitialGameState = createInitialState(config);
            setHistory({
                states: [{ gameState: newInitialGameState, time: initialTime }],
                index: 0
            });
            resetClock(initialTime);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [matchId, config]);

    useEffect(() => {
        if (matchId && history.index > -1) {
            localStorage.setItem(`match-state-${matchId}`, JSON.stringify(history));
            
            // Broadcast only the current state for other tabs
            const currentState = history.states[history.index];
            const dataToBroadcast = { gameState: currentState.gameState, time: time };
            channel.current.postMessage({ matchId, data: dataToBroadcast });
        }
    }, [history, matchId, time]);


    const checkVolleyballWin = useCallback((newGameState: GameState) => {
        if (config?.sport !== Sport.Volleyball || !newGameState.setScores || config?.gameMode !== 'score') return newGameState;

        const { teamA, teamB, setScores, periodScores } = newGameState;
        
        const pointsToWin = config.targetScore ?? 25;
        const aWins = teamA.score >= pointsToWin && teamA.score >= teamB.score + 2;
        const bWins = teamB.score >= pointsToWin && teamB.score >= teamA.score + 2;

        if (aWins || bWins) {
            const newSetScores = { a: setScores.a + (aWins ? 1 : 0), b: setScores.b + (bWins ? 1 : 0) };
            const updatedPeriodScores = [...periodScores, { a: teamA.score, b: teamB.score }];
            
            const setsToWin = Math.ceil(config.periods / 2);
            const matchWinner: 'A' | 'B' | null = newSetScores.a === setsToWin ? 'A' : (newSetScores.b === setsToWin ? 'B' : null);

            if (matchWinner) {
                const winnerName = matchWinner === 'A' ? teamA.name : teamB.name;
                return {
                    ...newGameState,
                    setScores: newSetScores,
                    periodScores: updatedPeriodScores,
                    status: GameStatus.Finished,
                    winner: matchWinner,
                    message: `Match Over - ${winnerName} Wins!`,
                };
            } else {
                 return {
                    ...newGameState,
                    teamA: { ...teamA, score: 0 },
                    teamB: { ...teamB, score: 0 },
                    setScores: newSetScores,
                    periodScores: updatedPeriodScores,
                    status: GameStatus.PeriodBreak,
                    message: `Set ${newGameState.currentPeriod} Winner: ${aWins ? teamA.name : teamB.name}`,
                };
            }
        }
        return newGameState;
    }, [config]);
    
    const updateScore = useCallback((team: 'A' | 'B', delta: number) => {
        setGameState(prev => {
            if (!prev || prev.status === GameStatus.Finished) return prev;
            const baseState = clearNotification(prev);
            
            if (baseState.status === GameStatus.TieBreak && config?.sport === Sport.Volleyball && config.gameMode === 'time') {
                const newScoreValue = team === 'A' ? baseState.teamA.score + delta : baseState.teamB.score + delta;
                const tempState: GameState = {
                    ...baseState,
                    teamA: { ...baseState.teamA, score: team === 'A' ? Math.max(0, newScoreValue) : baseState.teamA.score },
                    teamB: { ...baseState.teamB, score: team === 'B' ? Math.max(0, newScoreValue) : baseState.teamB.score },
                    message: null,
                };

                const sumOfPreviousScoresA = (tempState.periodScores || []).reduce((sum, score) => sum + (score?.a || 0), 0);
                const sumOfPreviousScoresB = (tempState.periodScores || []).reduce((sum, score) => sum + (score?.b || 0), 0);
                const currentPeriodScoreA = tempState.teamA.score - sumOfPreviousScoresA;
                const currentPeriodScoreB = tempState.teamB.score - sumOfPreviousScoresB;

                if (Math.abs(currentPeriodScoreA - currentPeriodScoreB) >= 2) {
                    // Tie broken, end the period
                    return handleEndOfPeriod(tempState);
                }
                return tempState; // Tie not broken yet
            }

            const newScore = team === 'A' ? baseState.teamA.score + delta : baseState.teamB.score + delta;
            const updatedState: GameState = {
                ...baseState,
                teamA: { ...baseState.teamA, score: team === 'A' ? Math.max(0, newScore) : baseState.teamA.score },
                teamB: { ...baseState.teamB, score: team === 'B' ? Math.max(0, newScore) : baseState.teamB.score },
            };

            if (config?.gameMode === 'score' && config.targetScore) {
                const newScoreA = updatedState.teamA.score;
                const newScoreB = updatedState.teamB.score;

                if (newScoreA >= config.targetScore || newScoreB >= config.targetScore) {
                    const winner: 'A' | 'B' = newScoreA >= config.targetScore ? 'A' : 'B';
                    const winnerName = winner === 'A' ? updatedState.teamA.name : updatedState.teamB.name;
                    const finalPeriodScore = { a: updatedState.teamA.score, b: updatedState.teamB.score };
                     return {
                         ...updatedState,
                         status: GameStatus.Finished,
                         winner,
                         message: `Match Over - ${winnerName} Wins!`,
                         periodScores: [...(updatedState.periodScores || []), finalPeriodScore],
                     };
                }
            }

            if (config?.sport === Sport.Volleyball) {
                return checkVolleyballWin(updatedState);
            }
            return updatedState;
        });
    }, [config, checkVolleyballWin, setGameState, handleEndOfPeriod]);

    const startClock = useCallback(() => {
        setGameState(prev => {
            if (!prev || prev.status === GameStatus.Finished) return prev;
            const baseState = clearNotification(prev);
            if (config?.gameMode !== 'score') {
                start();
            }
            return { ...baseState, status: GameStatus.InProgress, pauseReason: null };
        });
    }, [start, config, setGameState]);

    const pauseClock = useCallback(() => {
        setGameState(prev => {
            if (!prev || prev.status === GameStatus.Finished) return prev;
            const baseState = clearNotification(prev);
            if (config?.gameMode !== 'score') {
                pause();
            }
            return { ...baseState, status: GameStatus.Paused };
        });
    }, [pause, config, setGameState]);
    
    const setPauseReason = useCallback((reason: PauseReason) => {
        setGameState(prev => ({ ...clearNotification(prev), pauseReason: reason }));
        setTimeout(() => {
             setGameState(prev => ({ ...prev, pauseReason: null }));
        }, 3000);
    }, [setGameState]);

    const startNextPeriod = useCallback(() => {
        setGameState(prev => {
            if (!config || !prev || (prev.status !== GameStatus.PeriodBreak && prev.status !== GameStatus.NotStarted) || config.gameMode === 'score') {
                return prev;
            }
            
            const isFirstPeriodStart = prev.status === GameStatus.NotStarted;
            const newPeriod = isFirstPeriodStart ? prev.currentPeriod : prev.currentPeriod + 1;
            
            if (newPeriod > config.periods) {
                 return {...clearNotification(prev), status: GameStatus.Finished, message: "Match Over"};
            }
            
            if (config.sport === Sport.Volleyball) {
                resetClock(0);
            } else if (!isFirstPeriodStart) {
                resetClock(initialTime);
            }
            start();

            return {
                ...clearNotification(prev),
                currentPeriod: newPeriod,
                status: GameStatus.InProgress,
                message: null,
            };
        });
    }, [config, resetClock, initialTime, start, setGameState]);

    const reset = useCallback(() => {
       if(config) {
            const initialGameState = createInitialState(config);
            setHistory({
                states: [{ gameState: initialGameState, time: initialTime }],
                index: 0
            });
            resetClock(initialTime);
       }
    }, [config, resetClock, initialTime]);
    
    const getSetScoresFromPeriodScores = (periodScores: GameState['periodScores']) => {
        return (periodScores || []).reduce((acc, score) => {
            if (score && score.a > score.b) acc.a++;
            if (score && score.b > score.a) acc.b++;
            return acc;
        }, { a: 0, b: 0 });
    };

    const goToNextPeriod = useCallback(() => {
        setGameState(prev => {
            if (!config || !prev || isRunning || prev.status === GameStatus.Finished || prev.currentPeriod >= config.periods || config.gameMode === 'score') {
                return prev;
            }

            const currentPeriodScores = prev.periodScores || [];
            const sumOfScoresBeforeCurrentA = currentPeriodScores
                .slice(0, prev.currentPeriod - 1)
                .reduce((sum, score) => sum + (score?.a || 0), 0);
            
            const sumOfScoresBeforeCurrentB = currentPeriodScores
                .slice(0, prev.currentPeriod - 1)
                .reduce((sum, score) => sum + (score?.b || 0), 0);

            const scoreForCurrentPeriodA = prev.teamA.score - sumOfScoresBeforeCurrentA;
            const scoreForCurrentPeriodB = prev.teamB.score - sumOfScoresBeforeCurrentB;

            if (config.sport === Sport.Volleyball && config.gameMode === 'time' && scoreForCurrentPeriodA === scoreForCurrentPeriodB) {
                return {
                    ...prev,
                    notification: { message: 'A set must have a winner. Please add a point to break the tie.' }
                };
            }

            const newPeriodScores = [...currentPeriodScores];
            newPeriodScores[prev.currentPeriod - 1] = { a: scoreForCurrentPeriodA, b: scoreForCurrentPeriodB };
            
            let newSetScores = prev.setScores;
            if (config.sport === Sport.Volleyball) {
                resetClock(0);
                newSetScores = getSetScoresFromPeriodScores(newPeriodScores);
            } else {
                resetClock(initialTime);
            }

            return {
                ...clearNotification(prev),
                currentPeriod: prev.currentPeriod + 1,
                periodScores: newPeriodScores,
                ...(config.sport === Sport.Volleyball && { setScores: newSetScores }),
            };
        });
    }, [config, isRunning, initialTime, resetClock, setGameState]);

    const goToPreviousPeriod = useCallback(() => {
        setGameState(prev => {
            if (!config || !prev || isRunning || prev.status === GameStatus.Finished || prev.currentPeriod <= 1 || config.gameMode === 'score') {
                return prev;
            }
             
            let newSetScores = prev.setScores;
            if (config.sport === Sport.Volleyball) {
                resetClock(0);
                newSetScores = getSetScoresFromPeriodScores((prev.periodScores || []).slice(0, prev.currentPeriod - 2));
            } else {
                resetClock(initialTime);
            }

            return {
                ...clearNotification(prev),
                currentPeriod: prev.currentPeriod - 1,
                 ...(config.sport === Sport.Volleyball && { setScores: newSetScores }),
            };
        });
    }, [config, isRunning, initialTime, resetClock, setGameState]);
    
    const finishMatchManually = useCallback(() => {
        if (config?.gameMode === 'score') return;
        pause();
        setGameState(prev => {
            if (!prev) return prev;
            
            const isDecidingSet = prev.currentPeriod === config.periods && prev.setScores?.a === prev.setScores?.b;

            if (config?.sport === Sport.Volleyball && config?.gameMode === 'time' && isDecidingSet) {
                const sumOfPreviousScoresA = (prev.periodScores || []).reduce((sum, score) => sum + (score?.a || 0), 0);
                const sumOfPreviousScoresB = (prev.periodScores || []).reduce((sum, score) => sum + (score?.b || 0), 0);
                const currentSetScoreA = prev.teamA.score - sumOfPreviousScoresA;
                const currentSetScoreB = prev.teamB.score - sumOfPreviousScoresB;

                if (currentSetScoreA === currentSetScoreB) {
                    return {
                        ...prev,
                        notification: { message: 'Final set cannot end in a tie. A winner must be decided.' }
                    };
                }
            }
            return handleEndOfPeriod(clearNotification(prev));
        });
    }, [handleEndOfPeriod, pause, config, setGameState]);

    const startAction = () => {
        if (gameState?.status === GameStatus.PeriodBreak) {
            startNextPeriod();
        } else {
            startClock();
        }
    };
    
    const undo = useCallback(() => {
        setHistory(prev => {
            const newIndex = Math.max(0, prev.index - 1);
            if (prev.states[newIndex]) {
                setClockTime(prev.states[newIndex].time);
            }
            return { ...prev, index: newIndex };
        });
    }, [setClockTime]);

    const redo = useCallback(() => {
        setHistory(prev => {
            const newIndex = Math.min(prev.states.length - 1, prev.index + 1);
            if (prev.states[newIndex]) {
                setClockTime(prev.states[newIndex].time);
            }
            return { ...prev, index: newIndex };
        });
    }, [setClockTime]);


    const canUndo = history.index > 0;
    const canRedo = history.index < history.states.length - 1;


    const actions = useMemo(() => ({
        start: startAction,
        pause: pauseClock,
        reset,
        updateScore,
        setPauseReason,
        startNextPeriod,
        goToNextPeriod,
        goToPreviousPeriod,
        finishMatchManually,
        undo,
        redo,
    }), [startAction, pauseClock, reset, updateScore, setPauseReason, startNextPeriod, goToNextPeriod, goToPreviousPeriod, finishMatchManually, undo, redo]);

    return { gameState, time, isRunning, actions, canUndo, canRedo };
};
--- END FILE: hooks\useGameLogic.ts ---

--- START FILE: index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Project: Iskor-App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;700&family=Teko:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
      /* --- KEYFRAME ANIMATIONS (UNCHANGED) --- */
      @keyframes score-update {
        0% { transform: scale(1); } 30% { transform: scale(1.3); } 60% { transform: scale(0.95); } 100% { transform: scale(1); }
      }
      .animate-score-update { animation: score-update 0.4s cubic-bezier(0.2, 1.5, 0.5, 1); }
      @keyframes slide-in-left { from { transform: translateX(-20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
      @keyframes winner-card-pop-in { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
      @keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }
      .animate-fade-in { animation: fade-in 0.4s ease-out; }
      @keyframes modal-scale-in { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
      .animate-modal-scale-in { animation: modal-scale-in 0.3s cubic-bezier(0.165, 0.84, 0.44, 1) forwards; }
      @keyframes content-slide-up { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
      .animate-content-slide-up { animation: content-slide-up 0.5s cubic-bezier(0.165, 0.84, 0.44, 1) forwards; opacity: 0; }
      @keyframes archive-fly-out { to { transform: translateX(150%) rotate(15deg) scale(0.8); opacity: 0; } }
      .animate-archive-fly-out { animation: archive-fly-out 0.5s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards; }
      @keyframes unarchive-fly-out { to { transform: translateX(-150%) rotate(-15deg) scale(0.8); opacity: 0; } }
      .animate-unarchive-fly-out { animation: unarchive-fly-out 0.5s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards; }
      @keyframes complete-fly-out { to { transform: translateY(-150%) scale(0.8); opacity: 0; } }
      .animate-complete-fly-out { animation: complete-fly-out 0.5s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards; }
      @keyframes animate-chart-bar { from { transform: scaleX(0); } to { transform: scaleX(1); } }
      .animate-chart-bar { transform-origin: left; animation: animate-chart-bar 0.7s cubic-bezier(0.5, 0, 0.5, 1) forwards; transition: none; }
      @keyframes slide-in-bottom { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
      .animate-slide-in-bottom { animation: slide-in-bottom 0.6s cubic-bezier(0.25, 1, 0.5, 1) forwards; opacity: 0; }
      @keyframes shrink-and-fade { to { transform: scale(0.8); opacity: 0; } }
      .animate-shrink-and-fade { animation: shrink-and-fade 0.5s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards; }
      @keyframes fade-in-delayed { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
      .animate-fade-in-delay-1 { animation: fade-in-delayed 0.5s ease-out 0.2s forwards; opacity: 0; }
      .animate-fade-in-delay-2 { animation: fade-in-delayed 0.5s ease-out 0.4s forwards; opacity: 0; }
      .animate-fade-in-delay-3 { animation: fade-in-delayed 0.5s ease-out 0.6s forwards; opacity: 0; }
      .animate-fade-in-delay-4 { animation: fade-in-delayed 0.5s ease-out 0.8s forwards; opacity: 0; }
      
      /* --- NEW THEME-SPECIFIC ANIMATIONS --- */
      @keyframes aurora { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
      @keyframes scanline { to { background-position: 0 200%; } }
      @keyframes text-flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
      
      /* --- NEW WINNER MODAL ANIMATIONS --- */
      @keyframes trophy-bounce-enhanced { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-30px) rotate(5deg); } 60% { transform: translateY(-15px) rotate(-5deg); } }
      .animate-trophy-bounce-enhanced { animation: trophy-bounce-enhanced 2s ease-in-out infinite; }
      @keyframes glow { 0% { box-shadow: 0 0 10px -5px var(--winner-glow); } 50% { box-shadow: 0 0 40px 0px var(--winner-glow); } 100% { box-shadow: 0 0 10px -5px var(--winner-glow); } }
      .animate-glow { animation: glow 4s ease-in-out infinite; }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
      .sunburst-bg {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        background-image:
            radial-gradient(ellipse at center, rgba(255, 255, 255, 0.1) 0%, transparent 60%),
            repeating-conic-gradient(from 0deg, var(--winner-glow) 0deg 5deg, transparent 5deg 15deg);
        background-position: center center; background-size: cover; opacity: 0.1;
        animation: spin 60s linear infinite; z-index: 0;
      }
      .confetti-container { position: absolute; inset: 0; overflow: hidden; pointer-events: none; z-index: 2; }
      .confetti {
        position: absolute; width: 8px; height: 16px; background: var(--winner-glow);
        top: -20px; opacity: 0; animation: fall 5s linear infinite;
      }
      @keyframes fall {
        from { transform: translateY(0vh) rotate(0deg); opacity: 1; }
        to { transform: translateY(110vh) rotate(720deg); opacity: 0; }
      }

      /* --- THEME DEFINITIONS --- */
      :root, html.light {
        --color-background: #F0F2F5; --color-card: #FFFFFF; --color-card-secondary: #F7F7F8;
        --color-text: #1C1E21; --color-text-muted: #606770; --color-border: #E0E0E0;
        --color-brand-blue: #00A8FF; --color-brand-red: #EF4444;
        --font-sans: 'Inter', sans-serif; --font-mono: 'Roboto Mono', monospace; --font-display: 'Teko', sans-serif;
      }
      html.dark {
        --color-background: #101418; --color-card: #1A1D21; --color-card-secondary: #2C3238;
        --color-text: #E4E6EB; --color-text-muted: #A8B3CF; --color-border: #30363d;
      }
      html.viola {
        --color-background: #0D0C1D; --color-card: #16152B; --color-card-secondary: #201F3D;
        --color-text: #E0DDFE; --color-text-muted: #8481A0; --color-border: #312F5D;
        --color-brand-blue: #9f7aea; --color-brand-red: #ED64A6;
      }
      html.coder {
        --color-background: #020a02;
        --color-card: rgba(0, 50, 0, 0.3);
        --color-card-secondary: rgba(0, 70, 0, 0.4);
        --color-text: #00dd00; /* Slightly less harsh green */
        --color-text-muted: #00aa00;
        --color-border: rgba(0, 255, 0, 0.3); /* More subtle border */
        --color-brand-blue: #00ef00;
        --color-brand-red: #FF4141;
        --font-sans: 'Roboto Mono', monospace;
        --font-mono: 'Roboto Mono', monospace;
        --font-display: 'Teko', sans-serif; /* Restore Teko for display elements */
      }
      
      /* --- GLOBAL STYLES & TRANSITIONS --- */
      body {
        font-family: var(--font-sans);
        background-color: var(--color-background);
        color: var(--color-text);
      }
      .font-sans { font-family: var(--font-sans); }
      .font-mono { font-family: var(--font-mono); }
      .font-display { font-family: var(--font-display); }
      *, *::before, *::after {
        transition-property: color, background-color, border-color, fill, stroke, opacity, box-shadow, transform;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 200ms;
      }

      /* --- THEME-SPECIFIC EFFECTS --- */
      /* VIOLA THEME: Aurora Background */
      html.viola body { position: relative; }
      html.viola body::before, html.viola body::after {
        content: ''; position: fixed; z-index: -1; top: 50%; left: 50%;
        width: 200vw; height: 200vh; transform: translate(-50%, -50%);
        background: radial-gradient(circle at center, rgba(128, 0, 128, 0.2) 0, transparent 30%),
                    radial-gradient(circle at center, rgba(0, 0, 255, 0.2) 0, transparent 30%);
        background-size: 200% 200%;
        animation: aurora 20s linear infinite;
        will-change: background-position;
      }
      html.viola body::after { animation-direction: reverse; animation-duration: 30s; }
      html.viola .card-glow-on-hover:hover { transform: translateY(-4px); box-shadow: 0 0 25px -5px rgba(159, 122, 234, 0.4); }
      
      /* GRADIENT TEXTS */
      .text-gradient-viola { background-image: linear-gradient(to bottom right, #a78bfa, #f472b6); -webkit-background-clip: text; background-clip: text; color: transparent; }
      .text-gradient-dark { background-image: linear-gradient(to bottom right, #00A8FF, #0077B6); -webkit-background-clip: text; background-clip: text; color: transparent; }
      .text-gradient-coder { background-image: linear-gradient(to bottom right, #39FF14, #00aa00); -webkit-background-clip: text; background-clip: text; color: transparent; }
      .text-gradient-light { background-image: linear-gradient(to bottom right, #00A8FF, #005f8d); -webkit-background-clip: text; background-clip: text; color: transparent; }

      /* CODER THEME: Matrix/Terminal Effects */
      html.coder body {
        background-image: linear-gradient(rgba(0, 255, 0, 0.04) 1px, transparent 1px), linear-gradient(to right, rgba(0, 255, 0, 0.04) 1px, transparent 1px);
        background-size: 25px 25px;
        background-position: -1px -1px;
        text-shadow: 0 0 4px rgba(0, 221, 0, 0.3);
      }
      html.coder h1, html.coder h2, html.coder h3, html.coder .font-bold {
          text-shadow: 0 0 6px rgba(0, 221, 0, 0.5);
      }
      html.coder body::after {
        content: ' '; display: block; position: fixed; top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
        background-size: 100% 4px; z-index: 9999; pointer-events: none;
        animation: scanline 8s linear infinite;
        opacity: 0.7; /* Make scanlines a bit more subtle */
      }
      html.coder .shadow-lg, html.coder .shadow-xl, html.coder .shadow-2xl {
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.1), 0 0 5px rgba(0, 255, 0, 0.15);
        border: 1px solid var(--color-border);
      }
      html.coder .card-glow-on-hover:hover {
        transform: translateY(-4px);
        box-shadow: 0 0 25px -5px rgba(0, 255, 0, 0.3), 0 0 8px rgba(0, 255, 0, 0.25);
        border-color: rgba(0, 255, 0, 0.6);
      }
      html.coder .flicker { animation: text-flicker 3s linear infinite; }
      
      /* FIX: Force dark text on bright green buttons for readability */
      html.coder .bg-brand-blue,
      html.coder .bg-green-600,
      html.coder .final-badge,
      html.coder .get-started-btn {
        color: #020a02 !important;
        text-shadow: none !important;
        border: 1px solid var(--color-border);
      }
      html.coder .bg-brand-blue:hover,
      html.coder .bg-green-600:hover {
        background-color: #39FF14 !important;
      }

      /* Ensure compatibility with dark mode classes used in components */
      html.coder .dark\\:bg-black {
        background-color: var(--color-card-secondary) !important;
      }

      /* Default Card Hovers */
      .card-glow-on-hover { transition-property: transform, box-shadow; transition-duration: 300ms; }
      html.light .card-glow-on-hover:hover { transform: translateY(-4px); box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.1); }
      html.dark .card-glow-on-hover:hover { transform: translateY(-4px); box-shadow: 0 0 25px -5px rgba(0, 168, 255, 0.25); }

    </style>
    <script>
      (function() {
        let theme = localStorage.getItem('theme');
        if (!theme) {
          theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        document.documentElement.className = '';
        document.documentElement.classList.add(theme);
      })();

      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: {
              'sans': ['var(--font-sans)', 'sans-serif'],
              'mono': ['var(--font-mono)', 'monospace'],
              'display': ['var(--font-display)', 'sans-serif'],
            },
            colors: {
              brand: {
                blue: 'var(--color-brand-blue)',
                red: 'var(--color-brand-red)',
              },
              light: {
                background: 'var(--color-background)',
                card: 'var(--color-card)',
                'card-secondary': 'var(--color-card-secondary)',
                text: 'var(--color-text)',
                'text-muted': 'var(--color-text-muted)',
                border: 'var(--color-border)',
              },
              dark: {
                background: 'var(--color-background)',
                card: 'var(--color-card)',
                'card-secondary': 'var(--color-card-secondary)',
                text: 'var(--color-text)',
                'text-muted': 'var(--color-text-muted)',
                border: 'var(--color-border)',
              }
            }
          }
        }
      }
    </script>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^18.3.1/",
    "react/": "https://aistudiocdn.com/react@^18.3.1/",
    "react": "https://aistudiocdn.com/react@^18.3.1",
    "vite": "https://aistudiocdn.com/vite@^5.3.3",
    "url": "https://aistudiocdn.com/url@^0.11.4",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.0.4",
    "@google/genai": "https://aistudiocdn.com/@google/genai@0.15.0",
    "jspdf": "https://aistudiocdn.com/jspdf@^2.5.1",
    "jspdf-autotable": "https://aistudiocdn.com/jspdf-autotable@^3.8.2",
    "@babel/runtime/": "https://aistudiocdn.com/@babel/runtime@^7.24.7/",
    "fflate": "https://aistudiocdn.com/fflate@^0.8.2",
    "components/": "https://aistudiocdn.com/components@^0.1.0/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
--- END FILE: index.html ---

--- START FILE: index.tsx ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
--- END FILE: index.tsx ---

--- START FILE: metadata.json ---
{
  "name": "Project: Iskor-App",
  "description": "Project: Iskor-App turns sports matches into legendary showdowns. A professional multi-sport scoreboard for Basketball, Soccer, and Volleyball, perfect for organizers, coaches, and streamers.",
  "requestFramePermissions": []
}
--- END FILE: metadata.json ---

--- START FILE: package-lock.json ---
{
  "name": "sports-scoreboard-pro",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "sports-scoreboard-pro",
      "version": "0.0.0",
      "dependencies": {
        "jspdf": "^2.5.1",
        "jspdf-autotable": "^3.8.2",
        "react": "^18.3.1",
        "react-dom": "^18.3.1"
      },
      "devDependencies": {
        "@types/node": "^20.14.10",
        "@vitejs/plugin-react": "^5.0.4",
        "typescript": "^5.5.3",
        "vite": "^5.3.3"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.4.tgz",
      "integrity": "sha512-YsmSKC29MJwf0gF8Rjjrg5LQCmyh+j/nD8/eP7f+BeoQTKYqs9RoWbjGOdy0+1Ekr68RJZMUOPVQaQisnIo4Rw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.4.tgz",
      "integrity": "sha512-2BCOP7TN8M+gVDj7/ht3hsaO/B/n5oDbiAyyvnRlNOs+u1o+JWNYTQrmpuNp1/Wq2gcFrI01JAW+paEKDMx/CA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helpers": "^7.28.4",
        "@babel/parser": "^7.28.4",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.4",
        "@babel/types": "^7.28.4",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.3.tgz",
      "integrity": "sha512-3lSpxGgvnmZznmBkCRnVREPUFJv2wrv9iAoFDvADJc0ypmdOxdUtcLeBgBJ6zE0PMeTKnxeQzyk0xTBq4Ep7zw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.3",
        "@babel/types": "^7.28.2",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.3.tgz",
      "integrity": "sha512-gytXUbs8k2sXS9PnQptz5o0QnpLL51SwASIORY6XaBKF88nsOT0Zw9szLqlSGQDP/4TljBAD5y98p2U1fqkdsw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.4.tgz",
      "integrity": "sha512-HFN59MmQXGHVyYadKLVumYsA9dBFun/ldYxipEjzA4196jpLZd8UjEEBLkbEkvfYreDqJhZxYAWFPtrfhNpj4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.4.tgz",
      "integrity": "sha512-yZbBqeM6TkpP9du/I2pUZnJsRMGGvOuIrhjzC1AwHwW+6he4mni6Bp/m8ijn0iOuZuPI2BfkCoSRunpyjnrQKg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.4"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.4.tgz",
      "integrity": "sha512-Q/N6JNWvIvPnLDvjlE1OUBLPQHH6l3CltCEsHIujp45zQUSSh8K+gHnaEX45yAT1nyngnINhvWtzN+Nb9D8RAQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.4.tgz",
      "integrity": "sha512-YEzuboP2qvQavAcjgQNVgsvHIDv6ZpwXvcvjmyySP2DIMuByS/6ioU5G9pYrWHM6T2YDfc7xga9iNzYOs12CFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.3",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.4",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.4.tgz",
      "integrity": "sha512-bkFqkLhh3pMBUQQkpVgWDWq/lqzc2678eUyDlTBhRqhCHFguYYGM0Efga7tYk4TogG/3x0EEl66/OQ+WGbWB/Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.38",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.38.tgz",
      "integrity": "sha512-N/ICGKleNhA5nc9XXQG/kkKHJ7S55u0x0XUJbbkmdCnFuoRkM1Il12q9q0eX19+M7KKUEPw/daUPIRnxhcxAIw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.52.4.tgz",
      "integrity": "sha512-BTm2qKNnWIQ5auf4deoetINJm2JzvihvGb9R6K/ETwKLql/Bb3Eg2H1FBp1gUb4YGbydMA3jcmQTR73q7J+GAA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.52.4.tgz",
      "integrity": "sha512-P9LDQiC5vpgGFgz7GSM6dKPCiqR3XYN1WwJKA4/BUVDjHpYsf3iBEmVz62uyq20NGYbiGPR5cNHI7T1HqxNs2w==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.52.4.tgz",
      "integrity": "sha512-QRWSW+bVccAvZF6cbNZBJwAehmvG9NwfWHwMy4GbWi/BQIA/laTIktebT2ipVjNncqE6GLPxOok5hsECgAxGZg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.52.4.tgz",
      "integrity": "sha512-hZgP05pResAkRJxL1b+7yxCnXPGsXU0fG9Yfd6dUaoGk+FhdPKCJ5L1Sumyxn8kvw8Qi5PvQ8ulenUbRjzeCTw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.52.4.tgz",
      "integrity": "sha512-xmc30VshuBNUd58Xk4TKAEcRZHaXlV+tCxIXELiE9sQuK3kG8ZFgSPi57UBJt8/ogfhAF5Oz4ZSUBN77weM+mQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.52.4.tgz",
      "integrity": "sha512-WdSLpZFjOEqNZGmHflxyifolwAiZmDQzuOzIq9L27ButpCVpD7KzTRtEG1I0wMPFyiyUdOO+4t8GvrnBLQSwpw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.52.4.tgz",
      "integrity": "sha512-xRiOu9Of1FZ4SxVbB0iEDXc4ddIcjCv2aj03dmW8UrZIW7aIQ9jVJdLBIhxBI+MaTnGAKyvMwPwQnoOEvP7FgQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.52.4.tgz",
      "integrity": "sha512-FbhM2p9TJAmEIEhIgzR4soUcsW49e9veAQCziwbR+XWB2zqJ12b4i/+hel9yLiD8pLncDH4fKIPIbt5238341Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.52.4.tgz",
      "integrity": "sha512-4n4gVwhPHR9q/g8lKCyz0yuaD0MvDf7dV4f9tHt0C73Mp8h38UCtSCSE6R9iBlTbXlmA8CjpsZoujhszefqueg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.52.4.tgz",
      "integrity": "sha512-u0n17nGA0nvi/11gcZKsjkLj1QIpAuPFQbR48Subo7SmZJnGxDpspyw2kbpuoQnyK+9pwf3pAoEXerJs/8Mi9g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.52.4.tgz",
      "integrity": "sha512-0G2c2lpYtbTuXo8KEJkDkClE/+/2AFPdPAbmaHoE870foRFs4pBrDehilMcrSScrN/fB/1HTaWO4bqw+ewBzMQ==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.52.4.tgz",
      "integrity": "sha512-teSACug1GyZHmPDv14VNbvZFX779UqWTsd7KtTM9JIZRDI5NUwYSIS30kzI8m06gOPB//jtpqlhmraQ68b5X2g==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.52.4.tgz",
      "integrity": "sha512-/MOEW3aHjjs1p4Pw1Xk4+3egRevx8Ji9N6HUIA1Ifh8Q+cg9dremvFCUbOX2Zebz80BwJIgCBUemjqhU5XI5Eg==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.52.4.tgz",
      "integrity": "sha512-1HHmsRyh845QDpEWzOFtMCph5Ts+9+yllCrREuBR/vg2RogAQGGBRC8lDPrPOMnrdOJ+mt1WLMOC2Kao/UwcvA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.52.4.tgz",
      "integrity": "sha512-seoeZp4L/6D1MUyjWkOMRU6/iLmCU2EjbMTyAG4oIOs1/I82Y5lTeaxW0KBfkUdHAWN7j25bpkt0rjnOgAcQcA==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.52.4.tgz",
      "integrity": "sha512-Wi6AXf0k0L7E2gteNsNHUs7UMwCIhsCTs6+tqQ5GPwVRWMaflqGec4Sd8n6+FNFDw9vGcReqk2KzBDhCa1DLYg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.52.4.tgz",
      "integrity": "sha512-dtBZYjDmCQ9hW+WgEkaffvRRCKm767wWhxsFW3Lw86VXz/uJRuD438/XvbZT//B96Vs8oTA8Q4A0AfHbrxP9zw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.52.4.tgz",
      "integrity": "sha512-1ox+GqgRWqaB1RnyZXL8PD6E5f7YyRUJYnCqKpNzxzP0TkaUh112NDrR9Tt+C8rJ4x5G9Mk8PQR3o7Ku2RKqKA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.52.4.tgz",
      "integrity": "sha512-8GKr640PdFNXwzIE0IrkMWUNUomILLkfeHjXBi/nUvFlpZP+FA8BKGKpacjW6OUUHaNI6sUURxR2U2g78FOHWQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.52.4.tgz",
      "integrity": "sha512-AIy/jdJ7WtJ/F6EcfOb2GjR9UweO0n43jNObQMb6oGxkYTfLcnN7vYYpG+CN3lLxrQkzWnMOoNSHTW54pgbVxw==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.52.4.tgz",
      "integrity": "sha512-UF9KfsH9yEam0UjTwAgdK0anlQ7c8/pWPU2yVjyWcF1I1thABt6WXE47cI71pGiZ8wGvxohBoLnxM04L/wj8mQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.52.4.tgz",
      "integrity": "sha512-bf9PtUa0u8IXDVxzRToFQKsNCRz9qLYfR/MpECxl4mRoWYjAeFjgxj1XdZr2M/GNVpT05p+LgQOHopYDlUu6/w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.19.19",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.19.tgz",
      "integrity": "sha512-pb1Uqj5WJP7wrcbLU7Ru4QtA0+3kAXrkutGiD26wUKzSMgNNaPARTUDQmElUXp64kh3cWdou3Q0C7qwwxqSFmg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/raf": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/@types/raf/-/raf-3.4.3.tgz",
      "integrity": "sha512-c4YAvMedbPZ5tEyxzQdMoOhhJ4RD3rngZIdwC2/qDN3d7JpEhB6fiBRKVY1lg5B7Wk+uPBjn5f39j1/2MY1oOw==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/@types/trusted-types": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
      "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "5.0.4",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-5.0.4.tgz",
      "integrity": "sha512-La0KD0vGkVkSk6K+piWDKRUyg8Rl5iAIKRMH0vMJI0Eg47bq1eOxmoObAaQG37WMW9MSyk7Cs8EIWwJC1PtzKA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.4",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.38",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.17.0"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/atob": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/atob/-/atob-2.1.2.tgz",
      "integrity": "sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg==",
      "license": "(MIT OR Apache-2.0)",
      "bin": {
        "atob": "bin/atob.js"
      },
      "engines": {
        "node": ">= 4.5.0"
      }
    },
    "node_modules/base64-arraybuffer": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/base64-arraybuffer/-/base64-arraybuffer-1.0.2.tgz",
      "integrity": "sha512-I3yl4r9QB5ZRY3XuJVEPfc2XhZO6YweFPI+UovAzn+8/hb3oJ6lnysaFcjVpkCPfVWFUDvoZ8kmVDP7WyRtYtQ==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">= 0.6.0"
      }
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.8.13",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.8.13.tgz",
      "integrity": "sha512-7s16KR8io8nIBWQyCYhmFhd+ebIzb9VKTzki+wOJXHTxTnV6+mFGH3+Jwn1zoKaY9/H9T/0BcKCZnzXljPnpSQ==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/browserslist": {
      "version": "4.26.3",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.26.3.tgz",
      "integrity": "sha512-lAUU+02RFBuCKQPj/P6NgjlbCnLBMp4UtgTx7vNHd3XSIJF87s9a5rA3aH2yw3GS9DqZAUbOtZdCCiZeVRqt0w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "baseline-browser-mapping": "^2.8.9",
        "caniuse-lite": "^1.0.30001746",
        "electron-to-chromium": "^1.5.227",
        "node-releases": "^2.0.21",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/btoa": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/btoa/-/btoa-1.2.1.tgz",
      "integrity": "sha512-SB4/MIGlsiVkMcHmT+pSmIPoNDoHg+7cMzmt3Uxt628MTz2487DKSqK/fuhFBrkuqrYv5UCEnACpF4dTFNKc/g==",
      "license": "(MIT OR Apache-2.0)",
      "bin": {
        "btoa": "bin/btoa.js"
      },
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001749",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001749.tgz",
      "integrity": "sha512-0rw2fJOmLfnzCRbkm8EyHL8SvI2Apu5UbnQuTsJ0ClgrH8hcwFooJ1s5R0EP8o8aVrFu8++ae29Kt9/gZAZp/Q==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/canvg": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/canvg/-/canvg-3.0.11.tgz",
      "integrity": "sha512-5ON+q7jCTgMp9cjpu4Jo6XbvfYwSB2Ow3kzHKfIyJfaCAOHLbdKPQqGKgfED/R5B+3TFFfe8pegYA+b423SRyA==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "@babel/runtime": "^7.12.5",
        "@types/raf": "^3.4.0",
        "core-js": "^3.8.3",
        "raf": "^3.4.1",
        "regenerator-runtime": "^0.13.7",
        "rgbcolor": "^1.0.1",
        "stackblur-canvas": "^2.0.0",
        "svg-pathdata": "^6.0.3"
      },
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/core-js": {
      "version": "3.45.1",
      "resolved": "https://registry.npmjs.org/core-js/-/core-js-3.45.1.tgz",
      "integrity": "sha512-L4NPsJlCfZsPeXukyzHFlg/i7IIVwHSItR0wg0FLNqYClJ4MQYTYLbC7EkjKYRLZF2iof2MUgN0EGy7MdQFChg==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/core-js"
      }
    },
    "node_modules/css-line-break": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/css-line-break/-/css-line-break-2.1.0.tgz",
      "integrity": "sha512-FHcKFCZcAha3LwfVBhCQbW2nCNbkZXn7KVUJcsT5/P8YmfsVja0FMPJr0B903j/E69HUphKiV9iQArX8SDYA4w==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "utrie": "^1.0.2"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/dompurify": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/dompurify/-/dompurify-3.2.7.tgz",
      "integrity": "sha512-WhL/YuveyGXJaerVlMYGWhvQswa7myDG17P7Vu65EWC05o8vfeNbvNf4d/BOvH99+ZW+LlQsc1GDKMa1vNK6dw==",
      "license": "(MPL-2.0 OR Apache-2.0)",
      "optional": true,
      "optionalDependencies": {
        "@types/trusted-types": "^2.0.7"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.233",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.233.tgz",
      "integrity": "sha512-iUdTQSf7EFXsDdQsp8MwJz5SVk4APEFqXU/S47OtQ0YLqacSwPXdZ5vRlMX3neb07Cy2vgioNuRnWUXFwuslkg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/fflate": {
      "version": "0.8.2",
      "resolved": "https://registry.npmjs.org/fflate/-/fflate-0.8.2.tgz",
      "integrity": "sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==",
      "license": "MIT"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/html2canvas": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/html2canvas/-/html2canvas-1.4.1.tgz",
      "integrity": "sha512-fPU6BHNpsyIhr8yyMpTLLxAbkaK8ArIBcmZIRiBLiDhjeqvXolaEmDGmELFuX9I4xDcaKKcJl+TKZLqruBbmWA==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "css-line-break": "^2.1.0",
        "text-segmentation": "^1.0.3"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jspdf": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/jspdf/-/jspdf-2.5.2.tgz",
      "integrity": "sha512-myeX9c+p7znDWPk0eTrujCzNjT+CXdXyk7YmJq5nD5V7uLLKmSXnlQ/Jn/kuo3X09Op70Apm0rQSnFWyGK8uEQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.2",
        "atob": "^2.1.2",
        "btoa": "^1.2.1",
        "fflate": "^0.8.1"
      },
      "optionalDependencies": {
        "canvg": "^3.0.6",
        "core-js": "^3.6.0",
        "dompurify": "^2.5.4",
        "html2canvas": "^1.0.0-rc.5"
      }
    },
    "node_modules/jspdf-autotable": {
      "version": "3.8.4",
      "resolved": "https://registry.npmjs.org/jspdf-autotable/-/jspdf-autotable-3.8.4.tgz",
      "integrity": "sha512-rSffGoBsJYX83iTRv8Ft7FhqfgEL2nLpGAIiqruEQQ3e4r0qdLFbPUB7N9HAle0I3XgpisvyW751VHCqKUVOgQ==",
      "license": "MIT",
      "peerDependencies": {
        "jspdf": "^2.5.1"
      }
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.23",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.23.tgz",
      "integrity": "sha512-cCmFDMSm26S6tQSDpBCg/NR8NENrVPhAJSf+XbxBG4rPFaaonlEoE9wHQmun+cls499TQGSb7ZyPBRlzgKfpeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/performance-now": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
      "integrity": "sha512-7EAHlyLHI56VEIdK57uwHdHKIaAGbnXPiw0yWbarQZOKaKpvUIgW0jWRVLiatnM+XXlSwsanIBH/hzGMJulMow==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/raf": {
      "version": "3.4.1",
      "resolved": "https://registry.npmjs.org/raf/-/raf-3.4.1.tgz",
      "integrity": "sha512-Sq4CW4QhwOHE8ucn6J34MqtZCeWFP2aQSmrlroYgqAV1PjStIhJXxYuTgUIfkEk7zTLjmIjLmU5q+fbD1NnOJA==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "performance-now": "^2.1.0"
      }
    },
    "node_modules/react": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react/-/react-18.3.1.tgz",
      "integrity": "sha512-wS+hAgJShR0KhEvPJArfuPVN1+Hz1t0Y6n5jLrGQbkb4urgPE/0Rve+1kMB1v/oWgHgm4WIcV+i7F2pTVj+2iQ==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.1.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "18.3.1",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-18.3.1.tgz",
      "integrity": "sha512-5m4nQKp+rZRb09LNH59GM4BxTh9251/ylbKIbpe7TpGxfJ+9kv6BLkLBXIjjspbgbnIBNqlI23tRnTWT0snUIw==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.1.0",
        "scheduler": "^0.23.2"
      },
      "peerDependencies": {
        "react": "^18.3.1"
      }
    },
    "node_modules/react-refresh": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.17.0.tgz",
      "integrity": "sha512-z6F7K9bV85EfseRCp2bzrpyQ0Gkw1uLoCel9XBVWPg/TjRj94SkJzUTGfOa4bs7iJvBWtQG0Wq7wnI0syw3EBQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/regenerator-runtime": {
      "version": "0.13.11",
      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.11.tgz",
      "integrity": "sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/rgbcolor": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/rgbcolor/-/rgbcolor-1.0.1.tgz",
      "integrity": "sha512-9aZLIrhRaD97sgVhtJOW6ckOEh6/GnvQtdVNfdZ6s67+3/XwLS9lBcQYzEEhYVeUowN7pRzMLsyGhK2i/xvWbw==",
      "license": "MIT OR SEE LICENSE IN FEEL-FREE.md",
      "optional": true,
      "engines": {
        "node": ">= 0.8.15"
      }
    },
    "node_modules/rollup": {
      "version": "4.52.4",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.52.4.tgz",
      "integrity": "sha512-CLEVl+MnPAiKh5pl4dEWSyMTpuflgNQiLGhMv8ezD5W/qP8AKvmYpCOKRRNOh7oRKnauBZ4SyeYkMS+1VSyKwQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.52.4",
        "@rollup/rollup-android-arm64": "4.52.4",
        "@rollup/rollup-darwin-arm64": "4.52.4",
        "@rollup/rollup-darwin-x64": "4.52.4",
        "@rollup/rollup-freebsd-arm64": "4.52.4",
        "@rollup/rollup-freebsd-x64": "4.52.4",
        "@rollup/rollup-linux-arm-gnueabihf": "4.52.4",
        "@rollup/rollup-linux-arm-musleabihf": "4.52.4",
        "@rollup/rollup-linux-arm64-gnu": "4.52.4",
        "@rollup/rollup-linux-arm64-musl": "4.52.4",
        "@rollup/rollup-linux-loong64-gnu": "4.52.4",
        "@rollup/rollup-linux-ppc64-gnu": "4.52.4",
        "@rollup/rollup-linux-riscv64-gnu": "4.52.4",
        "@rollup/rollup-linux-riscv64-musl": "4.52.4",
        "@rollup/rollup-linux-s390x-gnu": "4.52.4",
        "@rollup/rollup-linux-x64-gnu": "4.52.4",
        "@rollup/rollup-linux-x64-musl": "4.52.4",
        "@rollup/rollup-openharmony-arm64": "4.52.4",
        "@rollup/rollup-win32-arm64-msvc": "4.52.4",
        "@rollup/rollup-win32-ia32-msvc": "4.52.4",
        "@rollup/rollup-win32-x64-gnu": "4.52.4",
        "@rollup/rollup-win32-x64-msvc": "4.52.4",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/scheduler": {
      "version": "0.23.2",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.23.2.tgz",
      "integrity": "sha512-UOShsPwz7NrMUqhR6t0hWjFduvOzbtv7toDH1/hIrfRNIDBnnBWd0CwJTGvTpngVlmwGCdP9/Zl/tVrDqcuYzQ==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.1.0"
      }
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stackblur-canvas": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/stackblur-canvas/-/stackblur-canvas-2.7.0.tgz",
      "integrity": "sha512-yf7OENo23AGJhBriGx0QivY5JP6Y1HbrrDI6WLt6C5auYZXlQrheoY8hD4ibekFKz1HOfE48Ww8kMWMnJD/zcQ==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=0.1.14"
      }
    },
    "node_modules/svg-pathdata": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/svg-pathdata/-/svg-pathdata-6.0.3.tgz",
      "integrity": "sha512-qsjeeq5YjBZ5eMdFuUa4ZosMLxgr5RZ+F+Y1OrDhuOCEInRMA3x74XdBtggJcj9kOeInz0WE+LgCPDkZFlBYJw==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/text-segmentation": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/text-segmentation/-/text-segmentation-1.0.3.tgz",
      "integrity": "sha512-iOiPUo/BGnZ6+54OsWxZidGCsdU8YbE4PSpdPinp7DeMtUJNJBoJ/ouUSTJjHkh1KntHaltHl/gDs2FC4i5+Nw==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "utrie": "^1.0.2"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/utrie": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/utrie/-/utrie-1.0.2.tgz",
      "integrity": "sha512-1MLa5ouZiOmQzUbjbu9VmjLzn1QLXBhwpUa7kdLUQK+KQ5KA9I1vk5U4YHe/X2Ch7PYnJfWuWT+VbuxbGwljhw==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "base64-arraybuffer": "^1.0.2"
      }
    },
    "node_modules/vite": {
      "version": "5.4.20",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.20.tgz",
      "integrity": "sha512-j3lYzGC3P+B5Yfy/pfKNgVEg4+UtcIJcVRt2cDjIOmhLourAqPqf8P7acgxeiSgUB7E3p2P8/3gNIgDLpwzs4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    }
  }
}
--- END FILE: package-lock.json ---

--- START FILE: package.json ---
{
  "name": "sports-scoreboard-pro",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "jspdf": "^2.5.1",
    "jspdf-autotable": "^3.8.2",
    "react-dom": "^18.3.1",
    "react": "^18.3.1"
  },
  "devDependencies": {
    "@types/node": "^20.14.10",
    "@vitejs/plugin-react": "^5.0.4",
    "typescript": "^5.5.3",
    "vite": "^5.3.3"
  },
  "overrides": {
    "dompurify": "^3.1.5"
  }
}
--- END FILE: package.json ---

--- START FILE: README.md ---
# 🏀 Project: Iskor-App

<p align="center">
  <img width="1664" height="811" alt="image" src="https://github.com/user-attachments/assets/07f82c54-3d99-429b-a63e-affe267072ca" />
</p>

<p align="center">
  <strong>Turning Sports Matches into Legendary Showdowns.</strong>
</p>

<p align="center">
  A versatile, multi-sport scoreboard for Basketball, Soccer, and Volleyball — perfect for organizers, coaches, and streamers.
</p>

---

## 🏁 Overview

**Iskor-App** is a user-friendly, rule-based sports scoring tool for everyone — from event organizers to casual players. It enables users to manually score matches while automatically following each sport’s official rules.

Whether for tournaments, community games, or friendly matches, Iskor-App makes tracking scores organized, fair, and easy.

> ⚙️ Anyone can use this software to manage **manual scoring** in real-time while following each sport’s authentic rules.

> 💬 We’re open to **suggestions and feature ideas** from the community to make the app even better.

---

## 💡 Inspiration

The inspiration came from **Peeeweee**, who wanted a practical, no-fuss scoreboard for casual basketball, soccer, and volleyball games. Many players forget scores during friendly matches without referees — so **Iskor-App** was created to solve that problem. It’s a simple yet reliable solution for bringing structure and fairness to informal sports sessions.

---

## ✨ Key Features

* **🎮 Multi-Sport Support:** Basketball, Soccer, and Volleyball with rule-based scoring logic.
* **📊 Analytics Dashboard:** Track total matches, top teams, and high-scoring games.
* **🏅 Team Leaderboard:** See win/loss stats and performance summaries.
* **⚙️ Match Management:** Create, manage, and revisit your match history with ease.
* **🎨 Themes:** Choose from four sleek UI styles — Dark, Light, Coder, and Viola.
* **🧑‍🤝‍🧑 Team Customization:** Create teams with unique names and colors.
* **🖥️ Audience View:** Display a professional scoreboard for live viewing.
* **📁 Data Portability:** Export or back up match data and settings via JSON or PDF.

---

## 🖼️ Screenshots & Themes

### 🎨 Themes

|                                                                Viola                                                                |                                                                Coder                                                                |
| :---------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------: |
| <img width="1664" height="811" alt="image" src="https://github.com/user-attachments/assets/3292eff2-5868-4724-b571-cb2cb4b5e673" /> | <img width="1471" height="795" alt="image" src="https://github.com/user-attachments/assets/61e1d324-afd7-4dbb-a521-ee565e33569d" /> |
|                                                                Light                                                                |                                                                 Dark                                                                |
| <img width="1465" height="770" alt="image" src="https://github.com/user-attachments/assets/6715c6ba-901a-4a61-b318-5822fd37f93a" /> | <img width="1385" height="780" alt="image" src="https://github.com/user-attachments/assets/bad21b98-bea9-4e43-b169-202e5f3314c8" /> |

### 📸 Application in Action

|                                                              Dashboard                                                              |                                                              Analytics                                                              |
| :---------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------: |
| <img width="1622" height="913" alt="image" src="https://github.com/user-attachments/assets/d06ed878-40b3-4332-9870-377182bdf046" /> | <img width="1458" height="919" alt="image" src="https://github.com/user-attachments/assets/3d573896-c235-4daf-978a-cb5f8e1e29b7" /> |
|                                                             Match Setup                                                             |                                                            Match History                                                            |
| <img width="1096" height="766" alt="image" src="https://github.com/user-attachments/assets/5580d017-e484-458f-a29a-89e059815d1d" /> | <img width="1320" height="890" alt="image" src="https://github.com/user-attachments/assets/174a30a9-3b84-40ab-bf87-16114ee2ca7c" /> |
|                                                               Settings                                                              |                                                           Data Management                                                           |
| <img width="1175" height="601" alt="image" src="https://github.com/user-attachments/assets/2b276baf-77d7-4d3a-9379-456cc8f748be" /> | <img width="1313" height="679" alt="image" src="https://github.com/user-attachments/assets/920ade8d-3d64-48f1-8878-65bcba7e5416" /> |

---

## 🚀 Getting Started

### 🧩 Requirements

* Node.js **v18.0.0** or higher

### ⚙️ Installation

```bash
git clone https://github.com/your-username/project-iskor-app.git
cd project-iskor-app
npm install
npm run dev
```

Then open your browser and go to:

👉 **[http://localhost:3000](http://localhost:3000)**

---

## 🛠️ Tech Stack

* **Frontend:** React + TypeScript
* **Build Tool:** Vite
* **Styling:** Tailwind CSS
* **PDF Generation:** jsPDF + jspdf-autotable

---

## 🤝 Contributing

We welcome contributions! 💡
If you’d like to improve or expand **Iskor-App**, follow these steps:

1. **Fork** the repository
2. **Create a new branch**

   ```bash
   git checkout -b feature/YourFeatureName
   ```
3. **Commit your changes**

   ```bash
   git commit -m "Add YourFeatureName"
   ```
4. **Push your branch**

   ```bash
   git push origin feature/YourFeatureName
   ```
5. **Submit a Pull Request**

---

## 📄 License

This project is licensed under the **MIT License**.
See the [LICENSE](LICENSE) file for details.

---

<p align="center">
  Built with 🤖 by <strong>Paulo Delgado</strong> · Powered by <strong>React + Vite</strong>
</p>
--- END FILE: README.md ---

--- START FILE: src\App.tsx ---
import React, { useState, useCallback, useRef, useEffect } from 'react';
import type { MatchConfig, Theme, View, Match, SavedTeam, Settings, TeamStat } from './types';
import { GameStatus, Sport, Font, Layout as UILayout } from './types';
import { useGameLogic } from './hooks/useGameLogic';
import SetupScreen from './components/SetupScreen';
import Dashboard from './components/Dashboard';
import AudienceView from './components/AudienceView';
import MatchView from './components/MatchView';
import Layout from './components/layout/Layout';
import SettingsPage from './components/SettingsPage';
import LandingPage from './components/LandingPage';
import AnalyticsPage from './components/AnalyticsPage';
import MatchHistoryPage from './components/MatchHistoryPage';
import TeamsPage from './components/TeamsPage';
import { TEAM_COLORS } from './constants';
import { getDateFromId } from './utils';

const initialMatches: Match[] = [
  { id: '1', sport: Sport.Basketball, teamA: { name: 'Lakers', color: '#FDB927' }, teamB: { name: 'Warriors', color: '#006BB6' }, status: 'In Progress', durationMinutes: 12, durationSeconds: 0, periods: 4, gameMode: 'time' },
  { id: '2', sport: Sport.Soccer, teamA: { name: 'Real Madrid', color: '#FEBE10' }, teamB: { name: 'Barcelona', color: '#A50044' }, status: 'Finished', durationMinutes: 45, durationSeconds: 0, periods: 2, gameMode: 'time', finalScoreA: 6, finalScoreB: 4 },
  { id: '3', sport: Sport.Volleyball, teamA: { name: 'Brazil', color: '#009B3A' }, teamB: { name: 'USA', color: '#B31336' }, status: 'Upcoming', durationMinutes: 0, durationSeconds: 0, periods: 5, gameMode: 'time' },
  { id: '4', sport: Sport.Basketball, teamA: { name: 'Celtics', color: '#008348' }, teamB: { name: 'Heat', color: '#98002E' }, status: 'Finished', durationMinutes: 12, durationSeconds: 0, periods: 4, gameMode: 'time', finalScoreA: 9, finalScoreB: 6 },
  { id: '5', sport: Sport.Soccer, teamA: { name: 'Man United', color: '#DA291C' }, teamB: { name: 'Liverpool', color: '#C8102E' }, status: 'Upcoming', durationMinutes: 45, durationSeconds: 0, periods: 2, gameMode: 'time' },
  { id: '6', sport: Sport.Volleyball, teamA: { name: 'Poland', color: '#DC143C' }, teamB: { name: 'Italy', color: '#008C45' }, status: 'In Progress', durationMinutes: 0, durationSeconds: 0, periods: 5, gameMode: 'time' },
];

const App: React.FC = () => {
    const [view, setView] = useState<View>('landing');
    const [settings, setSettings] = useState<Settings>(() => {
        const saved = localStorage.getItem('scoreboardSettings');
        const defaultSettings: Settings = {
            theme: 'dark',
            font: Font.Display,
            layout: UILayout.Wide,
            defaultSport: Sport.Basketball,
            defaultTeamAColor: TEAM_COLORS[0],
            defaultTeamBColor: TEAM_COLORS[1],
        };
        try {
            if (saved) {
                return { ...defaultSettings, ...JSON.parse(saved) };
            }
            const legacyTheme = localStorage.getItem('theme') as Theme | null;
            if (legacyTheme) {
                defaultSettings.theme = legacyTheme;
                localStorage.removeItem('theme');
            }
        } catch (error) {
            console.error("Could not parse settings from localStorage", error);
        }
        return defaultSettings;
    });

    const [matchConfig, setMatchConfig] = useState<MatchConfig | null>(null);
    const [activeMatchId, setActiveMatchId] = useState<string | null>(null);
    const [matches, setMatches] = useState<Match[]>(() => {
        try {
            const savedMatches = localStorage.getItem('matches');
            return savedMatches ? JSON.parse(savedMatches) : initialMatches;
        } catch (error) {
            console.error("Could not parse matches from localStorage", error);
            return initialMatches;
        }
    });
    
    const [savedTeams, setSavedTeams] = useState<SavedTeam[]>(() => {
        try {
            const storedTeams = localStorage.getItem('savedTeams');
            return storedTeams ? JSON.parse(storedTeams) : [];
        } catch (error) {
            console.error("Could not parse saved teams from localStorage", error);
            return [];
        }
    });

    const [searchQuery, setSearchQuery] = useState('');
    const [isExportingPdf, setIsExportingPdf] = useState(false);


    const channel = useRef(new BroadcastChannel('scoreboard-pro-updates'));

    const { gameState, time, isRunning, actions } = useGameLogic(matchConfig, activeMatchId);

    useEffect(() => {
        localStorage.setItem('matches', JSON.stringify(matches));
    }, [matches]);
    
     useEffect(() => {
        localStorage.setItem('savedTeams', JSON.stringify(savedTeams));
    }, [savedTeams]);

    useEffect(() => {
        localStorage.setItem('scoreboardSettings', JSON.stringify(settings));
        const root = window.document.documentElement;
        root.classList.remove('light', 'dark');
        root.classList.add(settings.theme);
    }, [settings]);

    const updateSettings = (newSettings: Partial<Settings>) => {
        setSettings(prev => ({ ...prev, ...newSettings }));
    };

    const navigateTo = (newView: View) => {
      setSearchQuery(''); // Clear search when navigating
      setView(newView);
    };

    const handleLeaveMatch = () => {
        setMatchConfig(null);
        setActiveMatchId(null);
        navigateTo('dashboard');
    };

    const setupMatchForControl = (match: Match) => {
         const config: MatchConfig = {
            sport: match.sport,
            teamA: match.teamA,
            teamB: match.teamB,
            durationMinutes: match.durationMinutes,
            durationSeconds: match.durationSeconds,
            periods: match.periods,
            gameMode: match.gameMode,
            targetScore: match.targetScore,
        };
        setMatchConfig(config);
        setActiveMatchId(match.id);
    };

    const handleManageMatch = (match: Match) => {
        setupMatchForControl(match);
        navigateTo('match');
    };
    
    const handleGoToAudienceView = (match: Match) => {
        setActiveMatchId(match.id);
        setMatchConfig({
             sport: match.sport,
            teamA: match.teamA,
            teamB: match.teamB,
            durationMinutes: match.durationMinutes,
            durationSeconds: match.durationSeconds,
            periods: match.periods,
            gameMode: match.gameMode,
            targetScore: match.targetScore,
        });
        navigateTo('audience');
    };

    const handleMatchStart = (config: MatchConfig) => {
        const newMatch: Match = {
            ...config,
            id: `match-${Date.now()}`,
            status: 'Upcoming',
        };
        setMatches(prev => [...prev, newMatch]);
        setMatchConfig(config);
        setActiveMatchId(newMatch.id);
        navigateTo('match');
    };

    const handleDeleteMatch = (matchId: string) => {
        setMatches(prev => prev.filter(match => match.id !== matchId));
        localStorage.removeItem(`match-${matchId}`);
    };

    const handleArchiveMatch = (matchId: string) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isArchived: true } : match
            )
        );
    };
    
    const handleToggleCompleteMatch = (matchId: string, isCompleted: boolean) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isCompleted } : match
            )
        );
    };

    const handleUnarchiveMatch = (matchId: string) => {
        setMatches(prev =>
            prev.map(match =>
                match.id === matchId ? { ...match, isArchived: false } : match
            )
        );
    };
    
    const handleUpdateMatchConfig = (matchId: string, newConfig: Partial<MatchConfig>) => {
        let updatedMatch: Match | undefined;
        setMatches(prev =>
            prev.map(match => {
                if (match.id === matchId) {
                    updatedMatch = { ...match, ...newConfig };
                    return updatedMatch;
                }
                return match;
            })
        );

        if (activeMatchId === matchId && updatedMatch) {
            setMatchConfig(updatedMatch);
        }
    };
    
    const handleSaveTeam = (team: Omit<SavedTeam, 'id'> & { id?: string }) => {
        if (team.id) {
            setSavedTeams(prev => prev.map(t => t.id === team.id ? { ...t, name: team.name, color: team.color, sport: team.sport } : t));
        } else {
            const newTeam = { ...team, id: `team-${Date.now()}` };
            setSavedTeams(prev => [...prev, newTeam]);
            return newTeam; // Return the new team to be auto-selected
        }
    };

    const handleDeleteTeam = (teamId: string) => {
        setSavedTeams(prev => prev.filter(t => t.id !== teamId));
    };

    const handleExportData = () => {
        try {
            const dataToExport = {
                matches: JSON.parse(localStorage.getItem('matches') || '[]'),
                savedTeams: JSON.parse(localStorage.getItem('savedTeams') || '[]'),
                settings: JSON.parse(localStorage.getItem('scoreboardSettings') || '{}'),
            };
            const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(JSON.stringify(dataToExport, null, 2))}`;
            const link = document.createElement("a");
            link.href = jsonString;
            link.download = `scoreboard_pro_backup_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        } catch (error) {
            console.error("Failed to export data:", error);
            alert("Error exporting data.");
        }
    };

    const handleExportPdf = async () => {
        setIsExportingPdf(true);
        try {
            const { default: jsPDF } = await import('jspdf');
            const { default: autoTable } = await import('jspdf-autotable');

            const doc = new jsPDF();
            const pageHeight = doc.internal.pageSize.height;
            let finalY = 0;

            doc.setFontSize(22).setFont('helvetica', 'bold');
            doc.text('Project: Iskor-App', 105, 20, { align: 'center' });
            doc.setFontSize(16).setFont('helvetica', 'normal');
            doc.text('Data Export', 105, 30, { align: 'center' });
            doc.setFontSize(12);
            doc.text(`Export Date: ${new Date().toLocaleDateString()}`, 105, 40, { align: 'center' });

            const tableOptions = {
                startY: 60,
                headStyles: { fillColor: '#16A3B8' },
                theme: 'grid',
                didDrawPage: (data: any) => { finalY = data.cursor.y; }
            };

            doc.setFontSize(18).setFont('helvetica', 'bold');
            doc.text('Application Settings', 14, tableOptions.startY - 10);
            autoTable(doc, { ...tableOptions, head: [['Setting', 'Value']], body: [
                ['Theme', settings.theme], ['Default Sport', settings.defaultSport],
                ['Audience View Font', settings.font], ['Audience View Layout', settings.layout],
                ['Default Team A Color', settings.defaultTeamAColor], ['Default Team B Color', settings.defaultTeamBColor],
            ]});

            const checkNewPage = (yPos: number) => {
                if (yPos + 40 > pageHeight) { doc.addPage(); return 30; }
                return yPos + 20;
            };

            let currentY = checkNewPage(finalY);
            
            const finishedMatches = matches.filter((m): m is Match & { finalScoreA: number; finalScoreB: number } => 
                m.status === 'Finished' && typeof m.finalScoreA === 'number' && typeof m.finalScoreB === 'number'
            );

            if (finishedMatches.length > 0) {
                doc.setFontSize(18).setFont('helvetica', 'bold');
                doc.text('Analytics Overview', 14, currentY - 10);

                const sportCounts = finishedMatches.reduce((acc: Record<Sport, number>, match) => {
                    acc[match.sport] = (acc[match.sport] || 0) + 1;
                    return acc;
                }, {} as Record<Sport, number>);

                const maxCount = Math.max(0, ...Object.values(sportCounts) as number[]);
                const mostPlayedSportName = Object.entries(sportCounts)
                    .filter(([, count]) => count === maxCount)
                    .map(([sport]) => sport)
                    .join(', ');

                const highestGamesBySport = (Object.values(Sport) as Sport[]).reduce((acc, sport: Sport) => {
                    const sportMatches = finishedMatches.filter(m => m.sport === sport);
                    if (sportMatches.length > 0) {
                        acc[sport] = sportMatches.reduce((max, match) => {
                            const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
                            return totalScore > max.total ? { total: totalScore } : max;
                        }, { total: (sportMatches[0].finalScoreA ?? 0) + (sportMatches[0].finalScoreB ?? 0) });
                    } else {
                        acc[sport] = { total: 0 };
                    }
                    return acc;
                }, {} as Record<Sport, { total: number }>);

                const highestScoresText = (Object.values(Sport) as Sport[]).map(sport => `${sport}: ${highestGamesBySport[sport]?.total ?? '0'}`).join('\n');

                const mostDecisiveVictoriesBySport = (Object.values(Sport) as Sport[]).reduce((acc, sport: Sport) => {
                    const sportMatches = finishedMatches.filter(m => m.sport === sport);
                    if (sportMatches.length > 0) {
                        acc[sport] = sportMatches.reduce((max, match) => {
                            const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
                            return diff > max.diff ? { diff } : max;
                        }, { diff: Math.abs((sportMatches[0].finalScoreA ?? 0) - (sportMatches[0].finalScoreB ?? 0)) });
                    } else {
                        acc[sport] = { diff: 0 };
                    }
                    return acc;
                }, {} as Record<Sport, { diff: number }>);
                
                const mostDecisiveText = (Object.values(Sport) as Sport[]).map(sport => `${sport}: +${mostDecisiveVictoriesBySport[sport]?.diff ?? '0'}`).join('\n');

                autoTable(doc, {
                    ...tableOptions,
                    startY: currentY,
                    head: [['Metric', 'Value']],
                    body: [
                        ['Total Matches Played', finishedMatches.length.toString()],
                        ['Most Played Sport(s)', mostPlayedSportName],
                        ['Highest Scoring Games (Total Points)', highestScoresText],
                        ['Most Decisive Victories (Point Diff)', mostDecisiveText],
                    ],
                     didParseCell: (data) => {
                        if (data.row.index >= 2) {
                            (data.cell.styles as any).cellWidth = 'wrap';
                        }
                    },
                });

                currentY = checkNewPage(finalY);
            }
            
            if (savedTeams.length > 0) {
              doc.setFontSize(18).setFont('helvetica', 'bold');
              doc.text('Saved Teams', 14, currentY - 10);
              autoTable(doc, { ...tableOptions, startY: currentY, head: [['Name', 'Color', 'Sport Association']], body: savedTeams.map(team => [team.name, team.color, team.sport || 'Universal'])});
              currentY = checkNewPage(finalY);
            }
            
            if (finishedMatches.length > 0) {
                const teamStats = finishedMatches.reduce((acc, match) => {
                    const teams = [match.teamA, match.teamB];
                    const scores = [match.finalScoreA, match.finalScoreB];
                    for (let i = 0; i < teams.length; i++) {
                        const team = teams[i];
                        if (!acc[team.name]) acc[team.name] = { wins: 0, losses: 0, ties: 0, totalGames: 0, teamConfig: team };
                        acc[team.name].totalGames++;
                        if (scores[i] > scores[1 - i]) acc[team.name].wins++;
                        else if (scores[i] < scores[1 - i]) acc[team.name].losses++;
                        else acc[team.name].ties++;
                    }
                    return acc;
                }, {} as Record<string, TeamStat>);

// FIX: Add type assertion to Object.values to prevent potential type errors in strict mode.
                const leaderboard = (Object.values(teamStats) as TeamStat[]).map((team: TeamStat) => ({
                    ...team,
                    winRate: team.totalGames > 0 ? (team.wins / team.totalGames * 100) : 0,
                })).sort((a, b) => b.wins - a.wins || b.winRate - a.winRate);
                
                const top5Teams = leaderboard.slice(0, 5);

                if (top5Teams.length > 0) {
                    doc.setFontSize(18).setFont('helvetica', 'bold');
                    doc.text('Top 5 Teams Leaderboard', 14, currentY - 10);
                    autoTable(doc, {
                        ...tableOptions, startY: currentY,
                        head: [['#', 'Team', 'W', 'L', 'GP', 'Win %']],
                        body: top5Teams.map((team, index) => [
                            index + 1, team.teamConfig.name, team.wins, team.losses, team.totalGames, `${team.winRate.toFixed(1)}%`
                        ]),
                        didParseCell: (data) => {
                            if (data.section === 'body' && data.column.index === 1) {
                                const teamStat = top5Teams[data.row.index];
                                if (teamStat) (data.cell.styles as any).textColor = teamStat.teamConfig.color;
                            }
                        }
                    });
                    currentY = checkNewPage(finalY);
                }

                doc.setFontSize(18).setFont('helvetica', 'bold');
                doc.text('Completed Match History', 14, currentY - 10);
                autoTable(doc, {
                    ...tableOptions, startY: currentY,
                    head: [['Date', 'Sport', 'Matchup', 'Final Score', 'Winner']],
                    body: finishedMatches.map(match => {
                        const winner = (match.finalScoreA ?? 0) > (match.finalScoreB ?? 0) ? match.teamA.name : ((match.finalScoreB ?? 0) > (match.finalScoreA ?? 0) ? match.teamB.name : 'Tie');
                        return [getDateFromId(match.id, { year: 'numeric', month: 'short', day: 'numeric' }), match.sport, `${match.teamA.name} vs ${match.teamB.name}`, `${match.finalScoreA} - ${match.finalScoreB}`, winner];
                    }),
                });
            }

            doc.save(`scoreboard_pro_export_${new Date().toISOString().split('T')[0]}.pdf`);

        } catch (error) {
            console.error("Failed to export PDF:", error);
            alert("Error exporting PDF. Check console for details.");
        } finally {
            setIsExportingPdf(false);
        }
    };

    const handleImportData = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const text = e.target?.result;
                if (typeof text !== 'string') throw new Error("File is not readable.");
                const data = JSON.parse(text);
                if (data.matches && data.savedTeams && data.settings) {
                    if (window.confirm("Are you sure you want to import this data? This will overwrite all your current matches, teams, and settings.")) {
                        setMatches(data.matches);
                        setSavedTeams(data.savedTeams);
                        setSettings(data.settings);
                        alert("Data imported successfully!");
                        navigateTo('dashboard');
                    }
                } else {
                    throw new Error("Invalid backup file format. The file must contain 'matches', 'savedTeams', and 'settings' keys.");
                }
            } catch (error) {
                alert(`Error importing data: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        };
        reader.readAsText(file);
    };

    const handleClearData = () => {
        if (window.prompt('This action is irreversible and will delete all your matches, teams, and settings. To confirm, please type "DELETE" below.') === 'DELETE') {
            localStorage.removeItem('matches');
            localStorage.removeItem('savedTeams');
            localStorage.removeItem('scoreboardSettings');
            window.location.reload();
        }
    };

    useEffect(() => {
        if (view === 'match' && activeMatchId && gameState) {
            const dataToStore = { gameState, time };
            localStorage.setItem(`match-${activeMatchId}`, JSON.stringify(dataToStore));
            channel.current.postMessage({ matchId: activeMatchId });
        }
    }, [gameState, time, view, activeMatchId]);

    useEffect(() => {
        if (!activeMatchId || !gameState?.status) return;

        const newStatus = (() => {
            switch (gameState.status) {
                case GameStatus.InProgress:
                case GameStatus.Paused:
                case GameStatus.PeriodBreak:
                    return 'In Progress';
                case GameStatus.Finished:
                    return 'Finished';
                case GameStatus.NotStarted:
                default:
                    return 'Upcoming';
            }
        })();

        setMatches(prevMatches =>
            prevMatches.map(match => {
                if (match.id === activeMatchId) {
                    const updatedMatch: Match = { ...match, status: newStatus };
                    if (newStatus === 'Finished' && gameState) {
                        updatedMatch.finalScoreA = gameState.teamA.score;
                        updatedMatch.finalScoreB = gameState.teamB.score;
                        updatedMatch.periodScores = gameState.periodScores;
                    }
                    return updatedMatch;
                }
                return match;
            })
        );
    }, [gameState?.status, activeMatchId, gameState]);

    const renderView = () => {
        const handleCreateMatch = () => navigateTo('setup');
        const handleGoToHistory = () => navigateTo('history');
        const dashboardProps = {
            matches,
            onManageMatch: handleManageMatch,
            onGoToAudienceView: handleGoToAudienceView,
            onCreateMatch: handleCreateMatch,
            onDeleteMatch: handleDeleteMatch,
            onArchiveMatch: handleArchiveMatch,
            onUnarchiveMatch: handleUnarchiveMatch,
            onGoToHistory: handleGoToHistory,
            onToggleCompleteMatch: handleToggleCompleteMatch,
            searchQuery
        };

        switch (view) {
            case 'dashboard':
                return <Dashboard {...dashboardProps} />;
            case 'setup':
                return <SetupScreen onStartMatch={handleMatchStart} onBack={() => navigateTo('dashboard')} savedTeams={savedTeams} onSaveTeam={handleSaveTeam} defaultSport={settings.defaultSport} defaultTeamAColor={settings.defaultTeamAColor} defaultTeamBColor={settings.defaultTeamBColor} />;
            case 'settings':
                return <SettingsPage settings={settings} updateSettings={updateSettings} onExportData={handleExportData} onImportData={handleImportData} onClearData={handleClearData} onExportPdf={handleExportPdf} isExportingPdf={isExportingPdf} />;
            case 'analytics':
                return <AnalyticsPage matches={matches} />;
            case 'history':
                return <MatchHistoryPage matches={matches} />;
            case 'teams':
                return <TeamsPage savedTeams={savedTeams} onSaveTeam={handleSaveTeam} onDeleteTeam={handleDeleteTeam} searchQuery={searchQuery} />;
            case 'match':
                if (matchConfig && gameState && activeMatchId) {
                    const activeMatch = matches.find(m => m.id === activeMatchId);
                    if (activeMatch) {
                        return <MatchView
                            match={activeMatch}
                            matchConfig={matchConfig}
                            gameState={gameState}
                            clock={{ time, isRunning }}
                            actions={actions}
                            onLeaveMatch={handleLeaveMatch}
                            activeMatchId={activeMatchId}
                            onUpdateMatchConfig={(newConfig) => handleUpdateMatchConfig(activeMatchId, newConfig)}
                        />;
                    }
                }
                return <Dashboard {...dashboardProps} />;
            default:
                return <Dashboard {...dashboardProps} />;
        }
    };
    
    if (view === 'landing') {
        return <LandingPage onGetStarted={() => navigateTo('dashboard')} />;
    }
    
    if (view === 'audience' && matchConfig && activeMatchId) {
        return <AudienceView config={matchConfig} matchId={activeMatchId} onExit={() => navigateTo('dashboard')} initialTheme={settings.theme} />;
    }

    return (
      <Layout 
        activeView={view}
        navigateTo={navigateTo}
        theme={settings.theme}
        toggleTheme={() => updateSettings({ theme: settings.theme === 'dark' ? 'light' : 'dark' })}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
      >
        {renderView()}
      </Layout>
    );
};

export default App;
--- END FILE: src\App.tsx ---

--- START FILE: src\components\AnalyticsPage.tsx ---



import React, { useMemo, useState, useEffect, useRef } from 'react';
import type { Match, TeamConfig, TeamStat } from '../types';
import { Sport } from '../types';
import ListIcon from './icons/ListIcon';
import FireIcon from './icons/FireIcon';
import TrendingUpIcon from './icons/TrendingUpIcon';
import ChartBarIcon from './icons/ChartBarIcon';
import SparkleIcon from './icons/SparkleIcon';
import TeamDetailModal from './TeamDetailModal';
import DonutChart from './charts/DonutChart';
import BarChart from './charts/BarChart';
import { GoogleGenAI } from '@google/genai';
import TotalMatchesModal from './TotalMatchesModal';
import MostPlayedSportModal from './MostPlayedSportModal';
import HighestScoringGamesModal from './HighestScoringGamesModal';
import SportIcon from './SportIcon';
import MostDecisiveVictoryModal from './MostDecisiveVictoryModal';


interface AnalyticsPageProps {
  matches: Match[];
}

const easeOutQuad = (t: number) => t * (2 - t);

const useCountUp = (end: number = 0, duration = 1500) => {
    const [count, setCount] = useState(0);
    const animationFrameRef = useRef<number | null>(null);

    useEffect(() => {
        let startTime: number | null = null;
        
        const animate = (timestamp: number) => {
            if (!startTime) {
                startTime = timestamp;
            }
            
            const progress = timestamp - startTime;
            const percentage = Math.min(progress / duration, 1);
            const easedPercentage = easeOutQuad(percentage);
            
            const currentCount = Math.round(end * easedPercentage);
            setCount(currentCount);
            
            if (progress < duration) {
                animationFrameRef.current = requestAnimationFrame(animate);
            } else {
                setCount(end); // Ensure it ends on the exact value
            }
        };

        // Reset count to 0 to start animation from the beginning when 'end' value changes
        setCount(0);
        animationFrameRef.current = requestAnimationFrame(animate);

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [end, duration]);
    
    return count;
};

const useTypewriter = (text: string, speed = 30) => {
    const [displayText, setDisplayText] = useState('');
    useEffect(() => {
        if (!text) {
            setDisplayText('');
            return;
        };
        
        let i = 0;
        setDisplayText('');
        const typingInterval = setInterval(() => {
            if (i < text.length) {
                setDisplayText(prev => prev + text.charAt(i));
                i++;
            } else {
                clearInterval(typingInterval);
            }
        }, speed);

        return () => clearInterval(typingInterval);
    }, [text, speed]);

    return displayText;
};

interface KpiCardProps {
    icon: React.ReactNode;
    title: string;
    value?: string | number;
    children?: React.ReactNode;
    description: React.ReactNode;
    isCounting?: boolean;
    prefix?: string;
    suffix?: string;
}

const KpiCard: React.FC<KpiCardProps> = ({ icon, title, value, children, description, isCounting = false, prefix = '', suffix = '' }) => {
    const endValueForCountUp = parseFloat(String(value)) || 0;
    const animatedValue = useCountUp(endValueForCountUp, 1500);
    const displayValue = isCounting ? `${prefix}${animatedValue}${suffix}` : value;

    const valueIsString = typeof displayValue === 'string';
    // Adjust font size based on string length to prevent overflow and keep it looking good.
    const valueSizeClass = valueIsString && displayValue.length > 20 
        ? 'text-lg' 
        : valueIsString && displayValue.length > 12 
        ? 'text-xl' 
        : 'text-2xl';

    return (
        <div className="bg-light-card dark:bg-dark-card techy-bg p-6 rounded-xl shadow-sm flex items-start gap-4 card-glow-on-hover h-full">
            <div className="bg-brand-blue/10 text-brand-blue p-3 rounded-lg">
                {icon}
            </div>
            <div className="flex-1">
                <p className="text-sm font-semibold text-light-text-muted dark:text-dark-text-muted">{title}</p>
                {children ? (
                    <div className="mt-1">{children}</div>
                ) : (
                    <p className={`${valueSizeClass} font-bold font-display break-words`}>{displayValue}</p>
                )}
                <p className="text-xs text-light-text-muted dark:text-dark-text-muted">{description}</p>
            </div>
        </div>
    );
};

const AnalyticsPage: React.FC<AnalyticsPageProps> = ({ matches }) => {
    const [selectedSport, setSelectedSport] = useState<Sport | 'All'>('All');
    const [aiSummary, setAiSummary] = useState('');
    const [isGenerating, setIsGenerating] = useState(false);
    const [generationError, setGenerationError] = useState('');
    const [selectedTeam, setSelectedTeam] = useState<TeamStat | null>(null);
    const [isTotalMatchesModalOpen, setIsTotalMatchesModalOpen] = useState(false);
    const [isMostPlayedSportModalOpen, setIsMostPlayedSportModalOpen] = useState(false);
    const [isHighestScoringGamesModalOpen, setIsHighestScoringGamesModalOpen] = useState(false);
    const [isMostDecisiveVictoryModalOpen, setIsMostDecisiveVictoryModalOpen] = useState(false);
    
    const allFinishedMatches = useMemo<(Match & { finalScoreA: number; finalScoreB: number; })[]>(() => 
        matches.filter((m): m is Match & { finalScoreA: number; finalScoreB: number } =>
            m.status === 'Finished' && typeof m.finalScoreA === 'number' && typeof m.finalScoreB === 'number'
        )
    , [matches]);

    const finishedMatches = useMemo<(Match & { finalScoreA: number; finalScoreB: number; })[]>(() => {
        if (selectedSport === 'All') {
            return allFinishedMatches;
        }
        return allFinishedMatches.filter(m => m.sport === selectedSport);
    }, [allFinishedMatches, selectedSport]);


    const stats = useMemo(() => {
        if (allFinishedMatches.length === 0) return null;

        const sportCounts = allFinishedMatches
            .reduce((acc: Record<Sport, number>, match) => {
                acc[match.sport] = (acc[match.sport] || 0) + 1;
                return acc;
            }, {} as Record<Sport, number>);

        const mostPlayedSportNames = (() => {
            if (Object.keys(sportCounts).length === 0) return ['N/A'];
            // Coerce to number[] to ensure type safety with Math.max in strict mode.
            const maxCount = Math.max(0, ...Object.values(sportCounts) as number[]);
            return Object.entries(sportCounts)
                .filter(([, count]) => count === maxCount)
                .map(([sport]) => sport);
        })();

        const mostPlayedSportName = mostPlayedSportNames.join(', ');
        
        const highestScoringGame = finishedMatches.reduce((max: { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
            const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
            return totalScore > max.total ? { match, total: totalScore } : max;
        }, { match: null, total: 0 });

        const mostDecisiveVictory = finishedMatches.reduce((max: { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
            const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
            return diff > max.diff ? { match, diff } : max;
        }, { match: null, diff: 0 });

        const matchesBySport = allFinishedMatches.reduce((acc: Record<Sport, number>, match) => {
            acc[match.sport] = (acc[match.sport] || 0) + 1;
            return acc;
        }, {} as Record<Sport, number>);

        const createLeaderboard = (matchesForLeaderboard: (Match & { finalScoreA: number; finalScoreB: number; })[]) => {
            const teamStats = matchesForLeaderboard.reduce((acc: Record<string, TeamStat>, match: (Match & { finalScoreA: number; finalScoreB: number; })) => {
                const { teamA, teamB, finalScoreA, finalScoreB } = match;
                const teams = [teamA, teamB];
                const scores = [finalScoreA ?? 0, finalScoreB ?? 0];

                for (let i = 0; i < teams.length; i++) {
                    const team = teams[i];
                    if (!acc[team.name]) {
                        acc[team.name] = { wins: 0, losses: 0, ties: 0, totalGames: 0, teamConfig: team };
                    }
                    acc[team.name].totalGames++;
                    if (scores[i] > scores[1 - i]) {
                        acc[team.name].wins++;
                    } else if (scores[i] < scores[1 - i]) {
                        acc[team.name].losses++;
                    } else {
                        acc[team.name].ties++;
                    }
                }
                return acc;
            }, {} as Record<string, TeamStat>);

            // FIX: In a strict TypeScript environment, `Object.values` on a record can return `unknown[]`.
            // Added `as TeamStat[]` to assert the correct type, resolving the error where `team` was inferred as `unknown`.
            return (Object.values(teamStats) as TeamStat[])
                .map((team: TeamStat) => ({
                    ...team,
                    winRate: team.totalGames > 0 ? (team.wins / team.totalGames * 100) : 0,
                }))
                .sort((a, b) => b.wins - a.wins || b.winRate - a.winRate);
        };

        const leaderboard = createLeaderboard(finishedMatches);

        const calculateHighestScores = (filteredMatches: typeof allFinishedMatches) => {
            return (Object.values(Sport) as Sport[]).reduce((acc: Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }>, sport: Sport) => {
                const sportMatches = filteredMatches.filter(m => m.sport === sport);
                if (sportMatches.length > 0) {
                    acc[sport] = sportMatches.reduce((max, match) => {
                        const totalScore = (match.finalScoreA ?? 0) + (match.finalScoreB ?? 0);
                        return totalScore > max.total ? { match, total: totalScore } : max;
                    }, { match: sportMatches[0], total: (sportMatches[0].finalScoreA ?? 0) + (sportMatches[0].finalScoreB ?? 0) });
                } else {
                    acc[sport] = { match: null, total: 0 };
                }
                return acc;
            }, {} as Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; total: number }>);
        };
        
        const calculateMostDecisive = (filteredMatches: typeof allFinishedMatches) => {
            return (Object.values(Sport) as Sport[]).reduce((acc: Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }>, sport: Sport) => {
                const sportMatches = filteredMatches.filter(m => m.sport === sport);
                if (sportMatches.length > 0) {
                    acc[sport] = sportMatches.reduce((max, match) => {
                        const diff = Math.abs((match.finalScoreA ?? 0) - (match.finalScoreB ?? 0));
                        return diff > max.diff ? { match, diff } : max;
                    }, { match: sportMatches[0], diff: Math.abs((sportMatches[0].finalScoreA ?? 0) - (sportMatches[0].finalScoreB ?? 0)) });
                } else {
                    acc[sport] = { match: null, diff: 0 };
                }
                return acc;
            }, {} as Record<Sport, { match: (Match & { finalScoreA: number; finalScoreB: number; }) | null; diff: number }>);
        };
        
        const timeBasedMatches = allFinishedMatches.filter(m => (m.gameMode || 'time') === 'time');
        const scoreBasedMatches = allFinishedMatches.filter(m => m.gameMode === 'score');

        const timeBasedLeaderboard = createLeaderboard(
            selectedSport === 'All' ? timeBasedMatches : timeBasedMatches.filter(m => m.sport === selectedSport)
        );
        const scoreBasedLeaderboard = createLeaderboard(
            selectedSport === 'All' ? scoreBasedMatches : scoreBasedMatches.filter(m => m.sport === selectedSport)
        );


        return { 
            kpis: {mostPlayedSportName, highestScoringGame, mostDecisiveVictory}, 
            matchesBySport, 
            leaderboard, 
            highestGamesBySport: calculateHighestScores(allFinishedMatches), 
            mostDecisiveVictoriesBySport: calculateMostDecisive(allFinishedMatches),
            highestGamesBySportTime: calculateHighestScores(timeBasedMatches),
            highestGamesBySportScore: calculateHighestScores(scoreBasedMatches),
            mostDecisiveVictoriesBySportTime: calculateMostDecisive(timeBasedMatches),
            mostDecisiveVictoriesBySportScore: calculateMostDecisive(scoreBasedMatches),
            timeBasedLeaderboard,
            scoreBasedLeaderboard,
        };

    }, [allFinishedMatches, finishedMatches, selectedSport]);
    
    const animatedSummary = useTypewriter(aiSummary);

    const handleGenerateSummary = async () => {
        if (!stats) return;
        setIsGenerating(true);
        setGenerationError('');
        setAiSummary('');

        try {
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
             const dataForPrompt = {
                overallStats: stats.kpis,
                timeBasedHighlights: {
                    leaderboard: stats.timeBasedLeaderboard.slice(0, 3),
                    highestScoringGames: stats.highestGamesBySportTime,
                    mostDecisiveVictories: stats.mostDecisiveVictoriesBySportTime,
                },
                scoreBasedHighlights: {
                    leaderboard: stats.scoreBasedLeaderboard.slice(0, 3),
                    highestScoringGames: stats.highestGamesBySportScore,
                    mostDecisiveVictories: stats.mostDecisiveVictoriesBySportScore,
                }
            };

            const summaryPrompt = `
You are a sports analyst. Based on the following JSON data of completed matches for ${selectedSport === 'All' ? 'all sports' : selectedSport}, provide a short and engaging summary of the key analytics.

Your summary should be structured into three parts:
1. An overall summary of the most played sports and standout matches across all game modes.
2. Specific insights for 'Time-based' games. Mention the top-performing teams and any notable high-scoring games or decisive victories.
3. Specific insights for 'Score-based' games, similarly highlighting top teams and record-breaking matches.

Pay special attention to any significant differences in performance or game dynamics between these modes. For example, in Volleyball, time-based games might have different score patterns than score-based games. Keep the analysis concise and easy to read.

Format the response as plain text paragraphs.

Data:
${JSON.stringify(dataForPrompt, null, 2)}
            `;
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: summaryPrompt,
            });
            setAiSummary(response.text);
        } catch (error) {
            console.error("Error generating AI summary:", error);
            const errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
            if (errorMessage.includes('API_KEY_DOMAIN') || errorMessage.includes('API key not valid')) {
                 setGenerationError(
                    'Failed to generate insights. Your API key is not valid for this domain (localhost).\n\n' +
                    'Please go to the Google Cloud Console and ensure your API key has "localhost" added to the allowed HTTP referrers, or remove domain restrictions for local development.'
                );
            } else {
                setGenerationError('Failed to generate insights. An unknown error occurred. Please try again.');
            }
        } finally {
            setIsGenerating(false);
        }
    };


    const renderContent = () => {
        if (!stats) {
            return (
                <div className="bg-light-card dark:bg-dark-card rounded-lg p-8 text-center shadow-sm mt-8">
                    <h2 className="text-2xl font-bold mb-4">No Data Yet!</h2>
                    <p className="text-light-text-muted dark:text-dark-text-muted">
                        No finished matches found for {selectedSport}. Play some games to see your analytics here.
                    </p>
                </div>
            );
        }

        const sportColorMap: Record<Sport, string> = {
            [Sport.Basketball]: '#F97316', // orange-500
            [Sport.Soccer]: '#10B981', // emerald-500
            [Sport.Volleyball]: '#0EA5E9', // sky-500
        };
        
        const sportColorTextClasses: Record<Sport, string> = {
            [Sport.Basketball]: 'text-orange-500',
            [Sport.Soccer]: 'text-green-500',
            [Sport.Volleyball]: 'text-sky-500',
        };

        // FIX: Cast the result of Object.entries to a specific tuple type [Sport, number][]
        // to ensure type safety for 'sport' and 'count' in strict mode. This resolves the error
        // where `sport` was inferred as `unknown` and used as a React key.
        const donutChartData = (Object.entries(stats.matchesBySport) as [Sport, number][])
          .map(([sport, count]) => ({
            label: sport,
            value: count,
            color: sportColorMap[sport] || '#6B7280',
          }))
          .sort((a, b) => b.value - a.value);
        
        const topTeams = stats.leaderboard.slice(0, 5);
        const barChartData = topTeams.map(team => ({
            label: team.teamConfig.name,
            color: team.teamConfig.color,
            totalGames: team.totalGames,
            values: [
                { value: team.wins, color: '#22C55E', label: 'Wins' },
                { value: team.losses, color: '#EF4444', label: 'Losses' },
                { value: team.ties, color: '#6B7280', label: 'Ties' },
            ]
        }));

        return (
            <div key={selectedSport} className="animate-fade-in">
                <div className="bg-light-card dark:bg-dark-card p-6 rounded-xl shadow-sm my-8 animate-slide-in-bottom">
                    <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-4">
                        <h2 className="text-xl font-bold flex items-center gap-2">
                            <SparkleIcon />
                            AI-Powered Summary {selectedSport !== 'All' ? `for ${selectedSport}` : ''}
                        </h2>
                        <button
                            onClick={handleGenerateSummary}
                            disabled={isGenerating}
                            className="bg-brand-blue hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded-lg text-sm disabled:opacity-50 disabled:cursor-wait w-full sm:w-auto"
                        >
                            {isGenerating ? 'Analyzing...' : 'Generate Insights'}
                        </button>
                    </div>
                    {isGenerating && <div className="text-center p-4 text-light-text-muted dark:text-dark-text-muted">Generating your analytics summary...</div>}
                    {generationError && <div className="text-center p-4 text-brand-red font-semibold whitespace-pre-wrap">{generationError}</div>}
                    {aiSummary && (
                        <div className="p-4 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg">
                            <p className="text-light-text dark:text-dark-text whitespace-pre-wrap font-mono">{animatedSummary}</p>
                        </div>
                    )}
                </div>

                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                   <button
                        onClick={() => setIsTotalMatchesModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{animationDelay: '100ms'}}
                        aria-label="View details for all played matches"
                    >
                        <KpiCard icon={<ListIcon />} title="Total Matches Played" value={allFinishedMatches.length} description="Click to view all games" isCounting />
                    </button>
                    <button
                        onClick={() => setIsMostPlayedSportModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{ animationDelay: '200ms' }}
                        aria-label="View sport popularity breakdown"
                    >
                        <KpiCard icon={<ChartBarIcon />} title="Most Played Sport" value={stats.kpis.mostPlayedSportName} description="Click to see breakdown" />
                    </button>
                   <button
                        onClick={() => setIsHighestScoringGamesModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{ animationDelay: '300ms' }}
                        aria-label="View highest scoring games by sport"
                    >
                     <KpiCard 
                        icon={<FireIcon />} 
                        title="Highest Scoring Game" 
                        description="Click to see breakdown"
                    >
{/* FIX: Using Object.keys on a typed record is a safer way to iterate over enum members than Object.values, preventing potential type errors in strict mode. */}
                        <div className="flex items-end justify-around gap-2 mt-2 w-full text-center">
                            {(Object.keys(sportColorTextClasses) as Sport[]).map(sport => (
                                <div key={sport} className="flex flex-col items-center flex-1">
                                    <SportIcon sport={sport} className={`h-5 w-5 mb-1 ${sportColorTextClasses[sport]}`} />
                                    <span className="text-xl font-bold font-mono">
                                        {stats.highestGamesBySport[sport]?.total ?? '-'}
                                    </span>
                                </div>
                            ))}
                        </div>
                    </KpiCard>
                   </button>
                   <button
                        onClick={() => setIsMostDecisiveVictoryModalOpen(true)}
                        disabled={!stats}
                        className="text-left animate-slide-in-bottom focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-light-background dark:focus:ring-offset-dark-background focus:ring-brand-blue rounded-xl disabled:cursor-not-allowed"
                        style={{animationDelay: '400ms'}}
                        aria-label="View most decisive victories by sport"
                    >
                        <KpiCard
                            icon={<TrendingUpIcon />}
                            title="Most Decisive Victory"
                            description="Click to see breakdown"
                        >
{/* FIX: Using Object.keys on a typed record is a safer way to iterate over enum members than Object.values, preventing potential type errors in strict mode. */}
                            <div className="flex items-end justify-around gap-2 mt-2 w-full text-center">
                                {(Object.keys(sportColorTextClasses) as Sport[]).map(sport => (
                                    <div key={sport} className="flex flex-col items-center flex-1">
                                        <SportIcon sport={sport} className={`h-5 w-5 mb-1 ${sportColorTextClasses[sport]}`} />
                                        <span className="text-xl font-bold font-mono">
                                            {`+${stats.mostDecisiveVictoriesBySport[sport]?.diff ?? 0}`}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </KpiCard>
                   </button>
                </div>

                <div className="grid grid-cols-1 xl:grid-cols-5 gap-8">
                    <div className="xl:col-span-3 bg-light-card dark:bg-dark-card p-6 rounded-xl shadow-sm animate-slide-in-bottom" style={{animationDelay: '500ms'}}>
                         <h2 className="text-xl font-bold mb-4">Team Leaderboard</h2>
                         <div className="overflow-x-auto">
                            <table className="w-full text-left">
                                <thead>
                                    <tr className="border-b border-light-border dark:border-dark-border text-sm text-light-text-muted dark:text-dark-text-muted">
                                        <th className="p-2">#</th>
                                        <th className="p-2">Team</th>
                                        <th className="p-2 text-center">W</th>
                                        <th className="p-2 text-center">L</th>
                                        <th className="p-2 text-center">GP</th>
                                        <th className="p-2 text-right">Win %</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {stats.leaderboard.map((team: TeamStat & { winRate: number }, index) => {
                                        const animationDelay = `${500 + index * 50}ms`;
                                        return (
                                        <tr 
                                            key={team.teamConfig.name} 
                                            onClick={() => setSelectedTeam(team)}
                                            className="border-b border-light-border dark:border-dark-border last:border-b-0 hover:bg-light-card-secondary dark:hover:bg-dark-card-secondary cursor-pointer leaderboard-row-hover animate-slide-in-bottom"
                                            style={{
                                                '--team-glow-color': `${team.teamConfig.color}50`,
                                                animationDelay
                                            } as React.CSSProperties}
                                        >
                                            <td className="p-2 font-semibold text-light-text dark:text-dark-text">{index + 1}</td>
                                            <td className="p-2 font-bold" style={{ color: team.teamConfig.color }}>{team.teamConfig.name}</td>
                                            <td className="p-2 text-center font-mono text-green-500">{team.wins}</td>
                                            <td className="p-2 text-center font-mono text-brand-red">{team.losses}</td>
                                            <td className="p-2 text-center font-mono text-light-text dark:text-dark-text">{team.totalGames}</td>
                                            <td className="p-2 text-right font-mono font-semibold text-light-text dark:text-dark-text">{team.winRate.toFixed(1)}%</td>
                                        </tr>
                                    );
                                    })}
                                </tbody>
                            </table>
                         </div>
                    </div>
                    <div className="xl:col-span-2 space-y-8 animate-slide-in-bottom" style={{animationDelay: '600ms'}}>
                        {selectedSport === 'All' && <DonutChart data={donutChartData} title="Sport Popularity" />}
                        <BarChart data={barChartData} title={`Top 5 Teams (by Wins)${selectedSport !== 'All' ? ` in ${selectedSport}` : ''}`} />
                    </div>
                </div>
            </div>
        );
    };

    return (
        <div className="p-4 sm:p-6 md:p-8">
            <h1 className="text-4xl md:text-5xl font-bold font-display mb-8">Analytics</h1>

            <div className="mb-6 flex flex-wrap items-center gap-2 p-1.5 bg-light-card-secondary dark:bg-dark-card-secondary rounded-lg">
                {(['All', ...Object.values(Sport)] as const).map(sport => (
                    <button
                        key={sport}
                        onClick={() => setSelectedSport(sport)}
                        className={`flex-1 px-4 py-2 text-sm font-semibold rounded-md transition-colors ${
                            selectedSport === sport
                                ? 'bg-light-card dark:bg-dark-card shadow-sm text-brand-blue'
                                : 'text-light-text-muted dark:text-dark-text-muted hover:text-light-text dark:hover:text-dark-text'
                        }`}
                    >
                        {sport}
                    </button>
                ))}
            </div>
            
            {renderContent()}
            
            {selectedTeam && (
                <TeamDetailModal
                    team={selectedTeam}
                    matches={finishedMatches}
                    onClose={() => setSelectedTeam(null)}
                />
            )}

            {isTotalMatchesModalOpen && stats && (
                <TotalMatchesModal
                    matches={allFinishedMatches}
                    onClose={() => setIsTotalMatchesModalOpen(false)}
                />
            )}

            {isMostPlayedSportModalOpen && stats && (
                <MostPlayedSportModal
                    matchesBySport={stats.matchesBySport}
                    onClose={() => setIsMostPlayedSportModalOpen(false)}
                />
            )}

            {isHighestScoringGamesModalOpen && stats && (
                <HighestScoringGamesModal
                    highestGamesBySportTime={stats.highestGamesBySportTime}
                    highestGamesBySportScore={stats.highestGamesBySportScore}
                    onClose={() => setIsHighestScoringGamesModalOpen(false)}
                />
            )}

            {isMostDecisiveVictoryModalOpen && stats && (
                <MostDecisiveVictoryModal
                    mostDecisiveVictoriesBySportTime={stats.mostDecisiveVictoriesBySportTime}
                    mostDecisiveVictoriesBySportScore={stats.mostDecisiveVictoriesBySportScore}
                    onClose={() => setIsMostDecisiveVictoryModalOpen(false)}
                />
            )}
        </div>
    );
};

export default AnalyticsPage;
--- END FILE: src\components\AnalyticsPage.tsx ---

--- START FILE: tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
--- END FILE: tsconfig.json ---

--- START FILE: types.ts ---
export enum Sport {
  Basketball = 'Basketball',
  Soccer = 'Soccer',
  Volleyball = 'Volleyball',
}

export interface Team {
  name: string;
  score: number;
  color: string;
}

export interface TeamConfig {
    name: string;
    color: string;
}

export interface TeamStat {
  wins: number;
  losses: number;
  ties: number;
  totalGames: number;
  teamConfig: TeamConfig;
}

export interface SavedTeam {
    id: string;
    name: string;
    color: string;
    sport?: Sport | 'Universal';
}

export interface MatchConfig {
  sport: Sport;
  teamA: TeamConfig;
  teamB: TeamConfig;
  durationMinutes: number;
  durationSeconds: number;
  periods: number;
  gameMode?: 'time' | 'score';
  targetScore?: number;
}

export type PauseReason = 'Timeout' | 'Foul' | 'Violation' | 'Challenge';

export enum GameStatus {
  NotStarted = 'NOT_STARTED',
  InProgress = 'IN_PROGRESS',
  Paused = 'PAUSED',
  PeriodBreak = 'PERIOD_BREAK',
  Finished = 'FINISHED',
  TieBreak = 'TIE_BREAK',
}

export interface GameState {
  teamA: Team;
  teamB: Team;
  currentPeriod: number;
  pauseReason?: PauseReason | null;
  status: GameStatus;
  setScores?: { a: number; b: number }; // For volleyball
  winner?: 'A' | 'B' | 'TIE' | null;
  message?: string | null; // For overlays
  periodScores: Array<{ a: number; b: number }>;
  notification?: { message: string };
}

export type Theme = 'light' | 'dark' | 'coder' | 'viola';

export type View = 'landing' | 'dashboard' | 'setup' | 'match' | 'audience' | 'settings' | 'analytics' | 'history' | 'teams';

export enum Font {
    Display = 'display',
    Mono = 'mono',
    Sans = 'sans',
}

export enum Layout {
    Wide = 'wide',
    Compact = 'compact',
}

export interface SportDefaultSettings {
    durationMinutes: number;
    durationSeconds: number;
    periods: number;
    targetScore: number;
}

export interface Settings {
    theme: Theme;
    font: Font;
    layout: Layout;
    defaultSport: Sport;
    defaultTeamAColor: string;
    defaultTeamBColor: string;
    sportDefaults: Record<Sport, SportDefaultSettings>;
}

export type MatchStatus = 'In Progress' | 'Finished' | 'Upcoming';

export type Match = MatchConfig & {
  id: string;
  status: MatchStatus;
  isArchived?: boolean;
  isCompleted?: boolean;
  finalScoreA?: number;
  finalScoreB?: number;
  periodScores?: Array<{ a: number; b: number }>;
};
--- END FILE: types.ts ---

--- START FILE: utils.ts ---
export const getDateFromId = (id: string, options: Intl.DateTimeFormatOptions = {
    year: 'numeric', month: 'long', day: 'numeric'
}): string => {
    try {
        const timestamp = parseInt(id.split('-')[1], 10);
        if (isNaN(timestamp)) return 'Unknown Date';
        return new Date(timestamp).toLocaleDateString(undefined, options);
    } catch (e) {
        return 'Unknown Date';
    }
};
--- END FILE: utils.ts ---

--- START FILE: vite.config.ts ---
import { URL, fileURLToPath } from 'url';
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      resolve: {
        alias: {
          // FIX: `__dirname` is not available in ES modules.
          // Using `import.meta.url` is the standard way to get the current file's path.
          '@': fileURLToPath(new URL('.', import.meta.url)),
        }
      }
    };
});
--- END FILE: vite.config.ts ---

